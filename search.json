[{"title":"Java ProjectReactor框架之Flux篇","url":"/articles/almond/Java%20ProjectReactor-Flux/","content":"\nSpring5现处在第四个预发布版，正式版将要发布了，它带来的一大特性就是响应式框架Spring WebFlux。默认使用ProjectReactor框架。因此。本文通过ProjectReactor中的Flux，来学习使用该框架，以及了解其传递的思想。   \n\n本文基于Reactor3.1 rc1    \n\nReactor官方地址<http://projectreactor.io/>，官方文档写的十分详细，如果您有不错的英文能力，建议直接阅读官方文档。  \n\n<!-- more -->\n\n### Spring WebFlux 实践\n首先，为大家带来一个使用了ProjectReactor的例子，该例子使用Spring Boot 2.0.0.BUILD-SNAPSHOT。因Spring Boot推荐默认配置（约定）优先，可以极大减少大量的重复的模版化代码，简化搭建过程。   \n\n*Spring Boot 2.0.0稳定版还未出，不过也快了，目前处在第四个里程碑版本。*   \n\n#### step1:搭建环境\n\nspring boot部分工具如idea提供了可视化操作，选择reactive-web模块即可（你也可以多选一些你需要的模块），如果没有可视化的工具，也可访问官网的开始页面<https://start.spring.io/>，或者在pom中引入一下模块（web开发主流仍是maven，所以未采用gradle）   \n```xml\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-webflux</artifactId>\n\t\t</dependency>\n\t\t<dependency>\n\t\t\t<groupId>io.projectreactor</groupId>\n\t\t\t<artifactId>reactor-test</artifactId>\n\t\t\t<scope>test</scope>\n\t\t</dependency>\n```\n\n#### step2:编写处理类\n\n编写一个简单的处理类，TestHandler    \n```java\n@Service\n@NonNullApi\npublic class TestHandler {\n\n    public Mono<ServerResponse> data(ServerRequest request){\n        Mono<String> mono =  Mono.justOrEmpty(request.queryParam(\"data\"))\n                .defaultIfEmpty(\"this is null\")\n                .map(it -> it.concat(\"! from server webflux!\"));\n        return ServerResponse.ok().body(mono,String.class);\n    }\n\n}\n```\n\n#### step3:编写路由\n\nspring webflux也提供了函数试的路由配置，如下    \n```java\n@Configuration\npublic class RoutingConfiguration {\n\n    //...\n\n    @Bean\n    public RouterFunction<ServerResponse> testRouterFunction(TestHandler handle) {\n        return RouterFunctions.route(GET(\"/test\").and(accept(APPLICATION_JSON)), handle::data);\n    }\n\n}\n```\n\n#### step4:测试，验证\n\n当浏览器输入http://localhost:8080/test，得到结果：this is null! from server webflux!\n当浏览器输入http://localhost:8688/test?data=hi，得到结果：hi! from server webflux!\n\n*我的webflux项目地址：[GitHub](https://github.com/JiangTJ/circuasset)*\n\n### 深入学习\n\n> 看过实践后，你会发现有大量的使用Flux和Mono，它们是什么呢？\n\nFlux<T> 继承自 Publisher<T> ，用于代表拥有 0 到 n 元素的流，相对于 Mono<T> (其包含0-1个元素) 更加复杂。所以弄懂了Flux，其实也已经对Mono熟悉了。  \n\n### 静态方法\nFlux一般通过静态方法构造，所以先看看它的静态方法。 \n\n#### combineLatest\n\npublic static <T,V> Flux<V> combineLatest(Function<Object[],V> combinator, Publisher<? extends T>... sources)  \n构建一个Flux，混合由多个的发布者发布最新事件.\n\n![](https://raw.githubusercontent.com/reactor/reactor-core/v3.1.0.RC1/src/docs/marble/combinelatest.png)  \n\nType Parameters:  \nT - 表示发布者的事件类型  \nV - 被混合者混合后的类型  \nParameters:   \nsources - 发布者，提供事件  \ncombinator - 混合者，接受最新的事件，处理并传递给下游。  \nReturns:  一个以Flux为基础的混合流  \n*不同的参数方法很多，这里都只展示一个。*  \n\n#### concat\npublic static <T> Flux<T> concat(Publisher<? extends T>... sources)  \n用于连接一个流。与combineLatest不同的是，concat都是在前一个流完成后在连接新的流。而combineLatest，则哪个事件最先到的，哪个先处理。  \n\n![](https://raw.githubusercontent.com/reactor/reactor-core/v3.1.0.RC1/src/docs/marble/concat.png)  \n\nType Parameters:   \nT - 事件的类型  \nParameters:  \nsources - 一系列的发布者  \nReturns:  一个新的Flux连接了所有的发布者，并传递给下游    \n\n#### concatDelayError\n拥有与concat类似的方法，不同的是，遇到错误不提前拦截，而是等到最后发布的事件处理完成后\n\n#### create,push\npublic static <T> Flux<T> create(Consumer<? super FluxSink<T>> emitter)  \n通过FluxSink API，以同步或者异步方式创建Flux。  \n例如：  \n```java\n Flux.<String>create(emitter -> {\n\n     ActionListener al = e -> {\n         emitter.next(textField.getText());\n     };\n     // without cleanup support:\n\n     button.addActionListener(al);\n\n     // with cleanup support:\n\n     button.addActionListener(al);\n     emitter.onDispose(() -> {\n         button.removeListener(al);\n     });\n });\n```\n这是非常有用的，如果一个流，需要动态添加或者移除其他的多个事件，通过异步的api。而且，你将不必担心被取消和背压。  \n*create(Consumer<? super FluxSink<T>> emitter, FluxSink.OverflowStrategy backpressure) 设置背压方式*  \npush方法用处与使用方式与create几乎一致，它们唯一的区别在于CreateMode类型 create为PUSH_PULL，而push为PUSH_ONLY，从文档中也可以一个为多线程一个为单线程  \n\n##### backpressure(背压)概念的理解\n这里，我摘自一位大神的话，背压是指在异步场景中，被观察者发送事件速度远快于观察者的处理速度的情况下，一种告诉上游的被观察者降低发送速度的策略。简而言之，背压是流速控制的一种策略。  \n> 更多的背压到<http://www.jianshu.com/p/2c4799fa91a4>这里不多做介绍了    \n\n#### defer\npublic static <T> Flux<T> defer(Supplier<? extends Publisher<T>> supplier)  \n这个方法提供了一种惰性策略，发布者不会一开始发布消息，直到订阅者创建实例.  \n![](https://raw.githubusercontent.com/reactor/reactor-core/v3.1.0.RC1/src/docs/marble/defer.png)  \nType Parameters:  \nT - 发布者发布或订阅者接受的类型  \nParameters:  \nsupplier - 一个发布者的供应者，当订阅的时候回调  \nReturns: 一个惰性的Flux  \n#### empty\npublic static <T> Flux<T> empty()  \n创建一个不含任何事件的流.\n#### error\npublic static <T> Flux<T> error(Throwable error)  \n返回一个带着立即终止标识和错误信息的流 \n#### first\npublic static <I> Flux<I> first(Publisher<? extends I>... sources)  \n挑选出第一个发布者，由其提供事件。能有效避免多个源的冲突。  \n![](https://raw.githubusercontent.com/reactor/reactor-core/v3.1.0.RC1/src/docs/marble/firstemitting.png)  \n#### from\npublic static <T> Flux<T> from(Publisher<? extends T> source)  \npublic static <T> Flux<T> fromIterable(Iterable<? extends T> it)  \npublic static <T> Flux<T> fromStream(Stream<? extends T> s)  \n从一个发布者创建一个flux流  \n#### fromArray，fromIterable，fromStream\npublic static <T> Flux<T> fromArray(T[] array)\n通过一个数组，或者一个可迭代的元素，或者一个流，创建flux流.  \n\n![](https://raw.githubusercontent.com/reactor/reactor-core/v3.1.0.RC1/src/docs/marble/fromarray.png)  \n\nType Parameters:  \nT - 数组的类型和Flux的类型  \nParameters:  \nemmm.. - 数组,可迭代的元素,流  \nReturns: 新的flux流  \n\n#### generate\npublic static <T> Flux<T> generate(Consumer<SynchronousSink<T>> generator)  \nProgrammatically create a Flux by generating signals one-by-one via a consumer callback.  \n\n![](https://raw.githubusercontent.com/reactor/reactor-core/v3.1.0.RC1/src/docs/marble/generate.png)  \n\nType Parameters:  \nT - the value type emitted  \nParameters:  \ngenerator - Consume the SynchronousSink provided per-subscriber by Reactor to generate a single signal on each pass.\nReturns: a Flux   \n没看懂，好像是说，通过编程方式创建一个一对一的消费回调  \n\n#### interval\npublic static Flux<Long> interval(Duration period)  \n间隔一定的时间，发送事件。  \nRuns on the Schedulers.parallel() Scheduler.  \n![](https://raw.githubusercontent.com/reactor/reactor-core/v3.1.0.RC1/src/docs/marble/interval.png)  \n\n#### just\npublic static <T> Flux<T> just(T... data)  \n创建一个包含一系列元素的flux流  \n![](https://raw.githubusercontent.com/reactor/reactor-core/v3.1.0.RC1/src/docs/marble/justn.png)  \n\n#### merge\npublic static <I> Flux<I> merge(Publisher<? extends I>... sources)  \n混合多个流，和combineLatest类似，但它要求是同类型的流合并，combineLatest需要提供合并方式  \n![](https://raw.githubusercontent.com/reactor/reactor-core/v3.1.0.RC1/src/docs/marble/merge.png) \n\n#### never\npublic static <T> Flux<T> never()  \nCreate a Flux that will never signal any data, error or completion signal.  \n\n![](https://raw.githubusercontent.com/reactor/reactor-core/v3.1.0.RC1/src/docs/marble/never.png)  \n\nType Parameters:  \nT - the Subscriber type target  \nReturns:  \na never completing Flux  \n看一看，不是很明白，该流的用处。 \n\n#### range\npublic static Flux<Integer> range(int start, int count)  \n提供从start，到start + count的所有整数的flux流\n\n#### switchOnNext\npublic static <T> Flux<T> switchOnNext(Publisher<? extends Publisher<? extends T>> mergedPublishers)  \n从最新的发布者那里获取事件，如果有新的发布者加入，则改用新的发布者。  \n当最后一个发布者完成所有发布事件，并且没有发布者加入，则flux完成。  \n![](https://raw.githubusercontent.com/reactor/reactor-core/v3.1.0.RC1/src/docs/marble/switchonnext.png)\n\n#### using\npublic static <T,D> Flux<T> using(Callable<? extends D> resourceSupplier, Function<? super D,? extends Publisher<? extends T>> sourceSupplier, Consumer<? super D> resourceCleanup)  \nUses a resource, generated by a supplier for each individual Subscriber, while streaming the values from a Publisher derived from the same resource and makes sure the resource is released if the sequence terminates or the Subscriber cancels.  \nEager resource cleanup happens just before the source termination and exceptions raised by the cleanup Consumer may override the terminal even.\n\n![](https://raw.githubusercontent.com/reactor/reactor-core/v3.1.0.RC1/src/docs/marble/using.png)\n\n#### zip\npublic static <I,O> Flux<O> zip(Function<? super Object[],? extends O> combinator, Publisher<? extends I>... sources)\n通过混合者，合并多个流成一个输出流，一一对应合并\n![](https://raw.githubusercontent.com/reactor/reactor-core/v3.1.0.RC1/src/docs/marble/zip.png)  \n\n#### ...\n看一下下面的api  \npublic static <T1,T2,T3,V> Flux<V> combineLatest(Publisher<? extends T1> source1, Publisher<? extends T2> source2, Publisher<? extends T3> source3, Function<Object[],V> combinator) \npublic static <T1,T2,T3,T4,V> Flux<V> combineLatest(Publisher<? extends T1> source1, Publisher<? extends T2> source2, Publisher<? extends T3> source3, Publisher<? extends T4> source4, Function<Object[],V> combinator)   \n...  \npublic static <T1,T2> Flux<Tuple2<T1,T2>> zip(Publisher<? extends T1> source1, lisher<? extends T2> source2)  \npublic static <T1,T2,T3> Flux<Tuple3<T1,T2,T3>> zip(Publisher<? extends T1> source1, lisher<? extends T2> source2, lisher<? extends T3> source3)  \n...  \nヽ(o_ _)o摔倒，我也是服了project reactor 官方。\n\n### 常用的实例方法\n静态的方法介绍完了，但是实例方法比静态方法多太多，所以这里只举常用的几种介绍\n\n#### all,any,hasElement,hasElements\n这几个方法调用，均返回包涵一个Boolean信号的Mono。\n- all(Predicate<? super T> predicate)表示所有值均满足条件\n- any(Predicate<? super T> predicate)表示存在一个值满足条件\n- hasElement(T t)表示是否存在该值\n- hasElements()表示是否拥有一个或多个元素\n\n#### as,compose\npublic final <P> P as(Function<? super Flux<T>,P> transformer)   \n转化flux为一个目标类型。   \n官方例子：flux.as(Mono::from).subscribe()  \n将flux通过Mono.from函数转化为mono   \npublic final <V> Flux<V> compose(Function<? super Flux<T>,? extends Publisher<V>> transformer)    \ncompose与as的区别是转化类型做了限制，必须继承Publisher，同时compose是惰性的。在很多时候，写法上没有差别如flux.compose(Mono::from).subscribe()   \n\n#### blockFirst,blockLast\n阻塞至第一个或者最后一个值处理完成\n\n#### butter系列\n该系列实例方法很多，作用是将一系列元素，分成一组或者多组，该方法可用在按组批量操作上，例如，以时间间隔分组，批量添加数据。\n\n#### cache\n如其名缓存，相当于复制一份用于接下来的操作，而当前的流将会被缓存起来，用于之后的操作。\n\n#### cancelOn\npublic final Flux<T> cancelOn(Scheduler scheduler)  \n取消\n\n#### cast\npublic final <E> Flux<E> cast(Class<E> clazz)\n强转\n\n#### checkpoint\n用于检测当前节点，流中是否存在错误\n\n#### collect系列\n该系列实例方法，用于收集所有的元素到特定类型，如list、map等  \n处理完成时返回Mono\n\n#### concatMap系列,flatMap系列\n举例说明吧，[[1,2],[4,5],[6,7,8]] -> [1,2,4,5,6,7,8]起这种转化作用  \n![](https://raw.githubusercontent.com/reactor/reactor-core/v3.1.0.RC1/src/docs/marble/concatmap.png)  \nflatMap系列一样  \n\n#### concatWith\n与concatMap不同，这是相加  \n![](https://raw.githubusercontent.com/reactor/reactor-core/v3.1.0.RC1/src/docs/marble/concat.png)  \n#### defaultIfEmpty\npublic final Flux<T> defaultIfEmpty(T defaultV) 默认值  \n\n#### distinct\npublic final Flux<T> distinct()   \n去重，相对与jdk8，多了下面两种方法   \npublic final <V> Flux<T> distinct(Function<? super T,? extends V> keySelector)  \npublic final <V,C extends Collection<? super V>> Flux<T> distinct(Function<? super T,? extends V> Supplier<C> distinctCollectionSupplier)\n去除与V匹配的和第二个不怎么理解，，，这让我想到了filter  \n\n#### do系列\n还系列有doOnNext,doOnError,doOnCancel等等，均表示完成后触发\n\n#### elementAt\n返回某一位置的值，类型为Mono<T>，可以设置默认值\n\n#### filter\npublic final Flux<T> filter(Predicate<? super T> p)  \n过滤出满足条件的  \n\n#### groupBy\npublic final <K> Flux<GroupedFlux<K,T>> groupBy(Function<? super T,? extends K> keyMapper)  \n![](https://raw.githubusercontent.com/reactor/reactor-core/v3.1.0.RC1/src/docs/marble/groupby.png)  \n分组，根据提供的keyMapper\n\n#### mark\n标记一下，写到h接下来还有一些要写，暂时不写了，太累。。。先写会实践（实践提前放在开头，入门）  \n\n\n*未完待续*","categories":["后端"],"tags":["WebFlux","Reactor","Reactive"]},{"title":"Java设计模式之建筑者模式.","url":"/articles/almond/Java-builder-example/","content":"初看java设计模式-建造者模式时，肯定有和我一样有疑惑的。网上的例子几乎都一样，但是却没new xxx.Builder().buildxx().buildxx()...这样的。那么我今天来讲讲这种建造者模式的实现。\n\n首先按照我的惯例，先给例子后解说\n\n### 例子\n\nProduct.java\n<!-- more -->\n```java\npackage com.jtj.builder;\n\npublic class Product {\n\n\tprivate String part1;\n\tprivate String part2;\n\tprivate String part3;\n\t\n\tpublic String getPart1() {\n\t\treturn part1;\n\t}\n\tpublic void setPart1(String part1) {\n\t\tthis.part1 = part1;\n\t}\n\tpublic String getPart2() {\n\t\treturn part2;\n\t}\n\tpublic void setPart2(String part2) {\n\t\tthis.part2 = part2;\n\t}\n\tpublic String getPart3() {\n\t\treturn part3;\n\t}\n\tpublic void setPart3(String part3) {\n\t\tthis.part3 = part3;\n\t}\n\t\n\tpublic String getProduct(){\n\t\treturn new StringBuilder().append(part1)\n\t\t\t\t.append(\",\")\n\t\t\t\t.append(part2)\n\t\t\t\t.append(\",\")\n\t\t\t\t.append(part3)\n\t\t\t\t.toString();\n\t}\n\t\n\tpublic static class Builder{\n\t\t\n\t\tprivate Product product;\n\t\t\n\t\tpublic Builder(){\n\t\t\tproduct=new Product();\n\t\t}\n\n\t\tpublic Builder buildPart1(String part1){\n\t\t\tproduct.setPart1(part1);\n\t\t\treturn this;\n\t\t}\n\t\tpublic Builder buildPart2(String part2){\n\t\t\tproduct.setPart2(part2);\n\t\t\treturn this;\n\t\t}\n\t\tpublic Builder buildPart3(String part3){\n\t\t\tproduct.setPart3(part3);\n\t\t\treturn this;\n\t\t}\n\t\tpublic Product build(){\n\t\t\treturn product;\n\t\t}\n\t\t\n\t}\n\n}\n```\nMain.java\n```java\npackage com.jtj.builder;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tProduct product = new Product.Builder()\n\t\t        .buildPart1(\"qq\")\n\t\t\t\t.buildPart2(\"2\")\n\t\t\t\t.buildPart3(\"sa\")\n\t\t\t\t.build();\n\t\tSystem.out.println(product.getProduct());\n\t}\n\n}\n```\n\n### 结果\n\n```java\nqq,2,sa\n```\n\n### 说明\nproduct是产品，是我们需要构建的对象，里面有静态的构造器Builder，由于是静态类，里面构造方法在使用的时候最开始便会构造，也就是里面的product每次使用时都会先实例化一个。\n之后每次buildxxx后，我们可以看到返回的都是this,也就是这个静态类，就是这个原因，我们便可以在后面不断的连续buildxxx。\n最后通过一个build返回所实例化的product。  \n\n### Lombok\n\n> Lombok更优雅的方式实现建造者模式（17-10-25更新）\n\nLombok,可以通过注解方式，减少大量的臃肿的代码。比如getter和setter，看着就头疼。使用Lombok，你可以直接@Getter和@Setter来代替这部分，当然一般都是@Data，把一些列常用的注解都加上。   \n除了这些，它还提供了一些其他的不常用到的注解，来消除特定场合的臃肿的代码。比如@Cleanup减少try...catch，@Log减少写获取log实例的代码。这些都很实用。   \n当然，这里要讲的是与建造者相关的@Builder，还是看代码把    \n```java\n@Data//=@Setter @Getter @ToString @EqualsAndHashCode\n//这个@Builder就是用来生成建造者模式的，只需要小小的一个注解，就能实现了\n@Builder\n//下面两个注解，因为@Builder必须要全属性构造方法，才能使用。\n//虽然默认会生成全属性构造方法，但使用@NoArgsConstructor会覆盖掉这个默认，因此需要添加@AllArgsConstructor\n@NoArgsConstructor\n@AllArgsConstructor\npublic class TestEntity {\n    private String name;\n    private Integer age;\n}\n```\n实现过程相当简单，为它我也编写了一个测试类    \n```java\n//这个也是Lombok的一个注解\n@Slf4j\npublic class TestEntityTest {\n    @Test\n    public void test() {\n        TestEntity entity = TestEntity.builder()\n                .name(\"MrJ\")\n                .age(100)\n                .build();\n        log.error(entity.toString());\n    }\n}\n```\n在控制台中看到有`TestEntity(name=MrJ, age=100)`的输出，证明是成功的。","categories":["后端"],"tags":["设计模式"]},{"title":"Spring Data Jpa与Mybatis的选择","url":"/articles/almond/Spring-data-jpa-and-Mybatis/","content":"\n看了会jpa的文档，感觉挺不错的，如果都是增删改和简单查询，那基本就不用写sql，同时数据库也交由jpa管理，省心。  \n当然jpa也绝对不全是优点，当默认的规范生成sql不能满足我们的业务的时候。mybatis直接写sql更简单，更易实现。而且，我们也可以更好的调整sql以提升性能（sql的调优后，性能成倍提高的）。   \n> 那么，他们之间改怎么选择呢  \n\n<!-- more -->\n\n### 使用 spring data jpa\n- 打算自己维护一个开源项目，但却没时间管理数据库（我在这里，准备使用）\n- 公司的项目是为其他公司服务的，有需要跑在不同数据库上，不追求性能（mybatis也能多数据库，但是你得为不同的数据库写不同的sql）\n- 小项目，需快速完成  \n- 报表不多，且对性能要求不高的项目  \n### 使用mybatis\n- 公司内部系统，由内部员工开发，同时也有专门的dba把控数据库\n- 对性能要求比较高\n- 报表较多的项目\n- 有很复杂的数据库操作\n\n> 当然最重要的：对哪个熟悉用哪个\n\n> 不知道写全没，最后引用一句话：jpa适合领域模型，mybatis适合事务脚本","categories":["后端"],"tags":["Jpa","Mybatis"]},{"title":"Aria2 一个轻量级的命令行下载工具","url":"/articles/almond/aria2-info/","content":"\naria2 是一个轻量级的、多源、跨平台的命令行下载实用工具。它支持HTTP/HTTPS、FTP、SFTP、BitTorrent和Metalink。       \n我们可以在GitHub上下载最新的[稳定版](https://github.com/aria2/aria2/releases)     \n\n<!-- more -->\n\n# 特点\n- Multi-Connection Download. aria2 can download a file from multiple sources/protocols and tries to utilize your maximum download bandwidth. Really speeds up your download experience.\n- 多线程连接下载，最大限度的利用您的宽带\n\n- Lightweight. aria2 doesn’t require much memory and CPU time. When disk cache is off, the physical memory usage is typically 4MiB (normal HTTP/FTP downloads) to 9MiB (BitTorrent downloads). CPU usage in BitTorrent with download speed of 2.8MiB/sec is around 6%.\n- 轻量级，不需要太多的内存与cpu资源\n\n- Fully Featured BitTorrent Client. All features you want in BitTorrent client are available: DHT, PEX, Encryption, Magnet URI, Web-Seeding, Selective Downloads, Local Peer Discovery and UDP tracker.\n- 支持所有的BitTorrent的客户端特性\n\n- Metalink Enabled. aria2 supports The Metalink Download Description Format (aka Metalink v4), Metalink version 3 and Metalink/HTTP. Metalink offers the file verification, HTTP/FTP/SFTP/BitTorrent integration and the various configurations for language, location, OS, etc.\n- 支持Metalink\n\n- Remote Control. aria2 supports RPC interface to control the aria2 process. The supported interfaces are JSON-RPC (over HTTP and WebSocket) and XML-RPC.\n- 支持远程控制下载\n\n# 如何使用\n\n*建议添加aria2所在目录到系统path中，方便在任意位置使用aria2c命令*     \n\n1. 从网上下载文件:\n```bash\n$ aria2c http://example.org/mylinux.iso\n```\n2. 同时下载多个文件\n```bash\n$ aria2c http://a/f.iso ftp://b/f.iso\n```\n3. 使用两个连接下载\n```bash\n$ aria2c -x 2 http://a/f.iso\n```\n4. 使用BitTorrent下载\n```bash\n$ aria2c http://example.org/mylinux.torrent\n```\n5. 使用BitTorrent Magnet URI下载:\n```bash\n$ aria2c 'magnet:?xt=urn:btih:248D0A1CD08284299DE78D5C1ED359BB46717D8C'\n```\n6. 下载文本中的连接\n```bash\n$ aria2c -i uris.txt\n```\n7. 修改名称与路径\n```bash\n$ aria2c http://example.org/a.txt -o b.txt -d your-dir\n```\n\n# UI 框架\n- [webui-aria2](https://github.com/ziahamza/webui-aria2): 一个网页端的aria2实现\n- [persepolis](https://github.com/persepolisdm/persepolis): 一个python写的aria2的客户端\n\n# 参考\n- [aria2 docs](https://aria2.github.io/)\n","categories":["工具"]},{"title":"Dart之环境搭建","url":"/articles/almond/dart-get-start/","content":"\n\nDart 是一种易学习、易扩展、跨平台的编程语言。   \n\n- 易学习：语法感觉很熟悉，语义是干净和一致的。是Java与Javascript的结合体。\n- 易扩展：仅谷歌就有超过200万行的生产Dart代码。应用程序可以达到数十万行代码。\n- 跨平台：Dart可以在每一个现代浏览器、命令行、服务器和移动设备上快速运行。\n\nGoogle 在大型项目中部署使用 Dart。例如，下一代的AdWords (谷歌最重要的赚钱应用)运行在Dart上。   \n\n<!-- more -->\n\n### 下载\n\nwindows可下载安装程序，也可以使用Chocolatey来安装  \n下载地址：<https://www.dartlang.org/install>    \n*需翻墙*  \n\n### 工具\n\n推荐下载WebStorm   \n下载地址：<https://www.jetbrains.com/webstorm/>  \n\n### 第一个Angular应用\n\n官方推荐使用AngularDart，当然也有其他用户维护的vue，有兴趣可以尝试下。   \n\n1. 在WebStorm的欢迎界面，选择创建新的工程。或者点击菜单的File > New > Project… 。  \n2. 在左侧的菜单中选择Dart。  \n3. 如果Dart SDK path 和 Dartium path fields没有值，选择安装路径。  \n4. 修改Location中的值，已设置位置路径与应用的名称  \n5. Generate sample content 打上勾  \n6. 选择AngularDart Web App template  \n7. 创建  \n\n![](https://webdev.dartlang.org/guides/images/create-ng2-project.png)\n\n### 运行\n\n- 右键 pubspec.yaml 选择 Pub: Get Dependencies 更新依赖.   \n- 右键 web/index.html 文件，然后选择 Run ‘index.html’  \n\n![](https://webdev.dartlang.org/guides/images/run-app-in-ws.png)  \n\n看到下面画面时就好ok咯   \n\n![](https://webdev.dartlang.org/guides/images/run-app.png)  ","categories":["前端"],"tags":["Dart"]},{"title":"Dart与Node对比","url":"/articles/almond/dart-vs-node/","content":"\n# 简介\n\n## node\nNode.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。   \nNode.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。   \nNode.js 的包管理器 npm，是全球最大的开源库生态系统。   \n\n## dart\nDart是谷歌开发的计算机编程语言，后来被Ecma(ECMA-408)认定为标准。它被用于web、服务器、移动应用和物联网等领域的开发。它是宽松开源许可证（修改的BSD证书）下的开源软件。    \nDart是面向对象的、类定义的、单继承的语言。它的语法类似C语言，可以转译为JavaScript，支持接口(interfaces)、混入(mixins)、抽象类(abstract classes)、具体化泛型(reified generics)、可选类型(optional typing)和sound type system。 \n\n<!-- more -->  \n\n本篇文章基于node 8.11 与 dart 2.0-dev58   \n\n# 包管理\n\n对于任意一门语言，在依赖库膨胀的今天，包管理越来越显得重要。例如java的maven以及Swift的SPM(Swift Package Manager)    \n\n## npm\nnpm是我见过的最简单，粗暴的包管理工具   \nnpm会根据package.json查找并下载依赖至本地的node_modules文件夹上，但这种方式导致每个项目都需要下载几乎相同的依赖文件（而且很大），为解决这样的问题，Facebook开发了yarn依赖管理工具，统一下载依赖本件，复制相关文件至对应的项目，以减少下载慢的问题。当然还有其他方案，例如pnpm，他通过链接，将依赖关联到统一位置，以解决网络与空间占用问题        \nnpm非常自由，每个用户都能上传与下载任意的js包，但也因此，npm的包也非常的乱，看一下angular官方的例子以及ivew的node_modules大小吧，很难想象，一个不大的项目需要这么大的依赖库    \n![](/images/md/others/node_modules1.png)   \n\n## pub\ndart的包管理工具名为pub，他的管理方式类似于pnpm。他会下载依赖至统一的目录下。而每个项目都将关联依赖至该目录    \n目前，dart库中项目大部分来自于谷歌或者谷歌移植的node库，也因此，依赖库相对于node来说小了太多，但必要的库都是有的。   \n谷歌的angular框架也基于dart进行了重新的开发，相对于TypeScript版来说，最显著的是依赖库明显少了好多     \n![](/images/md/others/pub1.png)    \n\n> **Tips**\n- pub依赖库小于npm，意味着可用的工具类或者插件较少\n- pub下载，由于国内环境，需要通过科学方式\n- dev版很不稳定，甚至连一些基础的命令都在变\n\n# JIT运行\n\n开发过程，通过JIT即时运行是非常重要的，它在一定程度上影响着开发效率，下面对比了相同的angular例子，编译运行的时间    \n\n1. node每次的编译都在5s左右\n![](/images/md/others/angular-jit-node.png)    \n\n2. dart仅在在首次会编译运行所需的文件，因此，它表现为首次编译时间十分长(约33s)，而之后的每次，都仅需较短的时间(约2-3s)\n![](/images/md/others/angular-jit-dart.png)    \n\n# AOT编译\n\n部署上线，一般情况下需要AOT编译，以保证客户端的运行效率    \n\n1. node编译之后的大小在400kb左右，不算大，毕竟对于目前4G网络来说，很快就能下完\n![](/images/md/others/angular-aot-node.png)    \n\n2. dart生成的文件与node差距不大，但其中dart编译成的js名固定为`main.dart.js`，可能存在缓存问题，期待完善 \n![](/images/md/others/angular-aot-dart.png)   \n\n# 尾\n相对于node来说，dart很不成熟，但我们也能看到它的一些好的特性。怎么说呢，期待dart的完善，也希望node能借鉴其他的语言环境，改善一下不足之处\n\n\n","categories":["前端"],"tags":["Dart","Node"]},{"title":"Spring Cloud 之 Eureka （Finchley版）","url":"/articles/almond/f-eureka-server/","content":"\n在微服务架构中，服务发现是最重要的一环。Spring Cloud提供多个服务注册中心作为选择，如Eureka、Consul、Zookeeper等，当然最常用的是Eureka\n\n# 简介\nEureka由Eureka Server与Eureka Client两部分组成    \nEureka Server是高可用的（可同时作为客户端向其他注册中心注册）服务发现的注册中心，为每个客户端（Eureka Client）提供注册服务，并提供已注册服务信息    \nEureka Client向服务注册中心注册，并提供断路、负载均衡等功能    \n\n<!-- more -->\n\n# 简单的Eureka Server\n\n启动一个Eureka Server，首先需要添加依赖\n```xml\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.cloud</groupId>\n\t\t\t<artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>\n\t\t</dependency>\n```\n\n其次，在启动类Application类中添加Eureka Server相关的注解\n```java\n@EnableEurekaServer\n@SpringBootApplication\npublic class EurekaServer {\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(EurekaServer.class, args);\n\t}\n}\n```\n\n我们启动一个简单的注册中心，需要禁用Eureka Server的客户端行为（这是默认方式，为了保证注册中心的高可用），添加以下的配置\n```yml\nserver:\n  port: 8761\n\neureka:\n  instance:\n    hostname: localhost\n    prefer-ip-address: true\n  client:\n    registerWithEureka: false\n    fetchRegistry: false\n    serviceUrl:\n      defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/\n  server:\n    enable-self-preservation: false\n```\n\n`enable-self-preservation: false`是关闭自我保护，自我保护是为了保障微服务（实际可用）与Eureka Server之间由于网络因数无法通信时，在一段时间内保留微服务，避免微服务被注销而无法提供服务的情况，由于测试环境实例过少，开启会导致难以测试，一般线上需要开启（默认）    \n`registerWithEureka`与`fetchRegistry`，用于禁用客户端行为，Eureka Server作为单个独立应用运行    \n\n# 分布式的Eureka Server\n单个Eureka Server，在大部分场景下是足够的，但当企业微服务规模扩大，单个服务难以支撑时，分布式是不可避免的，Eureka Server作为高可用的注册中心，在最初设计时就考虑了相关问题，即它作为服务注册中心的同时，它也能作为客户端，向其他注册中心发起注册    \n官方以及许多其他地方的文档基本都是两个对等Eureka Server配置，但事实上，也有需要多个对等的配置。    \n多个对等配置如下   \n1. 实例一    \n```yml\nserver:\n  port: 8761\neureka:\n  instance:\n    hostname: localhost\n  client:\n    serviceUrl:\n      defaultZone: http://localhost:9001/eureka/,http://localhost:9002/eureka/\n  server:\n    enable-self-preservation: false\n```\n\n2. 实例二  \n```yml\nserver:\n  port: 9001\neureka:\n  instance:\n    hostname: localhost\n  client:\n    serviceUrl:\n      defaultZone: http://localhost:8761/eureka/,http://localhost:9002/eureka/\n  server:\n    enable-self-preservation: false\n```\n\n3. 实例三   \n```yml\nserver:\n  port: 9002\neureka:\n  instance:\n    hostname: localhost\n  client:\n    serviceUrl:\n      defaultZone: http://localhost:9001/eureka/,http://localhost:8761/eureka/\n  server:\n    enable-self-preservation: false\n```\n这里有一点需要注意，就是将**所有的Eureka Server填写在`defaultZone`中**，并以逗号隔开，自身的地址可填，也可不填，`registerWithEureka`配置了自我注册，默认是开启的。因为服务注册中心同步注册服务，需要彼此之间相互注册，例如A与B相互注册，B与C相互注册，如果一个客户端在A上注册，那么它能在B中发现，而不会在C中发现，如果需要在C中同样发现，那么必须A与C相互注册    \n\n# Eureka Client\n客户端是微服务的一个基础，用于向服务注册中心发起注册，当然如果存在多个注册中心的情况，填写一个就好，注册中心之间会相互同步注册的服务信息    \n首先需要引入依赖    \n```xml\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n        </dependency>\n```\n\n其次，在启动类Application类中添加Eureka Client相关的注解\n```java\n@EnableEurekaClient\n//或者@EnableDiscoveryClient\n//或者@SpringCloudApplication 需要添加断路器依赖（之后会讲这块）\n@SpringBootApplication\npublic class EurekaServer {\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(EurekaServer.class, args);\n\t}\n}\n```\n\n最后添加以下的配置，其实Eureka Server包含客户端的内容，这里的配置与上面一致\n```yml\nserver:\n  port: 7001\neureka:\n  client:\n    serviceUrl:\n      defaultZone: http://localhost:8761/eureka/\n```\n\n*默认情况下`defaultZone`的值为`http://localhost:8761/eureka/`*\n","categories":["后端"],"tags":["Spring Cloud"]},{"title":"Spring Cloud 之 Feign （Finchley版）","url":"/articles/almond/f-open-feign/","content":"\nFeign是轻量级、声明式的Http请求客户端，它吸收了来自的Retrofit JAXRS-2.0和WebSocket的灵感，为了使写Http请求变得更容易而诞生    \n\nFeign一开始作为Eureka的子项目，用于简化Http请求。但由于其不断完善，目前作为一个轻量级、声明式的Http请求客户端项目，独立维护。在Spring Cloud中，其引入了Feign，并提供了一系列默认的配置与Spring MVC注解的支持。因此，Feign一直被作为首先的Http请求客户端。   \n\n<!-- more -->\n\n# 准备工作\n\n需要Eureka Server，这部分看之前的文档部署，这篇以及以后的文章不在多提\n\n搭建基础的Eureka Client，给Feign Clinet调用    \n\n## 引入web相关依赖   \n\n```xml\n        <!-- 为了方便引入了lombok -->\n        <dependency>\n            <groupId>org.projectlombok</groupId>\n            <artifactId>lombok</artifactId>\n            <optional>true</optional>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-webflux</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n        <dependency>\n            <groupId>io.projectreactor</groupId>\n            <artifactId>reactor-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n```\n## 编写Curl Controller   \n\n```java\n@Slf4j\n@RestController\npublic class CurlController {\n\n    private static ObjectMapper objectMapper;\n\n    @GetMapping(\"/curl/{id}\")\n    public Mono<String> get(@PathVariable Long id){\n        return Mono.just(id).map(item -> \"Your id is \" + item);\n    }\n\n    @GetMapping(\"/curl\")\n    public Mono<String> get(@RequestParam MultiValueMap<String,String> queryParams){\n        return Mono.just(queryParams).map(item -> \"Your QueryParams is \" + item);\n    }\n\n    @PostMapping(\"/curl\")\n    @ResponseStatus(HttpStatus.CREATED)\n    public Mono<String> post(@RequestBody Mono<User> user){\n        return user.map(CurlController::toJson).map(item -> \"Your Body is \" + item);\n    }\n\n    @PutMapping(\"/curl\")\n    public Mono<String> put(@RequestBody Mono<User> user){\n        return post(user);\n    }\n\n    @DeleteMapping(\"/curl\")\n    @ResponseStatus(HttpStatus.NO_CONTENT)\n    public void delete() {\n        throw new RuntimeException(\"Fail\");\n    }\n\n    private static ObjectMapper getObjectMapper(){\n        if (objectMapper == null) {\n            objectMapper = new ObjectMapper();\n        }\n        return objectMapper;\n    }\n    private static String toJson(Object object) {\n        ObjectMapper mapper = getObjectMapper();\n        try {\n            return mapper.writeValueAsString(object);\n        } catch (Exception e) {\n            log.error(e.getMessage());\n        }\n        return null;\n    }\n}\n```\n## 编写测试用例   \n\n```java\n@RunWith(SpringRunner.class)\n@SpringBootTest\npublic class CurlControllerTest {\n\n    @Autowired\n    private ApplicationContext context;\n\n    private WebTestClient client;\n\n    @Before\n    public void setUp() {\n        client = WebTestClient.bindToApplicationContext(context).build();\n    }\n\n    @Test\n    public void get() {\n\n        client.get().uri(\"/curl/1\")\n                .exchange()\n                .expectStatus().isOk()\n                .expectBody(String.class).isEqualTo(\"Your id is 1\");\n\n        client.get().uri(\"/curl?name=Jone Test\")\n                .exchange()\n                .expectStatus().isOk()\n                .expectBody(String.class).isEqualTo(\"Your QueryParams is {name=[Jone Test]}\");\n\n    }\n\n    @Test\n    public void post() {\n        client.post().uri(\"/curl\")\n                .contentType(MediaType.APPLICATION_JSON)\n                .syncBody(User.of(\"Jone Po\",25,1))\n                .exchange()\n                .expectStatus().isCreated()\n                .expectBody(String.class).isEqualTo(\"Your Body is {\\\"name\\\":\\\"Jone Po\\\",\\\"age\\\":25,\\\"sex\\\":1}\");\n    }\n\n    @Test\n    public void put() {\n        client.put().uri(\"/curl\")\n                .contentType(MediaType.APPLICATION_JSON)\n                .syncBody(User.of(\"Jone Po\",25,1))\n                .exchange()\n                .expectStatus().isOk()\n                .expectBody(String.class).isEqualTo(\"Your Body is {\\\"name\\\":\\\"Jone Po\\\",\\\"age\\\":25,\\\"sex\\\":1}\");\n    }\n\n    @Test\n    public void delete() {\n        client.delete().uri(\"/curl\").exchange().expectStatus().isNoContent();\n    }\n}\n```\n## 测试接口   \n\n```\n[ERROR] Tests run: 4, Failures: 1, Errors: 0, Skipped: 0, Time elapsed: 0.204 s <<< FAILURE! - in com.jtj.cloud.baseclient.CurlControllerTest\n[ERROR] delete(com.jtj.cloud.baseclient.CurlControllerTest)  Time elapsed: 0.077 s  <<< FAILURE!\n```\n测试接口如预期，成功3个，失败1个（删除接口）    \n\n# Feign服务\n\n## 相对于基础的客户端，多引入Feign依赖，并启用Feign    \n\n```xml\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.cloud</groupId>\n\t\t\t<artifactId>spring-cloud-starter-openfeign</artifactId>\n\t\t</dependency>\n```\n```java\n@EnableFeignClients\n@SpringCloudApplication\npublic class FeignClientApplication {\n    //...\n}\n```\n## 编写声明式的Feign接口   \n\n```java\n@FeignClient(value = \"base-client\")\npublic interface BaseClient {\n\n    @GetMapping(\"/\")\n    String getBaseClientData();\n\n    @GetMapping(\"/curl/{id}\")\n    String getUser(@PathVariable(\"id\") Long id);\n\n    @GetMapping(\"/curl\")\n    String getUser(@RequestParam Map<String,String> query);\n\n    @PostMapping(\"/curl\")\n    String postUser(@RequestBody User user);\n\n    @PutMapping(\"/curl\")\n    String putUser(@RequestBody User user);\n\n    @DeleteMapping(\"/curl\")\n    void deleteUser();\n\n}\n```\n该接口注解与Spring MVC的基本一致（@PathVariable不能省略value值）   \n其中@FeignClient定义该接口实例化为Feign服务并注入到Spring中，由Spring管理，value值为配置文件中微服务的名称（spring.application.name的值）   \n## 调用Feign服务   \n\n```java\n\n\t@Resource\n\tprivate BaseClient baseClient;\n\n    \n\t@GetMapping(\"/base/curl\")\n\tpublic Map<String,String> getBaseClientCurl(){\n\t\tMap<String,String> result = new HashMap<>();\n\n\t\tresult.put(\"ID 1\",baseClient.getUser(1L));\n\t\tMap<String,String> query = new HashMap<>();\n\n\t\tquery.put(\"name\",\"Jone Taki\");\n\t\tresult.put(\"Query Jone\",baseClient.getUser(query));\n\n\t\tresult.put(\"Post\",baseClient.postUser(User.of(\"Jone Tiki\",20,1)));\n\t\tresult.put(\"Put\",baseClient.postUser(User.of(\"Jone Kolo\",30,1)));\n\n\t\ttry {\n\t\t\tbaseClient.deleteUser();\n\t\t\tresult.put(\"Delete\",\"success\");\n\t\t} catch (RuntimeException e) {\n\t\t\tresult.put(\"Delete\",\"fail: \" + e.getMessage());\n\t\t}\n\n\t\treturn result;\n\t}\n\n```\n\n## 访问接口测试   \n\n我们能得到如下结果，其中Delete是失败的\n```json\n{\n    \"Delete\":\"fail: BaseClient#deleteUser() failed and no fallback available.\",\n    \"Query Jone\":\"Your QueryParams is {name=[Jone Taki]}\",\n    \"Post\":\"Your Body is {\\\"name\\\":\\\"Jone Tiki\\\",\\\"age\\\":20,\\\"sex\\\":1}\",\n    \"ID 1\":\"Your id is 1\",\n    \"Put\":\"Your Body is {\\\"name\\\":\\\"Jone Kolo\\\",\\\"age\\\":30,\\\"sex\\\":1}\"\n}\n```\n\n上述这些例子包含了基本的REST操作，也就是Feign的基本使用\n\n# 参考\n- [Feign源码地址](https://github.com/OpenFeign/feign)\n- [Spring Cloud OpenFeign 官方文档](http://cloud.spring.io/spring-cloud-openfeign/single/spring-cloud-openfeign.html)\n- [例子源码地址（可能存在改动和完善）](https://github.com/JiangTJ/spring-cloud-examples/tree/master/simple-example)\n\n\n","categories":["后端"],"tags":["Spring Cloud"]},{"title":"写给我的朋友，Java学习之路","url":"/articles/almond/for%20friend,%20how%20working%20in%20java/","content":"\n### 最重要的\n\n选择程序猿，便意味着你始终要学习。如果说想着看完这里的全部，就能靠这混吃一辈子，那还是放弃把。  \n这里是我的曾今学习的方式，但我的学习方法可能不是很适合你。所以我只当只领路羊，接下来的学习，都得靠你自己。  \n加油！\n\n<!-- more -->\n\n### 思维脑图\n\n> [点这里查看图片](http://naotu.baidu.com/file/1b2db44c2a2805df3364bb7c49b9e198?token=13ccc33fc9a41655)  \n\n这是大概的学习树，但并不全。比如maven，学java必须知道的项目构建工具，但只要了解并会简单的使用可以了，maven会随着你java的水平的提高而提高。有比如Javascript、html等前端知识，学java必须了解一些。当然学习前端，后端知识也需要懂一些。  \n先看图，了解个大概，接下来我按后端学习的内容，一步一步的讲述我的经历。\n\n### First：基础\n\n我是科班出生的，第一次接触java是java基础课。那时候都是用java命令行操作，对java文件编译及运行。这时学习的是java的概念和基本的操作。练手的话可以写个小例子。  \n\n> 任务1：建两个类，为苹果和香蕉，它们有编号和数量（有初始值）属性，要求分别对其实例化，控制台分别输入编号和消耗数量之后，打印剩余数量，再次要求输入编号和数量（循环）。  \n\n第二次接触java便是web课，也是java最擅长的领域。学了java web基础servlet（等你学过去估计就忘了，当熟练主流框架后，回过来看这是满重要的），还有个已经被淘汰的框架struts2。老师也教了一个企业级的框架ssh（现在也快淘汰了），但是没听懂。这里也布置个任务  \n\n> 任务2：用最基础的方式（jsp + servlet）实现个java web服务。  \n\n接下来还有没有java课，没印象了，毕竟就算有，技术也熟练了应付过去没问题。  \n基础部分就这样，我花了4年(其实也没那么多，印象里好像就两节android和三节java课吧)，但你肯定没那么多时间，多看看基础书把，弄清概念。任务1与2解决，基本基础过关了。  \n\n> java基础书很多，百度以后一大把，挑新的看  \n\n### Second：框架\n\n框架很重要，甚至可以说你用这框架，感觉不是在写java。java里spring框架是‘轻量级’的最流行的框架。也是必学的。  \n从这里开始，就需要接触maven了。java的构建方式有多种，最主要是maven（web）和gradle（android），这两个工具作用差不多，现在越来越多的人选择用gradle构建web应用。但maven仍是主流，教程多，学习的话推荐。  \n\n> 从本质上来说：构建工具做的事是，将你现在的项目中，按照一定的规范，将文件编译后放到指定目录下，将依赖中的jar包下载下来放到指定目录下，并打包。  \n\n它是用来替换原本的打包方式的，主要是解决各种jar包的问题，原本的打包需要自己找jar包下载，并放入指定目录。  \n就框架而言，ssm现在的主流，下面的教程讲解的很明白。若是遇到不懂，解决不懂的地方，再向下看。这个视频中的js写的贼溜，这块实在看不懂可以先跳过。\n\n#### 教程\n\n- [慕课网：Java高并发秒杀API之业务分析与DAO层](http://www.imooc.com/learn/587)\n- [慕课网：Java高并发秒杀API之业务分析与SERVICE层](http://www.imooc.com/learn/631)\n- [慕课网：Java高并发秒杀API之业务分析与WEB层](http://www.imooc.com/learn/630)\n- 提高：[慕课网：Java高并发秒杀API之高并发优化](http://www.imooc.com/learn/632)\n\n> 任务3：实践很重要，跟着这个视频打一遍，并自己搭建框架实现简单的用户管理系统，要求用最新的稳定依赖。下面是maven仓库搜索地址。\n\n- [国内maven仓库搜索](http://mvnrepository.com/)\n- [官方maven仓库搜索](http://search.maven.org/)\n- 还有视频中提到的[Mybatis官方文档](http://www.mybatis.org/mybatis-3/zh/index.html)\n- 作为提高，再推荐一份博客，他里面对java8 Lambda讲述的很到位[lucida的博客](http://zh.lucida.me/)\n\n### Third：Spring Boot\n\n先来一段百科\n> Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，Spring Boot致力于在蓬勃发展的快速应用开发领域(rapid application development)成为领导者。\n\n所以，它不是新东西，只是简化配置用的，本质上仍是spring那套。给你两份教程，学去吧。\n> 任务4：学的过程中将之前的工程改成spring boot，记住之前的是ssm框架有Mybatis。\n\n#### 资料\n\n- 一份讲的很全的博客<http://blog.didispace.com/categories/Spring-Boot/page/4/>\n- 一个慕客网上的视频：[2小时学会Spring Boot](http://www.imooc.com/learn/767) \n- 这个人的另一份视频：[Spring Boot进阶之Web进阶](http://www.imooc.com/learn/810)\n\n到这里，回忆一下之前的最基础的servlet和jsp写的web服务，是不是有很大的不同，那么问题就来了，spring是怎么实现的\n> 额外任务：参照spring mvc，写一个简单的Web应用框架，实现web请求到Controller的过程，简单点，假设参数都是string类型的。当然这个过程很困难，需要学习很多东西，如java的注解、spring mvc的原理（aop）或者说动态代理、java的反射等等。但这对于理解spring非常的有用。\n\n### Fourth：数据库\n\n之前的学习，已经接触数据库，写过sql了把，没什么好讲的，看书。不过作为开发增删改查会就行，查稍微麻烦点。\n\n### Fifth：思想\n\n呃。。先来段重构这书中的一句把\n> 软件工程领域的超级经典巨著，与另壹巨著《设计模式》并称\"软工双雄\"，全美销量超过100000册，亚马逊书店伍星书。\n\n这就是经典，还有代码大全，据说也是可以不断来回看\n\n### Sixth：架构\n\n其实到了这里，你不一定要学架构，可以继续学习java，java很难，尤其是底层，里面大量的涉及编译原理，jvm最好的虚拟机，没有之一。  \n\n也可以走产品，你已经有代码基础了，在看些产品书，我觉得会比直接往产品方向发展更好。因为你更懂你的战友，你在设计时，也会考虑他们的情况。  \n\n还可以dba，这玩意就要求对数据库操作很精通了。\n\n我未来可能往架构方向发展也可能产品，目前就想多学点技术  \n\n这里推荐个博客学习spring cloud\n> 其实就是之前那个spring boot的博主<http://blog.didispace.com/categories/Spring-Cloud/>  \n\n> 额外任务：按着教程写个一整套spring cloud玩玩，好像是这个博主出过一本书《spring cloud微服务实战》，挺不错的\n\n### 总结\n\n越往后，学习的路就越宽阔，学无止境。引用一句名言**吾生也有涯，而知也无涯 。以有涯随无涯，殆已！**。所以，当你完成所有任务，我便领完了路，然后各奔东西把。\n\n### 备注\n\n经常有人问培训怎么样，我想说有人教，比你自学肯定要快，补基础不错的，但是也很贵。但学程序后面都是靠自学，没有人教你，养成好习惯更重要，只靠培训是没用的。所以培训可去可不去。  \n> 在学习java过程中，其他工具也要学学，比如git，无论你是从事什么开发，都是必备的。\n","categories":["杂文"],"tags":["杂文","学习"]},{"title":"Git工作流","url":"/articles/almond/git-flow/","content":"\n选择Git工作流，和如何配合工作流工作，这是软件行业经常碰到的问题。不同的Leader会有不同方案，有好有坏。当然能应用进实际开发中的流程，只要实际操作人员足够的仔细便不会出现问题，例如最常用的[Vincent Driessen提出的Git工作流](http://nvie.com/posts/a-successful-git-branching-model/)。     \n\n接下来，将介绍这个Git工作流，以及它所衍生出来的其它不错的工作流（GitHub Flow与GitLab Flow）    \n\n![](https://nvie.com/img/git-model@2x.png)   \n\n<!-- more -->\n\n# Git Flow By Vincent Driessen\n\n如上图，它包含了全部的流程内容，一个由两个主分支develop和master以及三个支持分支hot-fix、feature、release组成的工作流。我们每次功能开发以develop分支为主，从它这里拉出feature分支，当完成时合并回develop，如下图     \n![](https://nvie.com/img/fb@2x.png)   \n\n当开发完成，将develop发布到一release分支上进行测试以及bug修复。测试通过后将release分支的代码合并到master，作为一版本发布    \n![](https://nvie.com/img/main-branches@2x.png)\n\n线上问题，是常见的情况，无论是谁都不可能保证自己的代码不出问题。这时需要从master的tags（一般每次版本发布都需打上tags）中拉出修复分支hot-fix，修复并测试该问题。当完成后，须将此次更新同时合并到master和develop    \n![](https://nvie.com/img/hotfix-branches@2x.png)\n\nVincent Driessen作为首个Git成功模型的提出者，值得敬佩。后来的许多分支管理流程或多或少都有参照他的设计。    \n\n# 简化：GitHub Flow\nGitHub Flow也是个‘非常常用’的分支管理流程，一般它只在开源项目中使用。它是个十分轻量的分支管理流程，去掉了诸如hot-fix、release、develop分支，仅仅保留了master与feature，当然这里的feature也可当作hot-fix分支     \n![](https://jiangtj.github.io/assets/img/others/github-flow.png)   \n\n如图，当我们需要进行开发或者修复bug时，我们首先从master拉出一个feature/hot-fix分支，当完成开发，接下来是测试与讨论，并持续改进，当完善后，将该部分代码合并入master。至此，一个功能或者一个Bug修复开发完成了。相对Git Flow，减少了许多分支，可以让开发者更专注于功能的开发，同时也减少了不同分支间切换出错的概率。当然，也导致了分支间的定义不够，如遇到需要版本的情况，该怎么定义版本分支，遇到企业内部的测试环境，又该怎么区分呢？     \n\n# 演进：GitLab Flow\nGitLab Flow是基于GitHub Flow提出的，它的目的是为了解决上述企业中可能遇到的问题，同时保持足够的简化。GitLab Flow在实施过程中，十分重视上游优先的原则。一般情况下，只允许将上游的分支的代码部署到下游。\n\n## Production branch\nGitLab Flow总共提出了三种场景下分别使用不同的分支模型，最简单的是产品分支模型。它与GitHub Flow唯一的不同，仅多了一个production分支，当我们觉得master上的代码足够成熟，将代码合并到production上。在这个模型中master属于production的上游分支，所有的更改只在master上修改。当完善后拉到production上。     \n![](https://docs.gitlab.com/ee/workflow/production_branch.png)\n\n## Environment branches\n之前，就提问过，遇到测试环境怎么办？这时候我们需要引入环境分支，例如pre-production分支进行测试。它的模型结构与Production branch基本一致，不详说     \n![](https://docs.gitlab.com/ee/workflow/environment_branches.png)\n\n## Release branches\nRelease branches是GitLab提出的第三种分支模型，它适用于您需要将产品发布到外部的情况。它与Environment branches模型不同，它使用版本的分支代替了production分支。当然，一个项目中可能存在多个版本分支，这取决于您维护的版本数。     \n![](https://docs.gitlab.com/ee/workflow/release_branches.png)    \n就我而言，比较喜欢Release branches，因为比较喜欢[语义化版本](https://semver.org/lang/zh-CN/)   \n\n## 技巧\n- Q:如果同时有多个更新在master上，其中一个较为紧急，怎么优先发布（或者存在一个Bug修复，如何合并到维护的release分支）？\n- A:可以使用git cherry-picked拉取某次提交到指定分支\n\n# 参考文献\n[Git Flow By Vincent Driessen](https://nvie.com/posts/a-successful-git-branching-model/)    \n[GitHub Flow](https://guides.github.com/introduction/flow/)    \n[GitLab Flow](https://docs.gitlab.com/ee/workflow/gitlab_flow.html)    \n\n","categories":["团队"],"tags":["Git"]},{"title":"Git教程","url":"/articles/almond/git-start/","content":"先推荐三篇教程，帮助大家快速熟悉，最好按顺序学习~  \n\n### 廖雪峰老师的git教程\n这篇教程，百度搜git教程第一篇就是，廖雪峰老师讲的很清楚，非常适合新人学习及了解概念   \n> <https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/>\n\n### idea里git实战\n这篇讲idea中git的可视化操作。大部分时间，我们使用git都是可视化的，概念清楚的情况下，放心用   \n> <http://blog.csdn.net/autfish/article/details/52513465>\n\n<!-- more -->\n\n### Pro Git 中文版\n这就比较高级了，是git官方推荐的教程\n> <https://git-scm.com/book/zh/v2>\n\n### 工作流\n> git标准工作流<http://mzeht.com/2017/05/28/Gitflow-%E5%B7%A5%E4%BD%9C%E6%B5%81/>  \ngithub工作流<https://guides.github.com/introduction/flow/>  \ngitlab工作流<https://about.gitlab.com/2014/09/29/gitlab-flow/>  \n\n在所有工作流里，github工作流定义的最简单适合简单团队协作，gitlab工作流对其进行了扩充，相比于github工作流更适合企业场景。而git标准工作流。对于分支的划分更清晰，但其太过复杂，需在分支之间需要频繁切换，易出错，而不被推荐。\n\n\n","categories":["工具"],"tags":["学习","Git"]},{"title":"GitLab Pages 搭建Hexo教程","url":"/articles/almond/gitlab-pages-for-hexo/","content":"\n大部分情况下，都是github pages与hexo组合搭建静态博客。但不可否认的是，这样存在一些问题。比如，每次文章写完都需要要编译，才能上传，如果我仅仅想写个博客，这样的操作显得繁琐。又比如，你拥有多台电脑的情况，你需要在每台电脑上都配置一样的环境。    \n\n所以通过持续集成CI/CD的方式，让编译自动化，是一种很不错的解决方案。这里将介绍gitlab-ci来简化环境的搭建与编译过程。当然静态资源将托管在gitlab-pages上。   \n\n> There is also a tutorial in English\n\n<!-- more -->\n\n## 中文教程\n\n### 环境搭建\n\n1. 点击打开[gitlab pages例子页面](https://gitlab.com/groups/pages)\n2. fork其中的hexo项目到自己的账户（如果没有需要创建一个新的gitlab账户）\n3. 删除fork关系（点击项目左侧的settings->General，然后展开Advanced settings，删除fork关系）\n4. 可选：修改项目信息，如Project name、Project description、Path等。*这里建议Path和Project name一同修改。*gitlab pages地址规则与github是一致的  \n5. 可选：**建议修改`.gitlab-ci.yml`中node版本为最新的稳定版**\n6. 修改任意一文件，如readme.md或者source/_posts下的文章\n\n当你完成这些步骤，你可以点击右侧的CI/CD，可以看到如下画面：  \n\n![](https://jiangtj.github.io/assets/img/others/ci-1.jpg)  \n\n当然你看到的可能是pending或running，这时请耐心等待。当显示为passed时，在浏览器中输入托管地址https://your-name.gitlab.io/projext-name，能访问，就意味着搭建成功咯    \n\n### 修改主题\n\n这个项目结构是标准的hexo的项目，除了多个一个`.gitlab-ci.yml`，如下图   \n\n![](https://jiangtj.github.io/assets/img/others/ci-2.jpg)  \n\n我们仅需关心script部分即可，而这部分其实是标准的hexo命令。    \n\n如果你想使用next主题（最受欢迎的hexo主题），<http://theme-next.iissnan.com>官网的网站上已有详细的教程    \n\n\n## English\n\n### Get Started\n\n1. Click [example projects for gitlab pages](https://gitlab.com/groups/pages)\n2. Fork the project of hexo to your account(If you do not have any gitlab account, you can create a new)\n3. Remove fork relationship(Choose settings->General from the list on the left.And expand Advanced settings to remove fork relationship)\n4. Optional: modify project info，such as Project name, Project description, Path etc. *Here's a suggestion about that path and Project name modify together.* your website will be available at https://username.gitlab.io/projectname, it is familiar with gitlab pages.\n5. Optional: **suggested modify the node's version from `.gitlab-ci.yml` to last LTE version**\n6. Modify any file, such as readme.md or the article under source/_posts\n7. Choose CI/CD, waiting job completion\n8. Click https://your-name.gitlab.io/projext-name\n\n### Advanced\n\n- you can modify script in `.gitlab-ci.yml`.\n- you can change the theme to next, which is most popular theme of hexo, by a official tutorial <http://theme-next.iissnan.com>\n\n## Updated\n\n### Command Lines\nUse command lines to init a blog with gilab page, written in 2018.9.19\n\n#### Init hexo project\n```bash\nhexo init your-blog-dir\ncd your-blog-dir\nhexo s\n```\nHexo is running at http://localhost:4000, you can test it.\n\n#### Git remote\nAssert your project remote url is https://gitlab.com/your-gitlab-name/project-name.\n```bash\ngit init\ngit remote add origin git@gitlab.com:<your-gitlab-name>/<project-name>.git\ngit add .\ngit commit -m \"Initial commit\"\ngit push -u origin master\n```\n\n#### Add CI config  \nPlease rename `<*-name>` to real name, such as `sed -ri 's/.*(url:.*)/url: https:\\/\\/www.dnocm.com/g' _config.yml`   \n```bash\nwget -O .gitlab-ci.yml https://gitlab.com/JiangTJ/hexo/raw/master/.gitlab-ci.yml?inline=false\nsed -ri 's/.*(url:.*)/url: https:\\/\\/<your-gitlab-name>.gitlab.io/g' _config.yml\n```\nIf project-name is not your-gitlab-name.gitlab.io, update `root` var.\n```bash\nsed -ri 's/.*(root:.*)/root: \\/<project-name>\\//g' _config.yml\n```\nPush to remote\n```bash\ngit add .\ngit commit -m \"CI\"\ngit push -u origin master\n```\nWait pipeline finish running, your hexo blog is running at https://your-gitlab-name.gitlab.io/project-name.\n\n","categories":["前端"],"tags":["Hexo","CI"]},{"title":"简单、高效的管理hexo站点主题","url":"/articles/almond/hexo-theme-manage/","content":"如果您和我一样，喜欢更新至最新的主题，那么您也应该遇到和我一样的烦恼。每次更新新的主题时，总是要重新配置，而且随着自定义的内容增多，更新就成了负担。   \n\n因此，引入了Fork与Submodules来实现以下目标\n1. 自动合并自定义内容与配置\n2. 校验更新操作是否正常工作\n\n> 如果您不了解如何使用hexo搭建博客，您可以参考这篇博客：<https://www.dnocm.com/articles/almond/gitlab-pages-for-hexo/>\n\n<!-- more -->\n\n# GitHub Fork\nFork，一般用在贡献开源项目时（这里由于需要对主题配置做修改）。  \n1. 找到您喜欢的主题的开源项目，并点击fork，派生该项目至您自己的远程仓库\n{% img /images/md/almond/github-fork.png github-fork %}\n2. 创建新的分支例如custom，并在新分支上调整您的配置\n\n完成上述步骤后，以后每次合并新的功能仅仅是将主题的改动合并到自己的远程仓库，然后合并到分支上即可。避免了每次做同样的修改操作\n\n# Git Submodules\n通过fork，我们得到了想要的主题，但如何使用呢？通常的做法是下载主题到hexo博客项目中，测试并部署。然后，Git合并并不能保证永远完美的工作，如果出现问题，就需要修改主题项目，重新下载放入hexo工程，在运行测试。这过程是复杂的    \n事实上，Git已经针对这种依赖另一个独立的Git仓库情况作了调整，来解决复杂项目管理问题，而这种方式是Submodules子模块    \n> Git 通过子模块来解决这个问题。 子模块允许你将一个 Git 仓库作为另一个 Git 仓库的子目录。 它能让你将另一个仓库克隆到自己的项目中，同时还保持提交的独立。  ---ProGit(中文版)    \n\n\n1. 添加您的子模块\n```bash\ngit submodule add <remote-url> <local-path>\n```\n2. 进去您的字模块，切换到自定义分支，其他操作，就像普通的Git项目一样  \n\n\n如果您使用vs code，那么在侧边栏Git里，可以很方便的可视化管理子模块\n{% img /images/md/almond/sub-vs.png 300 sub-vs %}\n\n这样之后，您的更新操作，也变得足够简单，基本自定义的配置错了，也可以直接对子模块做修改并提交\n\n# GitLab CI\n在gitlab ci中需要针对子模块做额外的配置，将`GIT_SUBMODULE_STRATEGY`变量改为`normal`或者`recursive`\n```yml\nvariables:\n  GIT_SUBMODULE_STRATEGY: recursive\n```\n\n# npm依赖更新\n除了主题外还有hexo相关脚本需要更新。事实上，我们很难知道哪些脚本发布了新版本，这和npm更新机制有很大关系，如果在版本号前添加了`^`那么npm会下载兼容的最新版本包（除非存在`package.lock`或者`yarn.loc`），比如`^1.0.0`，如果存在`1.0.1`版本，那么你下载下来的是后者。。。    \n\n关于依赖的管理，通过GitHub市场中的[依赖管理工具](https://github.com/marketplace/category/dependency-management)会是个不错的办法，比如我所使用的[dependabot](https://github.com/marketplace/dependabot)，它会帮助我检测最新的依赖，并更新它（提交PR），我做的事就只剩Merge了。    \n\n这里就存在另一个问题，怎么测试PR是否正常运行。一个方式是本地部署PR分支测试，但大部分情况下都不会出问题，这就比较耗时了。这里我使用[Netlify](https://www.netlify.com/)PR预览功能，协助我测试（我最近已经将托管服务迁移到它上了，如果使用GitLab做托管，那么你可能需要做双向镜像，以便GitLab与GitHub之间的代码库保持一致）。   \n\n# 参考\n1. [GitHub - 对项目做出贡献](https://git-scm.com/book/zh/v2/GitHub-%E5%AF%B9%E9%A1%B9%E7%9B%AE%E5%81%9A%E5%87%BA%E8%B4%A1%E7%8C%AE)\n2. [Git 工具 - 子模块](https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E5%AD%90%E6%A8%A1%E5%9D%97)\n3. [Using Git submodules with GitLab CI](https://docs.gitlab.com/ee/ci/git_submodules.html#using-git-submodules-in-your-ci-jobs)\n\n","categories":["前端"],"tags":["Hexo","CI"]},{"title":"Java动态代理小例子.","url":"/articles/almond/java-proxy-example/","content":"### 例子\n1，先创建teacher接口   \n```java\npublic interface Teacher {\n\tvoid manageWork(String s);\n}\n```\n2,创建teacher实现类   \n```java\npublic class TeacherA implements Teacher {\n\n\t@Override\n\tpublic void manageWork(String s) {\n\t\t// TODO Auto-generated method stub\n\t\tSystem.out.println(this.getClass().getSimpleName()+\"开始布置作业：\"+s);\n\t}\n\n}\n```\n\n<!-- more -->\n\n3,创建teacher代理类,java 的动态代理就是通过Proxy.newProxyInstance这个静态方法生成   \n```java\npublic class TeacherProxy implements InvocationHandler {\n\t\n\tprivate Object teacher;\n\t\n\tpublic void setTeacher(Class<?> cls){\n\t\ttry {\n\t\t\tteacher =cls.newInstance();\n\t\t} catch (InstantiationException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t} catch (IllegalAccessException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\tpublic static Teacher getTeacher(Class<?> cls){\n\t\tTeacherProxy proxy=new TeacherProxy();\n\t\tproxy.setTeacher(cls);\n\t\treturn (Teacher) Proxy.newProxyInstance(cls.getClassLoader(), cls.getInterfaces(), proxy);\n\t}\n\n\t@Override\n\tpublic Object invoke(Object proxy, Method method, Object[] args)\n\t\t\tthrows Throwable {\n\t\t// TODO Auto-generated method stub\n\t\t//System.out.println(\"代理类名字：\"+proxy.getClass().getName());\n\t\tSystem.out.println(teacher.getClass().getSimpleName()+\"的课代表通知老师\");\n\t\tObject o=method.invoke(teacher, args);\n\t\tSystem.out.println(teacher.getClass().getSimpleName()+\"的任务完成\");\n\t\treturn o;\n\t}\n\n}\n```\n接下来我们在main中写一下代码运行,其中student只是普通的类，不在这里写出来了   \n```java\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tTeacher teacherProxyA=TeacherProxy.getTeacher(TeacherA.class);\n\t\tTeacher teacherProxyB=TeacherProxy.getTeacher(TeacherB.class);\n\t\tteacherProxyA.manageWork(\"语文作业\");\n\t\tteacherProxyB.manageWork(\"数学作业\");\n\t\tnew StudentA().doWork();\n\t\tnew StudentB().doWork();\n\t}\n```\n运行后能看到下面的结果\n```java\nTeacherA的课代表通知老师\nTeacherA开始布置作业：语文作业\nTeacherA的任务完成\nTeacherB的课代表通知老师\nTeacherB开始布置作业：数学作业\nTeacherB的任务完成\nStudentA开始做作业\nStudentB开始做作业\n```\n### 说明\n如上面结果所示，teacherProxyA是由Proxy产生的动态代理类，它拥有接口所对应的方法，调用这个方法其实就是调用invoke方法。\n在invoke中，调用的是他所代理对象的方法。   \n所以说，动态代理很强大，他可以在代理过程中执行拦截或者记录日志，spring的aop核心便是这个。\n除此之外，不得不提一下retrofit框架，这是面向android的RESTful网络请求框架，他的核心也是动态代理，不过，对于所有的请求都提供一样的实现，而所有的参数都通过flied值与注解来得到，然后通过okhttp提交并返回call对象。这种实现很精彩。\n","categories":["后端"],"tags":["设计模式"]},{"title":"利用Jmeter进行压力测试","url":"/articles/almond/jmeter-info/","content":"\n压力测试（Stress Test），也称为强度测试、负载测试。压力测试是模拟实际应用的软硬件环境及用户使用过程的系统负荷，长时间或超大负荷地运行测试软件，来测试被测系统的性能、可靠性、稳定性等。目前互联网的环境下，压力测试是必不可少的，其中Apache JMeter是目前主流的开源的压力测试工具。\n\nApache JMeter是Apache组织开发的基于Java的压力测试工具。用于对软件做压力测试，它最初被设计用于Web应用测试，但后来扩展到其他测试领域。 它可以用于测试静态和动态资源，例如静态文件、Java 小服务程序、CGI 脚本、Java 对象、数据库、FTP 服务器， 等等。JMeter 可以用于对服务器、网络或对象模拟巨大的负载，来自不同压力类别下测试它们的强度和分析整体性能。另外，JMeter能够对应用程序做功能/回归测试，通过创建带有断言的脚本来验证你的程序返回了你期望的结果。为了最大限度的灵活性，JMeter允许使用正则表达式创建断言。\n\n<!-- more -->\n\n# 开始\n\n## 下载\nJmeter可以在官网<https://jmeter.apache.org/download_jmeter.cgi>直接下载编译过的文件    \n```bash\nwget http://mirrors.shu.edu.cn/apache/jmeter/binaries/apache-jmeter-4.0.zip -O jmeter.zip\n```\n## 配置\n下载好后解压，并修改配置文件，使其启动时默认使用中文语言     \n${jmeter-dir}/bin/jmeter.properties 37行左右      \n```properties\n#Preferred GUI language. Comment out to use the JVM default locale's language.\nlanguage=zh_CN\n```\n\n## 运行\nWindows下双击jmeter.bat启动，Linux或者其他用相应的脚本启动\n\n# 测试计划\n\njmeter可以自定义测试计划，比较常用的有线程组（用户组）、线程（用户）、控制器、定时器和监听器等\n\n## 线程组\n一般都需要定义一组用户，用于模拟多用户并发请求    \n![](https://jiangtj.github.io/assets/img/others/jmeter/u1.png)    \n如图，定义了500用户，依次在30s内递增    \n![](https://jiangtj.github.io/assets/img/others/jmeter/u2.png)   \n\n## 线程\n线程组内定义工作内容，或者一些通用的环境等    \n例如添加公共的默认请求信息    \n![](https://jiangtj.github.io/assets/img/others/jmeter/h1.png)   \n添加一个循环逻辑    \n![](https://jiangtj.github.io/assets/img/others/jmeter/l.png)   \n添加一个Http请求    \n![](https://jiangtj.github.io/assets/img/others/jmeter/q1.png)   \n\n## 监听器\n监听器用于获取执行情况，生成或者计算相应的数据    \n例如添加响应时间的报表     \n![](https://jiangtj.github.io/assets/img/others/jmeter/r1.png)  \n\n\n# 测试结果\n编写了一个jmeter脚本对我服务器上的两个web服务进行了压力测试，一个为webmvc，一个为webflux。由于机器的性能实在有限，出现了很多连接超时，但也有惊喜    \n\n我模拟在30s内启动500个用户请求服务，每个用户请求30次中间间隔随机1-2s\n\n## WebMVC\n\nwebmvc 在并发请求上去后，貌似服务崩了，以至于后面的请求都未完成，我在半个小时后再次访问web服务，仍然无响应。而从结果来看，数据库服务也被挤下去。   \n\n![](https://jiangtj.github.io/assets/img/others/jmeter/mvc1.png)   \n![](https://jiangtj.github.io/assets/img/others/jmeter/mvc2.png)   \n![](https://jiangtj.github.io/assets/img/others/jmeter/mvc3.png)   \n\n## WebFlux\n\nwebflux 在并发方面带给我一些惊喜，500的并发对于1核1G1M的机器来说，实在的太勉强了（还跑着数据库），测试过程中也出现了较多的连接超时，但是，服务一直保持可用。也查看过CPU，在连接超时的时间，CPU已经被占满。应该是无法处理导致直接不接收相应的请求。这也导致测试完成后，服务一直保持正常，访问返回了正确结果。\n\n![](https://jiangtj.github.io/assets/img/others/jmeter/flux1.png)   \n![](https://jiangtj.github.io/assets/img/others/jmeter/flux2.png)   \n\n# 插件\n\n## MQTT\n\njmeter还有许多插件，扩展它所支持的环境，例如MQTT插件<https://github.com/emqtt/mqtt-jmeter>，可用来测试MQTT服务，MQTT服务作为物联网的重要组测部分，能进行压力测试可以做到更好的评估。\n\n\n","categories":["工具"],"tags":["Jmeter","压力测试"]},{"title":"JWeb 简单的方式部署静态资源","url":"/articles/almond/jweb-for-static-resource/","content":"\nJWeb 是一个基于Spring Boot的简单服务。提供Shell脚本，以简单的方式部署以及运行静态资源\n\n# 缘\n某天晚上睡不着，充电。突然脑抽了一下，node能做到命令行快速的运行静态资源，例如[docsify-cli](https://docsify.js.org/#/zh-cn/quickstart)，能通过`docsify serve your-static-dir`直接部署静态资源，于是我想的是，相似的功能，java也能实现的把    \n\n直接部署静态资源，在开发过程中是很有必要的，例如测试跨域问题，您必须另外起个服务。如果是下载web服务器，并将资源拖拽过去的方式，就有点麻烦咯\n\n<!-- more -->\n\n# Java服务\njava随着spring boot的出现，开发变得越来越简单，而spring boot正好提供了命令行的方式运行web服务。通过翻阅相关的文档，也发现spring boot中配置文件可以设置本地路径，例如`file:/mnt/c/111/`设置为c盘111文件夹（win10 bash）。所以java服务是基于spring boot的简单的服务      \n\n## 创建项目\n您可以在[Spring官网](https://start.spring.io/)上下载基本的骨架，当然也可以通过idea等工具下载。一般来说添加以下依赖就够了，但如果您还有其他需求，例如和spring cloud配合，请引入相关的依赖     \n```maven\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n```\n\n## 添加路由\n由于spring boot默认需要`index.html`才能访问静态资源首页，这是我们不希望的，添加一个路径，将`/`跳转至index.html。如下修改`JwebApplication.class`     \n```java\n@Controller\n@SpringBootApplication\npublic class JwebApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(JwebApplication.class, args);\n    }\n\n    @RequestMapping(\"/\")\n    public String index(){\n        return \"index.html\";\n    }\n\n}\n```\n\n至此，已经完成了java服务的创建，您可以使用命令行`java -jar xxx.jar --spring.resources.static-locations=file:your-static-dir`来部署您的静态资源了，但，这命令行是不是太长了...\n\n# Shell脚本\nshell脚本的目的是为了简化命令行而编写的，提供类似docsify-cli一样的命令     \n\n目前的脚本如下：\n```shell\n#!/bin/sh\n\n# export PATH=$PATH:your_dir\n# Example: export PATH=$PATH:/mnt/c/Users/MrTT/IdeaProjects/jweb/scripts\n\n# 需要openJDK\nif ! hash java 2>/dev/null; then\n  echo \"I require java but it's not installed. Please install openJDK.\";\n  exit 1;\nfi\n\n# 获取脚本路径\nscript_path=`dirname $0`\n\n# 修复环境\nif [ ! -e ${script_path}\"/jweb.jar\" ]; then\n  echo \"Downloading jar ...\";\n  wget -O jweb.jar \"https://gitlab.com/jiangtj/jweb/-/jobs/artifacts/release/raw/target/jweb.jar?job=build-release\"\n  mv jweb.jar ${script_path}\nfi\n\n# java_command\njava_command=\"java -jar \"${script_path}\"/jweb.jar\"\n\nwhile getopts \"c:p:w:\" opt; do\n  case ${opt} in\n    c)\n      config_dir=`readlink -f $OPTARG`\n      java_command=${java_command}\" --spring.config.additional-location=file:\"${config_dir}\n      ;;\n    p)\n      java_command=${java_command}\" --server.port=\"$OPTARG\n      ;;\n    w)\n      static_dir=`readlink -f $OPTARG`\n      java_command=${java_command}\" --spring.resources.static-locations=file:\"${static_dir}\n      ;;\n    \\?)\n      echo \"Please read docs !\"\n      ;;\n  esac\ndone\n\n# 运行\necho ${java_command}\n${java_command}\n```\n\n实现几个功能点：    \n1. 判断是否存在java环境\n2. 自动下载基本的java服务（如果不存在的话）\n3. 获取参数，拼接java命令，并执行\n\n如果，将该shell脚本加载在path路径中，那么可以在任意位置通过命令行`jweb.sh -w your-static-dir`来部署静态资源    \n\n# 项目\n\n目前项目处在初步的设计阶段，后续会添加更多的参数，以及对java服务更多定制，以满足更多的情况    \n\n[JWeb·GitLab](https://gitlab.com/JiangTJ/jweb)     \n[JWeb·GitHub镜像](https://github.com/JiangTJ/jweb)     \n[JWeb·Docs](https://jiangtj.gitlab.io/jweb)    \n\n\n","categories":["后端"],"tags":["Java","Web","Shell"]},{"title":"Certbot 为你的HTTP服务加一层SSL协议","url":"/articles/almond/lets-encrypt-certbot/","content":"\n谷歌Chrome安全产品经理艾米丽·谢克特（Emily Schechter）发表博文，证实当该公司在7月发布Chrome 68浏览器时，该浏览器将把所有未采用HTTPS（安全套接字层超文本传输协议）加密的网站都标记为“不安全”网站。    \n\nChrome作为浏览器界的巨头，做出如此的决定，将极大的推进HTTPS的进程，我们自然也应该跟进，一同建立更安全的网络环境。但一般证书都是较为昂贵的，因此互联网安全研究小组Internet Security Research Group(ISRG)以及Linux基金会等，提供了公益的项目，用于加速HTTPS的发展    \n\n<!-- more -->\n\n# 概念\n\n## HTTPS\nHTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 它是一个URI scheme（抽象标识符体系），句法类同http:体系。用于安全的HTTP数据传输。https:URL表明它使用了HTTP，但HTTPS存在不同于HTTP的默认端口及一个加密/身份验证层（在HTTP与TCP之间）。\n\n## Let’s Encrypt\nLet’s Encrypt是一个公益的，免费的，自动化的和开源的证书颁发机构(CA)。是由互联网安全研究小组(ISRG)提供的服务。\n\n## Certbot\nCertbot是一个简单易用的工具，它能为您的Web服务器获取和部署SSL/TLS证书。Certbot是EFF和其他公司为Let’s Encrypt提供的客户端。在之前，它被称为“官方的Let’s Encrypt客户端”或“Let’s Encrypt 的Python客户端”。Certbot同样支持其他的支持ACME协议的证书颁发机构。\n\n# 配置\n\n## 安装\n可以在官网<https://certbot.eff.org/>上获取其安装文档，由于我服务端是Ubuntu16.04，同时以安装Nginx，所以选择了与此相应的安装文档。\n```bash\n$ sudo apt-get update\n$ sudo apt-get install software-properties-common\n$ sudo add-apt-repository ppa:certbot/certbot\n$ sudo apt-get update\n$ sudo apt-get install python-certbot-nginx \n```\nUbuntu上一般通过apt-get包管理工具安装。\n\n## 开始\nCertbot 有支持多环境的Nginx插件\n```bash\n$ sudo certbot --nginx\n```\n接下来是一些列问答式的配置，安装要求，或者自己的需求填写好    \n之后，我们可以发现网站已经可以通过https访问了\n\n## Nginx代理\nCertbot 的Nginx配置在`/etc/nginx/sites-enabled/default`中，我们可以找到配置的网站\n```\nserver {\n    root /var/www/html;\n    index index.html index.htm index.nginx-debian.html;\n    server_name x.j-time.cn; # managed by Certbot\n\n                \n    location / {\n        # First attempt to serve request as file, then\n        # as directory, then fall back to displaying a 404.\n        try_files $uri $uri/ =404;\n    }\n\n    location /bill-server/ {\n         proxy_pass  http://localhost:8689/;\n    }\n\n    ## ...\n\n}\n```\n在这之中，我可以实现我们自己的代理，例如简单的转发到本地一个服务上\n```bash\n$ sudo service nginx restart\n```\n重新Nginx服务\n\n## 重新获取证书\n\n证书都是有有效期的，我们需要在有效期内重新获取更新证书，Let’s Encrypt的证书有效期为3个月。所以我们需要通过Certbot工具自动的更新证书\n```bash\n$ sudo certbot renew --dry-run\n```\n\n# 校验\n\n打开配置好的地址<https://x.j-time.cn/>，能正常的通过https访问了，同时谷歌、火狐等浏览器，也将此站点标记为了安全站点\n\n# 更多细节\n\n[Certbot Documentation](https://certbot.eff.org/docs/index.html)\n\n","categories":["运维"]},{"title":"微服务设计 - 版本控制","url":"/articles/almond/microservices-version-control/","content":"\n# 背景\n在微服务中，单个服务的升级改善是不可避免的，虽然改动最终引起Rest接口变动并不多，但仍然会出现。在《微服务设计》中，提供了两种处理方案：\n1. 不同的接口共存\n2. 同时运行多个版本服务\n\n这本书的作者Sam Newman，他认为这两种方案都是可行的，但更倾向于不同接口共存。也提出了三点主要原因\n- 当出现问题时，不同的接口共存可以更快的修改新老版本的代码并一同部署，而另一种就比较麻烦了\n- 方案二维护困难，同时存在多个版本服务，对运维来说具有较大的挑战性\n- 持久化层可能是一样的，方案二却有不同版本的实现，会导致潜在的复杂性\n\n但我更倾向于方案二，该方案的实际使用者主要是Netflix（Spring Cloud便是基于他开源的微服务框架研发的），在现阶段（2018年）相对于作者的年代（2015年），技术上已经有了较大的变化。微服务的设计已经在很多公司大规模的推行及使用，变得更加成熟。作者所提出的前两点问题已经有了比较好的方案减少影响    \n\n<!-- more -->\n\n# 问题修复\n首先，同时需要修改两服务的情况应当只有问题修复，新功能迭代，应发生在新服务上，老版本不应该支持（从某种程度上来说，可以启到督促用户升级）    \n\n那么问题如何修复呢？同样也存在多种情况，我们拿书中的例子（用户服务）接着讲    \n\n## 改进\n用户服务负责的是用户相关的功能，其中一种情况是做了改进，增强部分功能。例如原本用户创建接口只是简单的用户名与单邮箱绑定（v1），改版后，需要实现的是多邮箱的绑定（v2），事情一个用户多个邮箱是比较常见的    \n\n那么在这种情况下，底层的持久层已经改变了，原本应该用户表中存在邮箱字段，而新方案则为用户表与用户邮箱绑定表。我们需要在老节点拉出分支`release-v1`用于维护与兼容老版本，同时在`master`上迭代新的改进，稳定后拉出`release-v2`，不同的版本的服务与具体的分支对应，同样的可以创建`release-v3`等，但不建议同时维护多个版本，即便在不同的接口共存方案里也是一样的    \n\n有了这些分支后，我们所做的修复都只需要在`master`上修复，通过`git cherry-pick`拉取单次提交至不同版本上，这是`GitLab Flow`方案，他所提倡的上游原则，在很大程度上避免了修改问题所造成的影响\n\n## 重构\n这里说的重构是指代码的重写，可能用了不同的技术架构或者语音，那么在这种情况下，不同的接口共存方案将无法处理，因为您的服务发生了彻底的变化\n\n## 部署\n问题修复后的部署也是难点，如果保证准确部署呢，CI/CD在很大程度上解决了这个问题，许多CI工具都提供指定分支的脚本配置，没错，我们可以提供一样的CI配置文件，保证编译测试一致的前提下，在不同的分支中运行不同的部署脚本\n\n# 运行\n运行时，如何将用户指向不同服务，同样的可以通过uri定位如`/v1/*`，微服务中网关与注册中心特别重要，我们可以在服务名中硬编码版本，比如`user-v1`这是第一个版本，在Spring Cloud中配置可以是：\n```yml\nspring:\n  cloud:\n    gateway:\n      routes:\n        - id: v1\n          uri: lb://user-v1\n          predicates:\n            - Path=/v1/user/**\n          filters:\n            # Strip first path，such v1\n            - StripPrefix=1\n```\n这并不困难\n\n# 持久化\n这个问题是唯一无法避免的，当然不同的接口共存也同样会遇到这个问题。作者认为旧接口转换处理后重新指向新接口服务，来避免持久化问题。这样的方案能解决的，在多服务中也很好解决，往往数据库中字段添加默认值就够了。其他无法兼容的，那么旧接口转换后访问新街口能不出错？唯一的措施是尽快推进升级    \n\n# 其他\n不同的接口共存就不存在问题么，显然不是的。每次新版本的发布，需要对所有接口重写，即使接口定义没有变化。这在很大程度上导致代码的冗余，多出许多`xxxV1Controller`、`xxxV2Controller`之类的。\n\n另外，多版本共存一般而言会在一定时间下掉老服务（惰性->升级），但接口共存方案，可能会导致老的controller长期存在（惰性->保留），可能导致微服务往“坏”的方向发展。    \n\n惰性的解释：   \n在多版本中，运行多版本是麻烦事，所以，会逼迫升级   \n在多接口中，删除旧接口是麻烦事，所以，会趋于保留    \n\n人性本就懒惰，用来维护微服务更健康，岂不更好？\n\n# 参考\n- 《微服务设计》 Sam Newman 著 崔力强 张俊 译\n- [GitLab Flow](https://docs.gitlab.com/ee/university/training/gitlab_flow.html)\n","categories":["架构"],"tags":["微服务","Version Control"]},{"title":"MySQL5.7 IN与EXISTS","url":"/articles/almond/mysql-in-and-exists/","content":"\n> 文章中的表参考这里的创建<http://blog.csdn.net/stevendbaguo/article/details/73467649>\n\n### 数据表的创建\n\n* 制造数据\n```sql\nDROP TABLE IF EXISTS test; \nCREATE TABLE test( \n    ID INT(10) NOT NULL, \n    `Name` VARCHAR(20) DEFAULT '' NOT NULL, \n    PRIMARY KEY( ID ) \n)ENGINE=INNODB DEFAULT CHARSET utf8; \n```\n\n<!-- more -->\n\n* 创建生成测试数据的存储过程\n```sql\nDROP PROCEDURE IF EXISTS pre_test; \nDELIMITER //\nCREATE PROCEDURE pre_test() \nBEGIN \nDECLARE i INT DEFAULT 0; \nSET autocommit = 0; \nWHILE i<4000000 DO \nINSERT INTO test ( ID,`Name` ) VALUES( i, CONCAT( 'Carl', i ) ); \nSET i = i+1; \nIF i%10000 = 0 THEN \nCOMMIT; \nEND IF; \nEND WHILE; \nEND; //\nDELIMITER ;\n```\n运行存储过程\n* 创建子表\n```sql\nCREATE TABLE test_bak AS SELECT * FROM test LIMIT 1000;\nCREATE INDEX ind_t_id ON test(id);\nSHOW CREATE TABLE test;\nCREATE INDEX ind_t1_id ON test_bak(id);\n```\n\n### SQL测试\n   \n[SQL]    \nSELECT * FROM test a LEFT JOIN test_bak b ON a.id = b.id LIMIT 5000;    \n时间: 0.017s   \n  \n[SQL]   \nSELECT * FROM test a LIMIT 5000;   \n时间: 0.003s\n  \n[SQL]   \nSELECT * FROM test a WHERE a.ID in (SELECT ID FROM test_bak) LIMIT 5000;   \n时间: 0.004s   \n   \n[SQL]   \nSELECT * FROM test a WHERE EXISTS(SELECT 1 FROM test_bak b WHERE b.id = a.id) LIMIT 5000;    \n时间: 19.255s    \n    \n[SQL]    \nSELECT * FROM test_bak b WHERE b.ID in (SELECT ID FROM test) LIMIT 5000;     \n时间: 0.003s     \n    \n[SQL]    \nSELECT * FROM test_bak b WHERE EXISTS(SELECT 1 FROM test a WHERE b.id = a.id) LIMIT 5000;       \n时间: 0.006s    \n     \n[SQL]   \nSELECT * FROM test a WHERE a.`Name` in (SELECT `Name` FROM test_bak) LIMIT 1000;   \n时间: 0.101s   \n    \n[SQL]    \nSELECT * FROM test a WHERE EXISTS(SELECT 1 FROM test_bak b WHERE b.`Name` = a.`Name`) LIMIT 1000;   \n时间: 0.229s  \n\n注意：最后两条LIMIT别大于1000   \n\n### 原因\n\nMySQL自某个版本起（不记得了，逃~~），对于in中无与外表的数据做条件判断的查询，会优化为join方式执行。这比EXISTS高效的多    \n当然，in中内表不能与外表的数据做条件判断，否则请用join    \n ","categories":["后端"],"tags":["MySQL"]},{"title":"重新开始","url":"/articles/almond/renew/","content":"再过去的一段时间，感觉一直在原地踏步，虽然偶尔也有写几篇文章，但几乎都是在翻旧账    \n\n但总不能一直这样下去吧   \n\n所以准备在接下来有所改变\n\n新的域名（dnocm.com）,我会再近期将其他站点迁移到这上面   \n\n新的博客Lofter，准备写一些其他兴趣相关的（Code外，动漫、游戏？），虽然目前还是零记录   \n\n新的CI/CD，使用Netlify做静态托管，能自动https，GitLab 3年前就开始讨论与准备集成Let's Encrypt，但。。。    \n\n新的邮箱（有新域名自然换啊），<i@dnocm.com>欢迎联系   \n\n新的封页（<https://www.dnocm.com/cover>）,可能调整到根路径下，打算用Web Components重写，打算中。。。\n\n"},{"title":"Restdoc与Docsify,更简单的生成Api文档","url":"/articles/almond/restdoc-and-docsify/","content":"大半年前就写过一篇文章[《测试驱动开发(TDD)的实践》](https://www.dnocm.com/articles/almond/test-driven development/)，关于测试的。时至今日，我仍然坚信测试是软件开发一重要环节，它在绝大多数情况下，保障了系统的质量与稳定性。   \n\n但当时所搭的框架存在一些不足，当然主要是由于Asciidoctor。这是一个足够完善的标记语言，但也足够复杂。然而大多数情况下我们并不需要这些语法，Markdown正好足够。    \n\n事实上，当时我最先尝试的也是Markdown，使用Spring Restdoc中推荐的Slate方案，来解决Markdown无法包含问题。缺点是它运行使用的Ruby，与我所学的完全不同（Java、Js）。但最近看到了另一个文档工具Docsify，它也添加了包含功能，它足够简单，以至于看几遍例子就完全学会，虽然也有缺点，SEO方面，但内部接口文档，你会在乎这个么？下面是一个例子整合Restdoc与Docsify\n\n<!-- more -->\n\n# 创建服务\n首先，创建一个简单的Spring Boot服务，以及暴露一个用户接口\n```java\n@RestController\n@SpringBootApplication\npublic class RestdocDocsifyApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(RestdocDocsifyApplication.class, args);\n    }\n\n    @GetMapping(\"/\")\n    public String index(){\n        return \"Server is running!\";\n    }\n\n    @GetMapping(\"/user\")\n    public User user(){\n        return new User(\"Jone\",1,20);\n    }\n\n}\n```\n# 创建测试用例\n这个测试用例是集成测试\n```java\n@RunWith(SpringRunner.class)\n@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\n@AutoConfigureWebTestClient\npublic class RestdocDocsifyApplicationTests {\n\n    @Resource\n    private WebTestClient webTestClient;\n\n    @Test\n    public void contextLoads() {\n        this.webTestClient.get().uri(\"/\").accept(MediaType.APPLICATION_JSON)\n                .exchange()\n                .expectStatus().isOk()\n                .expectBody(String.class)\n                .isEqualTo(\"Server is running!\");\n    }\n\n    @Test\n    public void getUser() {\n        this.webTestClient.get().uri(\"/user\").accept(MediaType.APPLICATION_JSON)\n                .exchange()\n                .expectStatus().isOk()\n                .expectBody();\n    }\n}\n```\n# 整合Restdoc\n1. 添加自动配置注解`@AutoConfigureRestDocs`\n2. 为每个WebTestClient添加文档参数说明`.consumeWith(document())`\n整合之后的结果如下\n\n```java\n@RunWith(SpringRunner.class)\n@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\n@AutoConfigureWebTestClient\n@AutoConfigureRestDocs(outputDir = \"docs/snippets\")\n@Import(CustomRestDocsConfiguration.class)\npublic class RestdocDocsifyApplicationTests {\n\n    @Resource\n    private WebTestClient webTestClient;\n\n    @Test\n    public void getUser() {\n        this.webTestClient.get().uri(\"/user\").accept(MediaType.APPLICATION_JSON)\n                .exchange()\n                .expectStatus().isOk()\n                .expectBody()\n                .consumeWith(document(\"user\",responseFields(\n                        fieldWithPath(\"name\").description(\"The user's name\"),\n                        fieldWithPath(\"sex\").description(\"The user's sex\"),\n                        fieldWithPath(\"age\").description(\"The user's age\"))\n                ));\n    }\n}\n```\n其中`outputDir`定义输出目录，指向Docsify文档目录，方便部署（注意添加Git忽略配置），`@Import(CustomRestDocsConfiguration.class)`导入自定义配置，目的是修改模板为Markdown，代码如下\n```java\n@TestConfiguration\npublic class CustomRestDocsConfiguration implements RestDocsWebTestClientConfigurationCustomizer {\n    @Override\n    public void customize(WebTestClientRestDocumentationConfigurer configurer) {\n        configurer.snippets().withTemplateFormat(TemplateFormats.markdown());\n    }\n}\n```\n# 创建Docsify文件\nDocsify的一些入门，可以查看[官网](https://docsify.js.org/#/zh-cn/quickstart)，这里已经当你会基本的操作了。首先创建一个`index.html`，您可以使用命令行生成，或者直接Copy下面的代码\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <title>Spring-Cloud Docs</title>\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" />\n  <meta name=\"description\" content=\"Description\">\n  <meta name=\"viewport\" content=\"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\">\n  <link rel=\"stylesheet\" href=\"//unpkg.com/docsify/lib/themes/vue.css\">\n</head>\n\n<body>\n<div id=\"app\"></div>\n<script>\n    window.$docsify = {\n        name: 'Restdoc-Docsify Examples',\n        repo: 'JiangTJ/restdoc-docsify',\n        loadSidebar: true,\n        autoHeader: true,\n        auto2top: true,\n        subMaxLevel: 2\n    }\n</script>\n<script src=\"//unpkg.com/docsify/lib/docsify.min.js\"></script>\n<script src=\"//unpkg.com/docsify/lib/plugins/search.js\"></script>\n<script src=\"//unpkg.com/prismjs/components/prism-java.min.js\"></script>\n<script src=\"//unpkg.com/prismjs/components/prism-bash.min.js\"></script>\n<script src=\"//unpkg.com/prismjs/components/prism-http.min.js\"></script>\n</body>\n\n</html>\n```\n\n你可以调整`window.$docsify`参数，这里将`loadSidebar`置为了`true`，为的是每个需求服务分在不同的文件里    \n同样的需要为其添加主页`README.md`和侧边栏`_sidebar.md`  \n\n- README.md\n  ```md\n  # Welcome Page\n  \n  ## How to use\n  mvn test\n  docsify serve docs\n  browse `localhost:3000`   \n  click sidebar `User Api`\n  ```\n\n- _sidebar.md\n  ```md\n  * [User Api](user.md)\n  ```\n\n编写一个用户服务，使用文档嵌入，将代码片段包括进去\n\n- user.md\n  ```md\n  ### curl-request\n  [curl-request](snippets/user/curl-request.md ':include')\n  \n  ### http-request\n  [http-request](snippets/user/http-request.md ':include')\n  \n  ### http-response\n  [http-response](snippets/user/http-response.md ':include')\n\n  ### httpie-request\n  [httpie-request](snippets/user/httpie-request.md ':include')\n  \n  ### request-body\n  [request-body](snippets/user/request-body.md ':include')\n  \n  ### response-body\n  [response-body](snippets/user/response-body.md ':include')\n  \n  ### response-fields\n  [response-fields](snippets/user/response-fields.md ':include')\n  ```\n\n# 运行\n1. 运行maven测试`mvn test`生成代码片段   \n2. 执行命令行`docsify serve docs`，浏览器打开`localhost:3000`就可以预览刚才编写的文档了(事实上该命令只是将docs下的文件直接放置在web服务器中，如果使用CI可以很方便的部署该文档服务)\n\n# 不足\nDocsify足够简单，Restdoc在测试阶段生成文档的方式既校验了代码，又校验文档，这种方式还有什么不足呢？在以下两方面\n- 无法很好的生成pdf文件\n- Mock接口\n\n如果你所在的公司非常“传统”，对于doc或者pdf之类的文件很执着，那Asciidoctor更适合您，多学一门语言而已，但Asciidoctor生成的pdf是真的漂亮。另外一个Mock接口，是为了在完成前，前端可以直接调用Mock接口进行调试，这是一个很好的实践，具体如何做到，你可以尝试一下，方式应该是多种多样的\n\n# 参考\n- [该文档的例子工程](https://github.com/JiangTJ/restdoc-docsify)\n- [Spring Boot文档](https://docs.spring.io/spring-boot/docs/2.1.1.RELEASE/reference/htmlsingle/#boot-features-testing)\n- [Spring Restdoc文档](https://docs.spring.io/spring-restdocs/docs/2.0.2.RELEASE/reference/html5/)\n- [Docsify文档](https://docsify.js.org/#/)\n\n","categories":["后端"],"tags":["Test"]},{"title":"Shiro拦截器与过滤器","url":"/articles/almond/shiro-filter-and-interceptor/","content":"\n> 这篇是对 [开涛的《跟我学shiro》](http://www.iteye.com/blogs/subjects/shiro) 的部分章节补充，更详细的探讨shiro的过滤器和拦截器\n\n### 拦截器与过滤器定义\n- 过滤器是一个程序，它先于与之相关的servlet或JSP页面运行在服务器上。它依赖于servlet容器。\n- 拦截器，在AOP（Aspect-Oriented Programming）中用于在某个方法或字段被访问之前，进行拦截然后在之前或之后加入某些操作。拦截是AOP的一种实现策略。\n\n在shiro中存在下图关系  \n![shiro](https://jiangtj.github.io/assets/img/others/shiro%E8%BF%87%E6%BB%A4%E5%99%A8%E4%B8%8E%E6%8B%A6%E6%88%AA%E5%99%A8.PNG)\n\n<!-- more -->\n\n### 过滤器\n在开涛博客中 [第八章 拦截器机制——《跟我学Shiro》](http://jinnianshilongnian.iteye.com/blog/2025656) 这里的拦截器主要为过滤器，依赖于servlet，并存在shiro-web包中。开涛讲的很完整，没必要继续讲解，这块不懂得，先点进去了解。\n\n### 拦截器\n那么shiro的拦截器又在哪里，怎么调用的呢？\n\n其实，shiro对使用注解方式，进行权限控制的过程是通过拦截器来实现的。接下以spring中集成shiro注解为例，讲解shiro的实现过程。\n\n#### step1: spring配置shiro 注解提供类\n```java\n    @Bean\n    public AuthorizationAttributeSourceAdvisor getAuthorizationAttributeSourceAdvisor(SecurityManager securityManager){\n        AuthorizationAttributeSourceAdvisor advisor = new AuthorizationAttributeSourceAdvisor();\n        advisor.setSecurityManager(securityManager);\n        return advisor;\n    }\n```\n这里，需要为spring提供AuthorizationAttributeSourceAdvisor的实例，同时，将shiro 安全管理器赋值给它\n#### step2: AuthorizationAttributeSourceAdvisor的实现\n先看源码\n```java\npublic class AuthorizationAttributeSourceAdvisor extends StaticMethodMatcherPointcutAdvisor {\n\n    ... //省略了部分\n\n    protected SecurityManager securityManager = null;\n\n    public AuthorizationAttributeSourceAdvisor() {\n        this.setAdvice(new AopAllianceAnnotationsAuthorizingMethodInterceptor());\n    }\n\n    public SecurityManager getSecurityManager() {\n        return this.securityManager;\n    }\n\n    public void setSecurityManager(SecurityManager securityManager) {\n        this.securityManager = securityManager;\n    }\n\n    ... //省略了部分\n}\n```\n`StaticMethodMatcherPointcutAdvisor`的构造函数中提供`AopAllianceAnnotationsAuthorizingMethodInterceptor`来为其提供注解拦截器。\n#### step3: AopAllianceAnnotationsAuthorizingMethodInterceptor\n```java\n\npublic class AopAllianceAnnotationsAuthorizingMethodInterceptor extends AnnotationsAuthorizingMethodInterceptor implements MethodInterceptor {\n    public AopAllianceAnnotationsAuthorizingMethodInterceptor() {\n        List<AuthorizingAnnotationMethodInterceptor> interceptors = new ArrayList(5);\n        AnnotationResolver resolver = new SpringAnnotationResolver();\n        interceptors.add(new RoleAnnotationMethodInterceptor(resolver));\n        interceptors.add(new PermissionAnnotationMethodInterceptor(resolver));\n        interceptors.add(new AuthenticatedAnnotationMethodInterceptor(resolver));\n        interceptors.add(new UserAnnotationMethodInterceptor(resolver));\n        interceptors.add(new GuestAnnotationMethodInterceptor(resolver));\n        this.setMethodInterceptors(interceptors);\n    }\n\n    ... //省略了部分\n\n}\n```\n这一步定了注解获取类`SpringAnnotationResolver`和一系列默认的注解拦截器，如果不使用`SpringAnnotationResolver`，shiro会调用自身的`DefaultAnnotationResolver`,初步看了一下，这两类基本差不多，都是获取注解用的。  \n默认的注解拦截器有以下几种：\n- RoleAnnotationMethodInterceptor 角色注解拦截器，对应`@RequiresRoles`，判断用户是否拥有角色，下面的权限同理\n- PermissionAnnotationMethodInterceptor 权限注解拦截器，对应`@RequiresPermissions`\n- AuthenticatedAnnotationMethodInterceptor 授权注解拦截器，对应`@RequiresAuthentication`，判断用户是否已被授权\n- UserAnnotationMethodInterceptor 用户注解拦截器，对应`@RequiresUser`，检查用户是否通过记住密码的方式登陆，该注解必须进行登陆操作才能通过\n- GuestAnnotationMethodInterceptor 访客注解拦截器，对应`@RequiresGuest`，比较少见的注解，表示未登录用户访问的接口。\n\n#### step4: AuthorizingAnnotationMethodInterceptor\n所有的默认拦截器都继承`AuthorizingAnnotationMethodInterceptor`，我们以权限拦截器为例。\n```java\npublic class PermissionAnnotationMethodInterceptor extends AuthorizingAnnotationMethodInterceptor {\n    public PermissionAnnotationMethodInterceptor() {\n        super(new PermissionAnnotationHandler());\n    }\n\n    public PermissionAnnotationMethodInterceptor(AnnotationResolver resolver) {\n        super(new PermissionAnnotationHandler(), resolver);\n    }\n}\n```\n这里构造函数内提供了`PermissionAnnotationHandler`权限注解的处理类，提供权限判断。到这里一切都清晰了，需要自定义注解一个一个自定义下来，并提供一个新的继承自`AuthorizingAnnotationMethodInterceptor`的类。需要重写默认拦截器，需要覆盖对应的处理类。\n\n### 后记\n在一个项目中，我需要重新写权限的判断。开始，我重写了`PermissionsAuthorizationFilter`然而未进该类。不得已，盯着注解一步步走下去。原来shiro内部是这样的，为此，我总算是下定决心学spring security了。","categories":["后端"],"tags":["Shiro"]},{"title":"Spring Boot使用GitLab CI自动部署","url":"/articles/almond/spring-boot-autodeploy-with-gitlab/","content":"# 定义场景\nspring boot应用在手动部署过程中主要分为两步，打包编译与上传部署（也可能存在测试环境，但由于该项目目前只有我开发，并未写测试用例）。同样的在gitlab-ci文件中也定义相应的两步骤\n```yml\nstages:\n  - build\n  - deploy\n```\n<!-- more -->\n\n# 编译\n使用GitLab公共CI服务为Spring Boot打包编译。image定义所使用的docker镜像，stage指定场景，script打包脚本（跳过测试阶段），artifacts定义需要归档的文件，only指定仅release分支打包（支持正则表达式）\n```yml\nrelease-build:\n  image: maven:3.5.2-jdk-8\n  stage: build\n  script: \"mvn package -B -Dmaven.test.skip=true\"\n  artifacts:\n    paths:\n      - target/bill-server.jar\n  only:\n    - /^release-.*$/\n```\n\n# 部署\n配置文件的结构与编译的基本一直，这里使用ubuntu镜像，如果您使用的yam请替换相应的命令。如果您使用自己的CI Runner(shell)，建议密钥存放在自己的服务器上，手动配置实现对部署服务器的ssh访问\n```yml\nrelease-deploy:\n  image: ubuntu\n  stage: deploy\n  script:\n\n    - 'which ssh-agent || ( apt-get update -y && apt-get install openssh-client git -y )'\n    - eval $(ssh-agent -s)\n    ##\n    ## Add the SSH key stored in SSH_PRIVATE_KEY variable to the agent store\n    ## We're using tr to fix line endings which makes ed25519 keys work\n    ## without extra base64 encoding.\n    ## https://gitlab.com/gitlab-examples/ssh-private-key/issues/1#note_48526556\n    ##\n    # Generate the private/public key pair using:\n    #\n    #     ssh-keygen -f deploy_key -N \"\"\n    #\n    # then set the $SSH_PRIVATE_KEY environment variable in the CI (Travis-CI,\n    # GitLab-CI, ...) to the base64 encoded private key:\n    #\n    #     cat deploy_key | base64 -w0\n    #\n    # and add the public key `deploy_key.pub` into the target git repository (with\n    # write permissions).\n    - ssh-add <(echo \"$SSH_PRIVATE_KEY\" | base64 --decode)\n\n    - mkdir -p ~/.ssh\n    - chmod 700 ~/.ssh\n\n    - ssh-keyscan 119.28.1.107 >> ~/.ssh/known_hosts\n    - chmod 644 ~/.ssh/known_hosts\n    - scp target/bill-server.jar ubuntu@119.28.1.107:bill\n    - ssh ubuntu@119.28.1.107 \"cd bill; sh bill-start.sh\"\n\n  only:\n    - /^release-.*$/\n```\n其中shell脚本，与我的[另一篇博客](https://www.dnocm.com/articles/almond/spring-boot-autorun-with-gitlab/)类似，稍做修改就行\n\n# 参考文档\n- [GitLab CI Document](https://docs.gitlab.com/ee/ci/)\n- [bill-server example](https://gitlab.com/dream-room/bill-server/blob/master/.gitlab-ci.yml)\n","categories":["后端"],"tags":["CI","Java","Shell"]},{"title":"Spring Boot 自动重启脚本","url":"/articles/almond/spring-boot-autorun-with-gitlab/","content":"一个脚本，自动从GitLab上下载jar，同时重启服务。为后续的CI自动部署做准备\n```sh\n#!/bin/sh\n#defined\necho \"通过GitLab-CI下载jar\"\nwget -O bill-server.jar \"https://gitlab.com/dream-room/bill-server/-/jobs/artifacts/$1/raw/target/bill-server.jar?job=release-build\"\necho \"查询已存在进程\"\npgrep -af bill-server\necho \"结束已存在进程\"\npkill -f bill-server\necho \"开始运行$1\"\nnohup java -jar bill-server.jar &\necho \"更新结束\"\n```\n运行\n```bash\nsh bill-start.sh release-0.0.3\n```\n","categories":["后端"],"tags":["CI","Java","Shell"]},{"title":"Spring Boot Relaxed Binding 2.0","url":"/articles/almond/spring-boot-relaxed-binding-2.0/","content":"\nSpring Boot 中的配置绑定一直是其最主要的特性。而在Spring Boot 2.0中，该绑定方式做了大量的修改，并且借机制定一些新的规范，以减少过于宽松的绑定规则导致的一些问题\n\n> 您也可以通过官方的[Relaxed-Binding-2.0 wiki](https://github.com/spring-projects/spring-boot/wiki/Relaxed-Binding-2.0)了解详细\n\n<!-- more -->\n\n# 设置配置属性\n\n## 简单的类型\n\n配置文件中的简单类型，都会被移除特殊字符并转为小写后，进行绑定。例如下面的几个配置都等价于`spring.jpa.databaseplatform=mysql`:\n```properties \nspring.jpa.database-platform=mysql\nspring.jpa.databasePlatform=mysql\nspring.JPA.database_platform=mysql\n```\n> 当然，推荐的是kebab-case命名，也是上面例子中的`spring.jpa.database-platform=mysql`\n\n## List类型\nList类型的属性，在配置文件中需要使用`[ ]`标记符:\n```properties\nspring.my-example.url[0]=http://example.com\nspring.my-example.url[1]=http://spring.io\n```\n或者yml的标准写法\n```yml\nspring:\n  my-example:\n    url:\n      - http://example.com\n      - http://spring.io\n```\n同时，还支持使用逗号分割成数组，例如：\n```properties\nspring.my-example.urls=http://example.com,http://spring.io\n```\n注意：在properties，如果遗漏中间的索引，会导致无法绑定异常，下面是不被允许的：\n```properties\nfoo[0] = a\nfoo[2] = b\n```\n\n## Map 类型\nMap类型标准格式很简单`my-example.key=value`，yml类似的，但当遇到特殊字符时，就需要特别处理，但官方文档上讲的，不是很清楚，所以写了几个例子做实验   \n\n```properties\njwt.test.xx=1\njwt.test.xx-xx=2\njwt.test.XX-xx=3\njwt.test.[ww-ww]=4\njwt.test.'[uuu/w1]'=5\njwt.test.[uuu/w2]=6\n```\n\n```yml\njwt:\n  ymltest:\n    foo: 1\n    ppp-vvv: 2\n    [scfds-tgro]: 3\n    '[csf-te]': 4\n    '[csf/e]': 5\n```\n\n结果如下图所示：   \n![](/images/md/others/spring-test-map.png)    \n\n\n## 环境变量\n在环境变量中，使用`_`代替`.`或者`[]`，如果`_`包围的是一数字，就替换为`[]`，其余情况为`.`，例如：   \n```\nMY_FOO_1_ = my.foo[1]\nMY_FOO_1_BAR = my.foo[1].bar\nMY_FOO_1_2_ = my.foo[1][2]\n```\n\n# 读取配置属性\n\n如果，你需要从环境中读出属性值到你的app中，你需要使用与配置文件一样规则的名称\n- 相同的名称\n- 必须是 (a-z,0-9)字母\n- 必须是 小写\n- 唯一允许的特殊字符是`[]`，用于表示list的索引\n- 用连接符`-`分割单词\n- 不能以数字开头   \n\n下面是一个从配置文件中读出属性的例子：\n```java\nthis.environment.containsProperty(\"spring.jpa.database-platform\")\n```\n> @Value 也需要遵守一样的规则\n\n\n\n","categories":["后端"],"tags":["Spring Boot"]},{"title":"测试驱动开发(TDD)的实践","url":"/articles/almond/test-driven%20development/","content":"\n测试驱动开发(TDD)是一种很好的方法论，虽然在国内并不被重视。但仍然想抽时间写一篇关于测试驱动开发的文档。      \n\nOK,最好的描述方式应该分为三部分吧，是什么？为什么？怎么做？那么就从这三部分，分别的描述测试驱动开发方法论。 \n\n<!-- more -->  \n\n# What: TDD 是什么\n\n测试驱动开发，英文全称Test-Driven Development，简称TDD，是一种不同于传统软件开发流程的新型的开发方法。它要求在编写某个功能的代码之前先编写测试代码，然后只编写使测试通过的功能代码，通过测试来推动整个开发的进行。这有助于编写简洁可用和高质量的代码，并加速开发过程。    \n\nKent Beck先生最早在其极限编程（XP）方法论中，向大家推荐“测试驱动”这一最佳实践，还专门撰写了《测试驱动开发》一书，详细说明如何实现。经过几年的迅猛发展，测试驱动开发已经成长为一门独立的软件开发技术，其名气甚至盖过了极限编程。      \n\n# Why: 为什么需要 TDD\n\n> 再摘个百度百科中的例子    \n\n盖房子的时候，工人师傅砌墙，会先用桩子拉上线，以使砖能够垒的笔直，因为垒砖的时候都是以这根线为基准的。TDD就像这样，先写测试代码，就像工人师傅先用桩子拉上线，然后编码的时候以此为基准，只编写符合这个测试的功能代码。    \n\n而一个新手或菜鸟级的小师傅，却可能不知道拉线，而是直接把砖往上垒，垒了一些之后再看是否笔直，这时候可能会用一根线，量一下砌好的墙是否笔直，如果不直再进行校正，敲敲打打。使用传统的软件开发过程就像这样，我们先编码，编码完成之后才写测试程序，以此检验已写的代码是否正确，如果有错误再一点点修改。    \n\n你是希望先砌墙再拉线，还是希望先拉线再砌墙呢？如果你喜欢前者，那就算了，而如果你喜欢后者，那就转入TDD阵营吧！详细可参阅。   \n\n上述例子中也已经能看出TDD的优点。但还是做个简单总结吧    \n\n它有助于编写简洁可用和高质量的代码，有很高的灵活性和健壮性，能快速响应变化，并加速开发过程    \n\n我们可以这么理解这句话，原本需求->产品设计->产品实现，调整为需求->产品设计->产品开发设计（Test阶段）->产品实现（Develop阶段）    \n\n- 产品开发设计（Test过程）: 由于仅先编写测试用例，相对于直接的开发更加迅速，能快速的响应需求的变化     \n- 产品实现（Develop阶段）: 我们仅需确保测试用例都通过，能有效的降低引入bug的可能性。同时测试用例的存在，对于后期维护，提供了强大的支持（回归测试）    \n\n# How: TDD 如何实践\n\n我的实践是 Spring Test + TestNG 集成测试，再配合 Spring Restdocs 文档生成。    \n\n## Spring Test\n\n首先，这不是一个独立的框架，它与Spring框架是绑在一起的，正如开头的第一句话所说，测试驱动在国内不受重视，但在国外恰恰相反。大部分国外的开源框架都集成了测试所需的一些工具类，比如[Spring Boot 单独的一节讲解测试](https://docs.spring.io/spring-boot/docs/2.0.1.RELEASE/reference/htmlsingle/#boot-features-testing)。在这里我们需要用到它的一个TestNG支持的抽象类`AbstractTransactionalTestNGSpringContextTests`，这个类的用于初始化Spring环境以及添加事务支持   \n\n## TestNG\n\n在Java里，最为流行的测试框架应该是JUnit和TestNG，他们的功能也十分相似。在这里，做个简单的比较，和阐述一下采用TestNG的原因    \n\n首先，先说一下JUnit，它是个优秀的单元测试框架，严格的遵守一个实现类一个测试类的方式。事实上，如果对代码质量要求很高，的确需要对每个类都编写测试用例。但例如Spring的代码，分为Dao层，Service层，Controller层，即便只是完成一个小功能，都需要编写多个测试类，来完成测试。这中间会耗费许多的时间，同时对于我们程序猿来说，也是件痛苦的事。而且，一般情况下，并需要如此高的质量。TestNG既包涵了JUnit的单元测试的功能，同时他也可以进行集成测试。我们仅需对功能点（接口）编写相应的集成测试，这能减少大量的代码量。所以，如果能把测试用例的编写变成一般轻松的事，谁不愿这么做呢   \n\n## Spring Restdocs\n\nSpring REST Docs helps you to document RESTful services. It combines hand-written documentation written with Asciidoctor and auto-generated snippets produced with Spring MVC Test. This approach frees you from the limitations of the documentation produced by tools like Swagger. It helps you to produce documentation that is accurate, concise, and well-structured. This documentation then allows your users to get the information they need with a minimum of fuss.     \n\n简单的说，它能使用Asciidoctor组合Spring MVC Test生成的代码片段，编写RESTful的接口文档   \n\n## 环境配置\n\n主要是Maven的配置，因为使用TestNG以及Spring Restdocs，我们需要添加以下依赖    \n```xml\n\t\t<!-- test -->\n\t\t<dependency>\n\t\t\t<groupId>org.springframework</groupId>\n\t\t\t<artifactId>spring-test</artifactId>\n\t\t\t<scope>test</scope>\n\t\t</dependency>\n\t\t<!-- option: remove junit -->\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-test</artifactId>\n\t\t\t<scope>test</scope>\n\t\t\t<exclusions>\n\t\t\t\t<exclusion>\n\t\t\t\t\t<artifactId>junit</artifactId>\n\t\t\t\t\t<groupId>junit</groupId>\n\t\t\t\t</exclusion>\n\t\t\t</exclusions>\n\t\t</dependency>\n\t\t<!-- testng -->\n\t\t<dependency>\n\t\t\t<groupId>org.testng</groupId>\n\t\t\t<artifactId>testng</artifactId>\n\t\t\t<version>6.8.13</version>\n\t\t\t<scope>test</scope>\n\t\t</dependency>\n\t\t<dependency>\n\t\t\t<groupId>org.assertj</groupId>\n\t\t\t<artifactId>assertj-core</artifactId>\n\t\t\t<scope>test</scope>\n\t\t</dependency>\n\t\t<!-- restdocs -->\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.restdocs</groupId>\n\t\t\t<artifactId>spring-restdocs-mockmvc</artifactId>\n\t\t\t<scope>test</scope>\n\t\t</dependency>\n```\n\n同时还需要配置Maven插件    \n```xml\n\t\t\t<plugin>\n\t\t\t\t<groupId>org.asciidoctor</groupId>\n\t\t\t\t<artifactId>asciidoctor-maven-plugin</artifactId>\n\t\t\t\t<version>1.5.3</version>\n\t\t\t\t<configuration>\n\t\t            <!-- 默认位置在src/main/asciidoc下 -->\n\t\t\t\t\t<sourceDocumentName>index.adoc</sourceDocumentName>\n\t\t\t\t\t<doctype>book</doctype>\n\t\t\t\t\t<attributes>\n\t\t\t\t\t\t<allow-uri-read>true</allow-uri-read>\n\t\t\t\t\t\t<attribute-missing>warn</attribute-missing>\n\t\t\t\t\t</attributes>\n\t\t\t\t</configuration>\n\t\t\t\t<executions>\n\t\t\t\t\t<execution>\n\t\t\t\t\t\t<id>generate-docs</id>\n\t\t\t\t\t\t<phase>test</phase>\n\t\t\t\t\t\t<goals>\n\t\t\t\t\t\t\t<goal>process-asciidoc</goal>\n\t\t\t\t\t\t</goals>\n\t\t\t\t\t\t<configuration>\n\t\t\t\t\t\t\t<backend>html5</backend>\n\t\t\t\t\t\t\t<sourceHighlighter>highlight.js</sourceHighlighter>\n\t\t\t\t\t\t\t<attributes>\n\t\t\t\t\t\t\t\t<toc2 />\n\t\t\t\t\t\t\t\t<docinfo>shared-head</docinfo>\n\t\t\t\t\t\t\t</attributes>\n\t\t\t\t\t\t</configuration>\n\t\t\t\t\t</execution>\n\t\t\t\t</executions>\n\t\t\t\t<dependencies>\n\t\t\t\t\t<dependency>\n\t\t\t\t\t\t<groupId>org.springframework.restdocs</groupId>\n\t\t\t\t\t\t<artifactId>spring-restdocs-asciidoctor</artifactId>\n\t\t\t\t\t\t<version>2.0.0.RELEASE</version>\n\t\t\t\t\t</dependency>\n\t\t\t\t</dependencies>\n\t\t\t</plugin>\n```\n\n## 组装\n\n1. 我们需要定义自己的TestNG抽象类，继承`AbstractTransactionalTestNGSpringContextTests`，并配置Spring Restdocs      \n```java\n@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\npublic abstract class AbstractAssetsTests extends AbstractTransactionalTestNGSpringContextTests {\n\n    private final ManualRestDocumentation restDocumentation = new ManualRestDocumentation(\"target/generated-snippets\");\n\n    @Autowired\n    private WebApplicationContext context;\n\n    protected MockMvc mockMvc;\n\n    @BeforeMethod\n    public void setUp(Method method) {\n        this.mockMvc = MockMvcBuilders.webAppContextSetup(context)\n                .apply(documentationConfiguration(this.restDocumentation)).build();\n        this.restDocumentation.beforeTest(getClass(), method.getName());\n    }\n\n    @AfterMethod\n    public void tearDown() {\n        this.restDocumentation.afterTest();\n    }\n\n}\n```\n\n2. 编写测试用例，继承我们的抽象类`AbstractAssetsTests`   \n```java\npublic class UserControllerTest extends AbstractAssetsTests {\n\n    @Resource\n    private UserService userService;\n\n    @Test\n    @Rollback\n    public void add() throws Exception {\n        User user = getMockUser();\n        super.mockMvc.perform(MockMvcRequestBuilders.post(\"/user/add\")\n                .contentType(MediaType.APPLICATION_JSON)\n                .content(Objects.requireNonNull(JacksonUtils.toJson(user))))\n                .andExpect(status().isOk())\n                .andExpect(content().contentType(MediaType.APPLICATION_JSON_UTF8))\n                .andDo(document(\"user-add\"));\n    }\n\n    @Test\n    @Rollback\n    public void delete() throws Exception {\n        ResultDto<User> add = userService.add(getMockUser());\n        User user = add.getObject();\n        super.mockMvc.perform(MockMvcRequestBuilders.delete(\"/user/delete\")\n                .param(\"ids\",user.getId()+\"\"))\n                .andExpect(status().isOk())\n                .andExpect(content().contentType(MediaType.APPLICATION_JSON_UTF8))\n                .andDo(document(\"user-delete\"));\n\n    }\n\n    //......\n\n    private User getMockUser() {\n        return User.builder()\n                .name(\"test-001\")\n                .password(\"123456\")\n                .pointId(1L)\n                .roleId(1L)\n                .description(\"TestNG测试帐号\")\n                .build();\n    }\n\n}\n```\n\n3. Asciidoctor拼接代码片段   \n```adoc\n= 接口文档\nMr.J;\n:toc2:\n:toc-title: 目录\n:doctype: book\n:icons: font\n:source-highlighter: highlightjs\n:docinfo: shared-head\n\n\ninclude::readme.adoc[]\n\ninclude::user/user-list.adoc[]\n\n== 例子\n\n简单的接口文档使用 Spring REST Docs 和 TestNG.\n\n`SampleTestNgApplicationTests` makes a call to a very simple service and produces three\ndocumentation snippets.\n\n用户添加:\n\ninclude::{snippets}/user-add/curl-request.adoc[]\n\n用户添加响应:\n\ninclude::{snippets}/user-add/http-response.adoc[]\n\n=== 三级标题\n\n恩恩恩\n```\n\n## 运行试试\n\n1. Maven运行测试用例   \n![](https://jiangtj.github.io/assets/img/others/testng-fail.png)    \n隔得时间有的久（三个月前），加接口变动，其中一个测试用例跑失败了。当然啦，这也展示了Spring Restdocs的另一大特性，对文档的校验，能时刻保证您的文档与接口字段对应，从而减少因文档不准引入错误的可能性    \n\n2. 运行接口文档   \n![](https://jiangtj.github.io/assets/img/others/spring-restdocs-test.png)   \n\n## 测试驱动\n\n以上的步骤，我们走完了测试环境的搭建。但测试驱动并不是写完功能代码编写测试用例，而且在开始前（设计阶段），编写测试用例，为后续的开发提供依据，同时接口文档也需要提前生成为前后端分离开发提供助力    \n\n**那，该怎么做呢？**   \n\n这时候，我们就需要模拟一个实现类，大部分情况下是模拟一个Service。这里推荐使用Spring Test的一个工具`ReflectionTestUtils`，注入测试实现类     \n\n1. 先创建service接口的测试实现，例如    \n```java\npublic class UserServiceTestBean implements UserService {\n\n    @Override\n    public ResultDto<User> getUserById(long id) {\n        ResultDto<User> result = new ResultDto<>(ResultCode.SUCCESS);\n        result.setObject(new User());\n        return result;\n    }\n\n    @Override\n    public ResultDto<User> add(User t) {\n        ResultDto<User> result = new ResultDto<>(ResultCode.SUCCESS);\n        result.setObject(t);\n        return result;\n    }\n\n    //......\n}\n```\n\n2. 在调用之前注入测试的模拟对象    \n```java\n    @Test\n    @Rollback\n    public void add() throws Exception {\n\n        //为userController注入userService对象\n        ReflectionTestUtils.setField(userController, \"userService\", new UserServiceTestBean());\n\n        User user = getMockUser();\n        super.mockMvc.perform(MockMvcRequestBuilders.post(\"/user/add\")\n                .contentType(MediaType.APPLICATION_JSON)\n                .content(Objects.requireNonNull(JacksonUtils.toJson(user))))\n                .andExpect(status().isOk())\n                .andExpect(content().contentType(MediaType.APPLICATION_JSON_UTF8))\n                .andDo(document(\"user-add\"));\n    }\n```\n\n这样我们完成了在实现之前，优先编写完测试用例。当然当service实现后，相应的mock代码都需要注释掉。使用Mockito模拟service对象也是行的，但在尝试后，不如直接编写测试对象来的高效。    \n\n\n\n# 结尾 \n上面代码开源在GitHub上，有兴趣的可以去看看  \n<https://github.com/JiangTJ/enterpriseAssetManagement/tree/testng%26spring-rest-docs>   \n缺少mock相关的代码，毕竟当时写测试用例时，service已经全部实现了，当然，您可以fork后自己尝试一下mock一些对象    \n\n","categories":["后端"],"tags":["Test","实践"]},{"title":"TICK Stack 实践之监控服务器","url":"/articles/almond/tick-stack-for-server/","content":"\n[TICK Stack](https://www.influxdata.com/time-series-platform/)是由一系列的服务组成的监控分析处理数据的解决方案，一般用于系统监控，或者收集处理与时间紧密相关的数据。\n\n它包含了以下服务：\n- Telegraf 是一个插件驱动的代理服务，用于收集并提供系统数据（如CPU、内存等）\n- InfluxDB 是一个时序数据库，为满足高负载的读写而开发的数据库\n- Chronograf 通过图表可视化分析数据的服务\n- Kapacitor 是数据处理服务，用于批处理数据以及必要时提醒用户等\n\n<!-- more -->\n\n# 安装\n\nTICK在官网<https://portal.influxdata.com/downloads>提供相应的下载安装方式，注意需要翻墙（JQuery引用的是Google源，会导致页面点击无反应）\n下面是Ubuntu & Debian的安装方式\n\n```bash\n# telegraf\nwget https://dl.influxdata.com/telegraf/releases/telegraf_1.6.2-1_amd64.deb\nsudo dpkg -i telegraf_1.6.2-1_amd64.deb\n# influxdb\nwget https://dl.influxdata.com/influxdb/releases/influxdb_1.5.2_amd64.deb\nsudo dpkg -i influxdb_1.5.2_amd64.deb\n# chronograf\nwget https://dl.influxdata.com/chronograf/releases/chronograf_1.4.4.2_amd64.deb\nsudo dpkg -i chronograf_1.4.4.2_amd64.deb\n# kapacitor\nwget https://dl.influxdata.com/kapacitor/releases/kapacitor_1.4.1_amd64.deb\nsudo dpkg -i kapacitor_1.4.1_amd64.deb\n```\n\n也可以通过添加apt源安装\n\n```bash\ncurl -sL https://repos.influxdata.com/influxdb.key | sudo apt-key add -\nsource /etc/lsb-release\necho \"deb https://repos.influxdata.com/${DISTRIB_ID,,} ${DISTRIB_CODENAME} stable\" | sudo tee /etc/apt/sources.list.d/influxdb.list\nsudo apt-get update\nsudo apt-get install influxdb\nsudo apt-get install telegraf\nsudo apt-get install chronograf\nsudo apt-get install kapacitor\n```\n\n\n# 运行\n\n通过linux命令启动相应的服务\n\n```bash\nsudo systemctl start telegraf\nsudo systemctl start influxdb\nsudo systemctl start kapacitor\nsudo systemctl start chronograf\n```\n\n默认情况下，访问<http://chronograf-ip:8888>即可\n\n# 配置\n\n一般情况下需要调整配置文件，使服务满足我们的需求，如权限等。\n\n可以查看官方相关的文档配置\n\n- [chronograf](https://docs.influxdata.com/chronograf/v1.4/introduction/getting-started/)\n- [influxdb](https://docs.influxdata.com/influxdb/v1.5/)\n\n目前Chronograf 的权限支持github,google等账号体系，但企业内部使用可能需要重新开发，满足企业内部帐号权限系统\n\n# 其他\n\n事实上，监控的功能挺多余的，云服务商一般都为我们提供了不错的监控服务。但influxdb，目前来说最主流的时序数据库，可以用来存储其他一些数据。例如网站的访问量等。再通过chronograf展示数据，在[我的博客](https://www.dnocm.com/)的左侧菜单上有站点数据，就是通过这种方式来实现的，[我统计用的js脚本可以点这里看](https://gitlab.com/JiangTJ/jiangtj.gitlab.io/blob/master/source/_data/metric.swig)。\n\n# 参考\n\n- [TICK技术栈 -- DevOps轻量级监控解决方案](https://blog.csdn.net/lin_credible/article/details/60579738)\n- [Open Source Time Series Platform](https://www.influxdata.com/time-series-platform/)\n\n","categories":["运维"],"tags":["TICK Stack"]},{"title":"关于Google Ads","url":"/articles/beechnut/about-google-ads/","content":"在今天，加入了Google Ads，不过更多的是想体验一下广告的收益以及对页面浏览的影响。我使用的是自动广告，但自己访问，完全没有任何广告的影子，不知道是不是配错了。如果亲们访问时对你们造成了影响（或者发现了广告的影子），可以截个图，通过右下角的Chatra联系我。  \n\n~~对页面访问有影响的话会下掉广告，毕竟没国际信用卡，就算赚了也取不出来。~~  \n去掉去掉，毕竟每天只有1-2pv，一个月也就半百人访问这个小破站，而且谷歌广告需要点击才收费，点击一次3毛。。。。(2019.1.15写)\n\n另外页面会使用Google分析。。。这个可能对国内用户访问造成影响，请尽量在VPN下访问该站点，[vultr](https://www.vultr.com/)与[outline](https://getoutline.org/zh-CN/home)是不错的方案，或者可以看一下我的[VPN教程](https://www.dnocm.com/articles/beechnut/vpn-white/)\n\n> 又双叒叕加回来啦😂---2019.7.28\n"},{"title":"探究：优惠券的设计","url":"/articles/beechnut/coupon-info/","content":"\n最近几天，和朋友讨论了许多优惠券相关的问题，他以产品的角度，探究优惠券的意义场景等。他阐释，优惠券的本质是价格歧视，通过对不同消费者提供不同的收费标准，以此来增加营收。\n\n当然，从我的角度出发（程序猿），我并不关心优惠券的目的，而更感兴趣于架构的设计，毕竟这块很有挑战性。比如满减或者折扣等涉及支付系统，用户领取使用又涉及用户系统等等（这里假设在微服务架构下）通常优惠券会影响多个系统，除此外，优惠规则与限制条件又十分复杂。但越难才越有意思。\n\n我初步将优惠券系统分为以下四个部分：\n\n- 优惠券主体，简单说定义名称或者一些说明之类\n- 优惠策略，定义处理优惠的方式\n- 限制规则，在这部分中定义什么条件下可使用或者“过期”\n- 发放策略，定义何时如何发放，一般情况下与用户和活动系统相关\n\n为了实现一个我理想中的优惠券系统\n\n- 支持多张券同时使用\n- 支持各种限制，甚至自定义限制\n- 尽可能的降低各个系统与优惠券系统的耦合性\n\n<!-- more -->\n\n![](https://jiangtj-lab.github.io/pic-repo/img-apricot/20191106145354.png)\n\n*发放策略与其他系统紧密相关，暂时未设计数据结构*\n\n# 优惠券主体\n\n这部分是优惠券的一些共同的信息，一般在查询展示时用到。所以前期比较简单，但后期如果需要对优惠券美化时，就需要扩展这部分来支持\n\n建议创建后不允许修改优惠券，为后续订单追溯优惠提供可能\n\n# 优惠策略\n\n优惠的策略与主体间是1对1的关系（一张优惠券一种优惠方式），理论上这部分可以和主体存放在一张表内\n\n优惠策略的关键在于handler处理器，所有的优惠策略处理器都需要继承优惠处理器相关的接口，例如java版如下（其他语言应该也能有类似的功能把）\n\n```java\npublic interface DiscountHandler {\n    String name();\n    default BigDecimal handle(BigDecimal price, String args) {\n        return price;\n    }\n    default int order() {\n        return 0;\n    }\n}\n```\n\n比如满减与折扣策略的实现可以如下\n\n```java\npublic class SubtractDiscountHandler implements DiscountHandler {\n    @Override\n    public String name() {\n        return \"立减\";\n    }\n    @Override\n    public BigDecimal handle(BigDecimal price, String args) {\n        return price.subtract(new BigDecimal(args));\n    }\n}\npublic class MultiplyDiscountHandler implements DiscountHandler {\n    @Override\n    public String name() {\n        return \"折扣\";\n    }\n    @Override\n    public BigDecimal handle(BigDecimal price, String args) {\n        return price.multiply(new BigDecimal(args));\n    }\n    @Override\n    public int order() {\n        return 1;\n    }\n}\n```\n\n其中，name用于记录处理器的名称，spring可以获取所有DiscountHandler的实例，我们处理后，作为选择列表供用户选择，使用哪个处理器\n\nargs在不同处理器时，具有不同的含义，在SubtractDiscountHandler下，填1，表示立减1元，MultiplyDiscountHandler下填0.9，表示打9折\n\n当用户选择优惠券(多张)后，获取选择的优惠券的处理器并依据order排序，依次处理价格(一般情况我们会把折扣放在后面处理，减少总的优惠额)\n\n# 限制规则\n\n限制规则与优惠策略处理的方式是一样的，不同点在于优惠券主体与限制规则是1对多的关系。\n\n限制规则的handler也与优惠券有点区别，大致如下\n\n```java\n@Data\npublic class LimitHandlerContext {\n    private Object coupon;\n    private List<Object> selectedCoupons;\n    private Object params;\n}\npublic interface LimitHandler {\n    String name();\n    default boolean handle(LimitHandlerContext context, String args) {\n        return true;\n    }\n    default int order() {\n        return 0;\n    }\n}\n```\n\n与优惠策略不同，不在传递与处理价格，而是传入LimitHandlerContext容器，由此判断是否拦截（false：拦截，true：通过）\n- coupon：指当前触发限制规则的优惠券\n- selectedCoupons：指全部已选择的优惠券\n- params：额外参数，有业务系统决定比如传递类型等\n\n比如，下面是一些限制规则实例\n\n> TBD\n\n# 发放策略\n\n发放策略在优惠券部分的逻辑其实只是添加一条用户领取的记录，但其难在何时如何领取优惠券。所以，总结一下就是\n1. 优惠券系统需要暴露API给外部系统调用，以生成用户的优惠券领取记录\n2. 在外部系统（比如活动系统），制定其领取规则\n\n那么接下来简单说下活动系统的实现思路（尽管我认为它已经不属于优惠券系统了）\n\n> TBD\n\n*注：为了降低系统间的耦合性，这部分可以使用发布订阅模式*\n","categories":["架构"],"tags":["优惠券","设计"]},{"title":"两幅图，谷歌与百度的差距有多大","url":"/articles/beechnut/google-vs-baidu/","content":"\n{% asset_img box baidu.png baidu %}\n{% asset_img box google.png google %}\n<a href=\"https://www.baidu.com\"><img class=\"box\" title=\"baidu\" data-src=\"/articles/beechnut/google-vs-baidu/baidu.png\" src=\"/articles/beechnut/google-vs-baidu/baidu.png\"></a>\n\n在针对性的SEO优化方面\n- 百度： 提供sitemap与提供百度蜘蛛自动推送\n- 谷歌： 提供sitemap\n\n就这样！\n"},{"title":"使用Git Submodule管理Hexo主题","url":"/articles/beechnut/hexo-git-submodule/","content":"\n不多说废话，介绍一种简单又近乎完美的主题管理方式。文章中使用[Cake](https://github.com/jiangtj/hexo-theme-cake)主题介绍，如果你使用NexT替换对应的链接。\n\n需要提前储备的知识，如果不懂请至百度\n- 基本的Git操作（Git Init/Add/Commit/Pust/Fetch/Pull）\n- 基本的Node/NPM操作（npm install）或者Yarn（类似于NPM）\n- 基本的Hexo命令（hexo init/cl/s/g）\n\n<!-- more -->\n\n# 初始化项目\n\n首先我们创建一个新的hexo项目，命令行运行以下命令\n```bash\n# Create a new hexo project\nhexo init <dir>\ncd <dir>\n```\n\n将该项目使用Git管理\n```bash\ngit init\n# do something by yourself, if you want to push it to GitHub.\n```\n\n添加Cake主题作为该项目的Git子模块\n```bash\ngit submodule add https://github.com/JiangTJ/hexo-theme-cake themes/cake\n```\n\n修改Hexo中的配置文件`theme`为`cake`\n\n一个基本的项目通过上面的步骤可以创建，如果你看到这篇文章前已经有自己的博客项目，定位到未完成的步骤起，跟着走完。\n\n# 更新主题版本\n\n如果你使用的主题仍在被维护，那么你能从远程获取更新。这部操作很简单，像下面这样：\n```bash\ngit submodule update --remote\n```\n\n它会从远程拉取最新master上的代码至你的子模块（也就是你的主题）中\n\n> 如果你想修改拉取的分支通过`git config -f .gitmodules submodule.themes/cake.branch stable`，一般情况下，master分支足够好，不需要修改\n\n# 使用npm脚本替换\n\ngit submodule的命令不好记，另一种方式是使用npm脚本替换。编辑`package.json`文件，添加以下内容：\n```json\n{\n  \"name\": \"mrtt-hexo-blog\",\n  \"version\": \"1.0.0\",\n  \"private\": true,\n  \"scripts\": {\n    \"update-theme\": \"git submodule update --remote\"\n  },\n  \"hexo\": {\n    \"version\": \"3.9.0\"\n  },\n  \"dependencies\": {\n    //...\n  }\n}\n```\n\n之后每次更新都只需要运行`npm run update-theme`\n\n# 自定义主题\n\n这个问题经常被提到，想要从官方的远程仓库获取更新，但又希望能修改主题的文件，添加自己的代码，也就是传说中的魔改，怎么处理呢\n\n一种方式是fork，然后将自己fork的主题作为子模块，但每次更新需要先将官方的更新同步至你fork的主题（有点麻烦）\n\n另一种是这里介绍的：替换。我不对主题文件做修改，但我能在外面创文件。思路是将外面与主题的文件路径一致替换掉对应的主题的文件\n\n## 替换\n\n首先，安装一个hexo插件[hexo-theme-plus](https://github.com/jiangtj/hexo-theme-plus)\n```bash\nnpm i --save @jiangtj/hexo-theme-plus\n```\n\n默认情况下，已经配置好了替换路径，如果你需要修改，在hexo中修改以下配置\n```yml\ntheme_plus:\n  custom_path: custom/theme # disabled: set 'false'\n```\n\n在`custom/theme`创建对应的主题文件，比如`${theme_dir}/layout/_partials/footer.swig`，将它复制到`${hexo_dir}/custom/theme/_partials/footer.swig`，然后稍微做些修改，比如我在作者信息那里加了个颜表情Ծ‸ Ծ\n```html\n  <span class=\"author\" itemprop=\"copyrightHolder\">{{ theme.footer.copyright || author }} Ծ‸ Ծ</span>\n```\n\n`hexo s`运行预览，我们可以看到最底下，作者的后面已经加上了Ծ‸ Ծ\n\n> Replace存在一点缺陷，首先只支持`layout`下的文件，其次需要主题支持（使用partial，不能用模版的特定的语法比如include），Cake除了`layout`根目录下外，其余都支持替换，但NexT需要你替换`include` `macro`等语法\n\n## 注入\n\n除了替换，还可以在注入点注入任何你希望的代码，详细见我上篇文章[Hexo NexT 高阶教程之 Injects](/articles/beechnut/hexo-next-injects/)\n\n# 另一台电脑上编辑\n\n使用Git仓库同步的情况下，如果你需要在另一台电脑上工作，你唯一需要做的事是在`git clone`命令上加上`--recursive`\n\n```bash\ngit clone --recursive https://github.com/your-name/your-blog\n```\n\n如果是GUI工具，那么什么都不用改变，它们默认都是加`--recursive`的\n\n如果你忘记加`--recursive`了，多执行下以下命令，当然你也可以将它加入到你的npm scripts里，方便记住它\n\n```bash\ngit submodule init\ngit submodule update\n```\n\n# 总结\n\n1. 不要修改任何主题文件，我相信替换与注入配合，你已经能修改任何的主题代码了，这能保证你的主题仓库可以直接设置为官方的仓库，且更新无冲突\n2. 需要记住的命令很少，就两个`git submodule update --remote`和`git clone --recursive repo`\n","categories":["前端"],"tags":["Git","Hexo"]},{"title":"Hexo Netlify CMS 1.0","url":"/articles/beechnut/hexo-netlify-cms-1.0/","content":"\nHexo Netlify CMS隔了好久终于迎来了一次大更新（不兼容），主要有以下的更新内容\n1. 扩展fields，在原本的Netlify CMS中，fields的设置比较麻烦，这次独立出`global_fields`方便配置\n2. 新增`auto_generator`用于管理`post`与`page`的生成，支持多个`post`配置\n3. 默认配置优化，环境搭好（Netlify启用相应服务）后，不需要额外配置便能使用Netlify CMS\n4. 调试优化，`--debug`一键修改Netlify CMS授权模式为`test-repo`，可直接调试\n\n详细的文档见[GitHub的Readme](https://github.com/jiangtj/hexo-netlify-cms/blob/master/README-ZH.md)\n","categories":["前端"],"tags":["Hexo"]},{"title":"Hexo Netlify CMS","url":"/articles/beechnut/hexo-netlify-cms/","content":"\n# 缘由\n有时候不想打开电脑修改文章，所以需要一个管理页面代替电脑操作（简单的能修改），一般而言，存在两种方案实现它\n- 调用GitHub（或者其他Repo）的Api，获取与修改文件\n- 通过Git命令获取修改以及推送文件\n\n但无论那种都存在安全问题，如果在本地操作，那么完全没必要管理站点，不是本地的话且使用静态托管的话（如GitHub Page），如何确保是自己修改呢？这就需要一个安全服务，但本身只是偶尔修改使用，撘一个安全服务似乎不划算，所以这件事就一直搁置着  \n\n前段时间，我将静态服务迁移到了Netlify，发现它居然提供了CMS用于管理静态资源，我体验了Gatsby的例子，能上传媒体文件，能添加与修改文章，相对的安全性（Netlify会获取你的Git仓库很多权限，但我不认为它会做恶意破坏的行为）...满足了我的要求。 \n\n<!-- more -->\n\n在将它应用到Hexo的时候，很不方便，官方例子很老旧，而且没有相关插件，所以简单的写了一个...\n\n下面是0.1.1的Hexo Netlify CMS插件的使用文档\n\n# Hexo Netlify CMS\n  \n这是一个Netlify CMS的Hexo插件，你可以使用它，简单的开启Netlify CMS服务.   \n\n[Live Demo](https://github.com/JiangTJ/hexo-netlify-cms-example)\n\n## 如何使用\n### Step1: 添加依赖\n```bash\nyarn add hexo-netlify-cms\n// or npm\nnpm i hexo-netlify-cms --save\n```\n### Step2: 在Hexo中添加配置\n```yaml\nnetlify_cms:\n  backend:\n    name: git-gateway\n    branch: master\n```\n### Step3: 在Netlify中开启服务\n\n开启netlify git-gateway服务\n![](https://raw.githubusercontent.com/JiangTJ/hexo-netlify-cms/master/imgs/git-gateway.png)  \n\n添加netlify-identity-widget.js, 代码如下   \n`<script src=\"https://identity.netlify.com/v1/netlify-identity-widget.js\"></script>`  \n![](https://raw.githubusercontent.com/JiangTJ/hexo-netlify-cms/master/imgs/snippet.png)\n\n**注意： 建议将身份认证设为仅邀请模式**\n\nOkay, 现在Netlify CMS已经好了, 你可以访问`your-site/admin`查看\n\n\n## 其他配置\n自定义pages自动生成配置\n```yml\nnetlify_cms:\n  # pages auto generate\n  pages: \n    enabled: true\n    # over page collection config\n    # if fields not set, would use posts fields config\n    config:\n      label: \"Page\"\n      delete: false\n      editor:\n        preview: true\n      # fields: \n```\n\n自定义配置文件，覆盖[默认的](https://raw.githubusercontent.com/JiangTJ/hexo-netlify-cms/master/admin/config.yml)\n```yml\nnetlify_cms:\n  config_file: netlify.yaml\n```\n\n开启/关闭覆盖时间格式配置(默认true)\n```yml\nnetlify_cms:\n  over_format: true\n```\n\n添加脚本, 用于自定义组件和预览样式   \n例如：    \n添加`example/source/js/cms/youtube.js`至你的博客下   \n```yml\n# 需要跳过配置\nskip_render:\n  - js/**\nnetlify_cms:\n  scripts:\n    - js/cms/youtube.js\n```\n\n另外，其他的`netlify_cms`配置变量可以在[Netlify CMS](https://www.netlifycms.org/docs/configuration-options/)中找到  \n\n## 调试\n```\nyarn link\ncd example\nyarn link hexo-netlify-cms\nhexo s\n```\n\n# 关于脚本\n事实上只是简单的在admin的页面下引入，可以通过Netlift CMS的全局变量`CMS`添加你想实现的自定义组件等。但这块需要花很多时间维护，毕竟预览的原理和hexo生成文件并不一样...    \n\n后续可能会添加对Image Tag的支持(其它应该不考虑实现，因为用不到)....\n\n# 项目\n- [Hexo Netlify CMS](https://github.com/JiangTJ/hexo-netlify-cms)\n","categories":["前端"],"tags":["Hexo"]},{"title":"Hexo NexT 高阶教程之 Injects","url":"/articles/beechnut/hexo-next-injects/","content":"\n# 前世因\n\n这要追溯到3月份，Mimi的[PR:Adding Submodule](https://github.com/theme-next/hexo-theme-next/pull/663)，我们讨论了如何管理第三方依赖。LEAFERx提出了使用NPM管理会更好，他进行了实践PR:Extract leancloud-counter to plugins [#677](https://github.com/theme-next/hexo-theme-next/pull/677) [#707](https://github.com/theme-next/hexo-theme-next/pull/707)。在我看来LEAFERx的方案并不好，因为复杂。所以要做到插件化，有两个必须达到的要求：\n\n1. 灵活与可扩展性，在插件中，我们就要能修改大部分内容。\n2. 操作简单，我们通过极少的代码集成我们想要的功能。\n\n除此外，ivan-nginx还关心文档的问题，但如果能完全独立，存放在插件库中也不是什么大问题。在此期间，我也进行过尝试[PR:Refactoring comments](https://github.com/theme-next/hexo-theme-next/pull/711)，毕竟现在的评论系统真的\"烂\"，一堆`if else`。这次的重构是挺好的尝试，但我不敢轻易合，因为影响大（几乎所有人），而后来发现了另一个方案，是Hexo的一个插件[hexo-inject](https://github.com/hexojs/hexo-inject)，通过注入代码的方式实现定制内容，由于hexo本身与主题分离，它仅能提供4个注入点，可扩展性远远不够。但如果能在NexT中实现，就完全不同了，于是我提了[PR:Add new filter type theme_inject](https://github.com/theme-next/hexo-theme-next/pull/868)\n\n<!-- more -->\n\n# 使用 Injects\n\nOkay，缘由讲到这，接下来来体验下如何使用`theme_inject`。当然，如果你是小白，完全可以使用配置文件中的`custom_file_path`来添加自定义内容。如果想更加定义化，那么跟着我一步步走下去。Injects具体的定义见[NexT文档](https://theme-next.org/docs/advanced-settings#Injects)。这里接下来是个例子，一步步集成[gitter](https://sidecar.gitter.im/)。\n\n## 注入布局\n\n首先，我们在hexo或者theme的`scripts`创建一个js文件（名字随意），添加以下内容。只要是这里面的脚本，hexo运行时会执行它。\n\n```js\nhexo.extend.filter.register('theme_inject', function(injects) {\n  //名字路径等都可以随意修改，为了方便下文都以这里的定义为主\n  injects.head.file('gitter', 'views/gitter.swig', {}, {cache: true});\n});\n```\n\n第二步，我们创建`views/gitter.swig`文件，添加以下内容。\n```html\n<script>\n  ((window.gitter = {}).chat = {}).options = {\n    room: 'your-room-name'\n  }});\n</script>\n<script src=\"https://sidecar.gitter.im/dist/sidecar.v1.js\" async defer></script>\n```\n\n`hexo s`运行，你可以看到右下角已经集成了gitter。\n\n## 注入样式\n\n接下来，我们调整下样式。在脚本中，多加样式的注入。\n\n```js\nhexo.extend.filter.register('theme_inject', function(injects) {\n  injects.head.file('gitter', 'views/gitter.swig', {}, {cache: true});\n  injects.style.push('views/gitter.styl');\n});\n```\n\n创建`views/gitter.styl`文件\n\n```css\n.gitter-open-chat-button {\n  background-color: slateblue;\n  margin-bottom: .8rem;\n  margin-right: 1rem;\n  padding: .4rem .8rem;\n  border-radius: .6rem;\n  box-shadow: 0 0 .4rem #111;\n  opacity: .9;\n}\n\n.gitter-open-chat-button:focus,.gitter-open-chat-button:hover {\n  background-color: slateblue;\n  box-shadow: 0px 0px 0.8rem #111;\n}\n\n.gitter-open-chat-button.is-collapsed {\n  transform: translateY(150%);\n}\n\n.sidebar-toggle {\n  margin-bottom: 18px;\n}\n```\n\n再次运行，按钮的样式变咯，你觉得相对于原来是好看还是...？\n\n# 制作NPM插件\n\n开源的精神在于分享，当你将你的主题自定义之后，你可能会写一篇文章《如何实现在NexT中XXXX》。然后，Visitor看到后，跟着你一点点的改。虽然没什么问题。但毕竟“懒”才是原动力，如果我们能将这一切放入到一个NPM插件中，那么他们使用的时候，就只需要`yarn add xxxx`就行了。这将多方便呀！！！\n\n接下来要实现是一个集合滑动到底部/头部和阅读进度的插件，最终效果见[hexo-cake-moon-menu](https://github.com/jiangtj-lab/hexo-cake-moon-menu)，以及右下角的那个按钮\n\n为了能上传至NPM仓库，你首先需要在它上面创建一个账户:<https://www.npmjs.com/>，另外为了方便，我是用的是yarn作为命令行工具\n\n## 初始化一个NPM包\n\n新建一个文件夹，并在里面运行`yarn init`，会问你一系列的问题(如下面)，完成后会初始化一个package.json\n\n```cmd\nPS C:\\Users\\MrTT\\Desktop\\hexo-moon-menu> yarn init\nyarn init v1.16.0\nquestion name (hexo-moon-menu): @jiangtj/hexo-moon-menu\nquestion version (1.0.0):\nquestion description: Hallo\nquestion entry point (index.js):\nquestion repository url: https://github.com/jiangtj/hexo-theme-cake.git\nquestion author: Mr.J\nquestion license (MIT): LGPL-3.0\nquestion private: false\nsuccess Saved package.json\nDone in 99.85s.\n```\n\n- name建议添加`@scope`也就是`@你的用户名`，毕竟到时候有一样名字的包，无法上传\n- name必须以`hexo-`或者`@scope/hexo-`开头\n\n## 创建例子工程预览插件\n\n你需要将你的插件上传上出（这步原本是最后一步，但由于hexo会检测package.json来执行插件，所以必须先有插件），在当前项目中运行`yarn publish --access public`\n\n添加一个`.gitignore`，如果默认情况下，npm也会依据它忽略不必要的文件\n```\nnode_modules/\n*.log\nexample/\n```\n\n运行以下命令，来创建例子项目\n```bash\n# 在example创建hexo项目\nhexo init example\n# 进入到example目录下\ncd example\n# 添加next主题\ngit clone https://github.com/theme-next/hexo-theme-next themes/next\n# 切换主题配置\nhexo config theme next\n# 切换Gemini scheme, 这次的插件由于和展开侧边栏的冲突，所以Muse中暂时不支持，如果你感兴趣可以自行在Muse中实现\nhexo config theme_config.scheme Gemini\n# 运行预览\nhexo s\n```\n\n关联插件\n```bash\n# 添加依赖\nyarn add \"@jiangtj/hexo-moon-menu\"\n# 为插件创建引用，来调试\ncd ..\nyarn link\ncd example\nyarn link \"@jiangtj/hexo-moon-menu\"\n# 运行预览，由于什么都没做所以没什么变话\nhexo s\n```\n\n## 布局与样式\n\n接下来将我的项目中[hexo-cake-moon-menu](https://github.com/jiangtj-lab/hexo-cake-moon-menu)以下部分复制到你的插件项目\n- default.yaml 默认配置\n- moon-menu.swig 菜单的布局\n- moon-menu.styl 菜单的样式\n\n在上面的Injects使用中，你能体会到重点在于js脚本，样式等都是通过它进行组织的，所以样式我就忽略了，如果你想研究可以查看那些\n\n## 脚本\n\npackage.json 中的 main 定义了脚本的入口文件，默认是`index.js`，所以我们创建它，并添加以下内容\n\n```js\n// 需要引入的依赖\nconst yaml = require('js-yaml');\nconst fs = require('fs');\nconst path = require('path');\n\nhexo.extend.filter.register('theme_inject', function(injects) {\n\n  // 需要禁用原本的按钮\n  hexo.theme.config.back2top.enable = false;\n\n  // 读取默认配置文件\n  // __dirname至该文件的绝对目录，需要注意这里的位置如果不使用path获取绝对路径，文件读出会异常（建议你尝试，体验npm的坑）\n  let defaultConfig = yaml.load(fs.readFileSync(path.join(__dirname, 'default.yaml')));\n  // 合并默认配置与hexo里的moon_menu配置\n  let moonMenu = Object.assign(defaultConfig, hexo.config.moon_menu);\n\n  // 重新组织菜单，排序等\n  let moonMenuArr = Object.keys(moonMenu)\n    .map(key => moonMenu[key])\n    .map(item => {\n      item.order = item.order || 0;\n      if (item.enable === undefined) {\n        item.enable = true;\n      }\n      return item;\n    })\n    .filter(item => item.enable)\n    .sort((a, b) => a.order - b.order);\n\n  // 添加布局\n  injects.bodyEnd.file('moon-menu', path.join(__dirname, 'moon-menu.swig'), {menus: moonMenuArr}, {cache: true, only: true});\n  // 添加样式\n  injects.style.push(path.join(__dirname, 'moon-menu.styl'));\n\n});\n```\n\n忘了，你需要添加`js-yaml`依赖用于解析yaml\n```bash\ncd ..\nyarn add js-yaml\ncd example\nhexo s\n```\n\n再次运行预览，你就可以看到按钮添加到你的例子工程中拉\n\n## 上传与分享\n\n完成后记得别忘记上传`yarn publish --access public`，然后赶紧在自己的博客中试下把`yarn add @jiangtj/hexo-moon-menu`\n\n如果你希望更多看到与使用你的插件，欢迎提交PR至 [Awesome-NexT](https://github.com/theme-next/awesome-next)\n\n## 其它\n\n我们在插件中也可以载入其他hexo的插件，在添加hexo插件（`yarn add plugin-name`）之后。通过以下代码加载脚本\n\n```js\nconst tagcloud = hexo.resolvePlugin('plugin-name')\nhexo.loadPlugin(tagcloud).then(() => {\n  hexo.log.debug('Plugin loaded: plugin-name');\n}).catch(err => {\n  hexo.log.error({err}, 'Plugin load failed: plugin-name');\n});\nhexo.extend.filter.register('theme_inject', injects => {\n  //...\n});\n```\n\n> 注意：`hexo.loadPlugin`需要放在过滤器等的外边，确保其在第一时间执行，上面的代码来自一个例子：[hexo-next-wapper-tag-cloud](https://github.com/jiangtj-lab/hexo-next-wapper-tag-cloud)\n\n# 后世果\n\n虽然这个theme_inject已经合并了，但还有许多需要改进\n- 有必要使NexT更结构化，以提供更多的注入点\n- 评论系统的重构PR关闭了，多方面原因，我计划基于theme_inject重新重构它（Done）\n","categories":["前端"],"tags":["Hexo","NexT"]},{"title":"Intersection Observer 简介","url":"/articles/beechnut/intersection-observer-info/","content":"\nIntersection Observer API提供了一种异步观察目标元素与祖先元素或顶级文档viewport的交集中的变化的方法。这使得以往较难实现的功能，更加简单，例如，监听图片元素，在适当的时候懒加载图片。\n\n<!-- more -->\n\n# 例子\n\n先看下，下面是一个简单的小例子\n\n{% preview %}\n\n<template>\n<div id=\"e1\" style=\"background-color:black;width:100%;height:500px;\">\n  <ul style=\"color:white;\">\n    <li>boundingClientRect:<span id=\"el-boundingClientRect\"></span></li>\n    <li>intersectionRatio:<span id=\"el-intersectionRatio\"></span></li>\n    <li>intersectionRect:<span id=\"el-intersectionRect\"></span></li>\n    <li>isIntersecting:<span id=\"el-isIntersecting\"></span></li>\n    <li>rootBounds:<span id=\"el-rootBounds\"></span></li>\n    <li>time:<span id=\"el-time\"></span></li>\n  </ul>\n</div>\n</template>\n\n<script>\nvar observer = new IntersectionObserver((entries,observer) => {\n  // 我只监听了一个对象\n  let entry = entries[0]\n  document.querySelector(\"#el-boundingClientRect\").innerHTML = JSON.stringify(entry.boundingClientRect);\n  document.querySelector(\"#el-intersectionRatio\").innerHTML = JSON.stringify(entry.intersectionRatio);\n  document.querySelector(\"#el-intersectionRect\").innerHTML = JSON.stringify(entry.intersectionRect);\n  document.querySelector(\"#el-isIntersecting\").innerHTML = JSON.stringify(entry.isIntersecting);\n  document.querySelector(\"#el-rootBounds\").innerHTML = JSON.stringify(entry.rootBounds);\n  document.querySelector(\"#el-time\").innerHTML = JSON.stringify(entry.time);\n  //document.querySelector(\"el-target\").innerHTML = entry.target;\n}, {\n  threshold : [0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0]\n});\nobserver.observe(document.querySelector(\"#e1\"));\n</script>\n\n{% endpreview %}\n\n# 构造器\n\n通过例子，我们可以看到Intersection Observer需要通过构造器来创建，即`new IntersectionObserver(callback[, options])`，参数有两部分组成，一个必传的回调函数以及一个可选的配置参数\n\n## 回调Callback\n\nIntersection Observer的翻译就是“交点观察”，因此，他的回调就成了重点。当观察元素与根元素之间的交叉状态发生变化时，它会将这部分信息反馈回来--通过回调告知\n\n在回调函数里，我们会接受到两个对象，发生状态变化的元素集合以及监听者本身（注意：创建时，会将所有被观察元素的状态传递过来），监听者本身我们可以通过它增加或者减少监听的元素或者销毁自身（后续讲），这里我们更关注观察元素\n\n```js\nfunction callback(entries,observer) {\n  entries -> 一系列被观察的元素\n  observer -> 观察者\n}\n```\n\n`entries` 是一个 `IntersectionObserverEntry` 对象的数组，`IntersectionObserverEntry` 包换以下元素（来自MDN）\n- boundingClientRect: 返回包含目标元素的边界信息的DOMRectReadOnly. 边界的计算方式与 Element.getBoundingClientRect() 相同\n- intersectionRatio: 返回intersectionRect 与 boundingClientRect 的比例值\n- intersectionRect: 返回一个 DOMRectReadOnly 用来描述根和目标元素的相交区域\n- isIntersecting: 返回一个布尔值, 如果目标元素与交叉区域观察者对象(intersection observer) 的根相交，则返回 true .如果返回 true, 则 IntersectionObserverEntry 描述了变换到交叉时的状态; 如果返回 false, 那么可以由此判断,变换是从交叉状态到非交叉状态\n- rootBounds: 返回一个 DOMRectReadOnly 用来描述交叉区域观察者(intersection observer)中的根\n- target: 与根出现相交区域改变的元素 (Element)\n- time: 返回一个记录从 IntersectionObserver 的时间原点(time origin)到交叉被触发的时间的时间戳(DOMHighResTimeStamp)\n\n具体的值是多少，我们可以在最上面的例子中看到，需要注意传递过来的对象都是只读（毕竟回调，只是通知你发生变化了）\n\n## 参数options\n\n我们可以通过 options 配置 IntersectionObserver，他包含以下几项配置\n- root: 监听元素的祖先元素Element对象，其边界盒将被视作视口。目标在根的可见区域的的任何不可见部分都会被视为不可见。默认情况下文档视口会作为root\n- rootMargin: 一个在计算交叉值时添加至根的边界盒(bounding_box)中的一组偏移量，类型为字符串(string) ，可以有效的缩小或扩大根的判定范围从而满足计算需要。语法大致和CSS 中的margin 属性等同。默认值是\"0px 0px 0px 0px\"。\n- threshold: 规定了一个监听目标与边界盒交叉区域的比例值，可以是一个具体的数值或是一组0.0到1.0之间的数组。若指定值为0.0，则意味着监听元素即使与根有1像素交叉，此元素也会被视为可见. 若指定值为1.0，则意味着整个元素都交叉时视为可见。阈值的默认值为0.0。\n\n在上面的例子中，我未修改root与rootMargin，你可以将浏览器的窗口作为可见区域，threshold定义了一系列数组，意味着到达那些交叉比时触发回调\n\n# 属性\n\n在创建或者回调函数中，我们可以得到 IntersectionObserver 对象，他包含以下属性：\n\n- root: 所监听对象的具体祖先元素(element)。如果未传入值或值为null，则默认使用顶级文档的视窗\n- rootMargin: 计算交叉时添加到根(root)边界盒bounding box的矩形偏移量， 可以有效的缩小或扩大根的判定范围从而满足计算需要。此属性返回的值可能与调用构造函数时指定的值不同，因此可能需要更改该值，以匹配内部要求。所有的偏移量均可用像素(pixel)(px)或百分比(percentage)(%)来表达, 默认值为\"0px 0px 0px 0px\"\n- thresholds: 一个包含阈值的列表, 按升序排列, 列表中的每个阈值都是监听对象的交叉区域与边界区域的比率。当监听对象的任何阈值被越过时，都会生成一个通知(Notification)。如果构造器未传入值, 则默认值为0\n\nIntersectionObserver 的属性也都是只读，他在创建之后不支持修改\n\n# 方法\n\nIntersectionObserver 通过以下方法添加或者取消监听元素\n- IntersectionObserver.disconnect() 使IntersectionObserver对象停止监听工作。\n- IntersectionObserver.observe() 使IntersectionObserver开始监听一个目标元素。\n- IntersectionObserver.takeRecords() 返回所有观察目标的IntersectionObserverEntry对象数组。\n- IntersectionObserver.unobserve() 使IntersectionObserver停止监听特定目标元素。\n\n# 真实的例子\n\n## 懒加载\n\nIntersectionObserver 可以很简单的实现图片懒加载，开头就提到的，看下面很少的代码，我们就实现了懒加载的功能（目前已经好些图片懒加载框架使用它了，比如我的博客所使用的lozad.js）\n\n{% preview %}\n\n<template>\n<img id=\"e2-lazy\" load-url=\"/images/avatar.jpg\" />\n</template>\n\n<script>\nvar observer = new IntersectionObserver((entries,observer) => {\n  let entry = entries[0]\n  if (entry.isIntersecting) {\n    let el = entry.target;\n    el.src = el.getAttribute('load-url');\n    observer.disconnect();\n  }\n});\nobserver.observe(document.querySelector(\"#e2-lazy\"));\n</script>\n\n{% endpreview %}\n\n## TOC 自动定位\n\n见我博客（Cake与NexT主题）的侧边栏，它使用的就是IntersectionObserver。不过在使用时，也遇到了些问题。比如，IntersectionObserver 在浏览器中的优先级不高（高效，必然也有缺陷），如果你很快的移动，可能无法触发\n\n我们（NexT团队）第一次尝试时，并未考虑优先级的事情，我们根据标题元素的是否在浏览器窗口可见计算其toc的位置，但如果快速滑动，那么toc的定位就会错乱\n\n后续，我们调整，扩大根窗口的区域（与文章一样长）的方式，那么我们只需要判断是不是已经交叉即可，即便滑动太快也无需担心\n\n相关的代码可以见：\n- https://github.com/jiangtj/hexo-theme-cake/blob/9532ba695834a80bde883386efd2af8ffe6fe351/source/js/next-boot.js#L61-L134\n- https://github.com/theme-next/hexo-theme-next/blob/ba019030a1293c80536fcb16777cc05a94305118/source/js/utils.js#L222-L300\n- https://github.com/theme-next/hexo-theme-next/pull/1125\n\n## 评论系统懒加载\n\n由于国内网络不稳定（众所周知的原因），当我们要加载一些国外服务时，往往希望在需要时加载，以改善网站的加载速度。在博客中比较常见的是disqus，NexT团队将其扩展到所有的评论系统。实现当用户浏览到评论系统位置（或者多评论系统启用某一评论系统）时，加载相关评论系统服务\n\n相关的代码见：\n- https://github.com/jiangtj/hexo-theme-cake/pull/33\n","categories":["前端"],"tags":["Intersection Observer"]},{"title":"JDK12 新特性 switch expressions （预览）","url":"/articles/beechnut/jdk12-switch-expressions/","content":"\nswitch expressions 这个新特性蛮有意思的，在部分情况下能减少我们的代码量，尤其在工厂模式下，会很简单\n\n<!-- more -->\n\n例如，一个支付服务，我们通常的实现如下\n\n```java\n@Service\npublic interface PayService {\n    Result pay();\n}\n@Service\npublic class AliService implements PayService {\n    @Override\n    public Result pay() {\n        return Result.of(\"success\", \"Paying by Ali!\");\n    }\n}\n@Service\npublic class WechatService implements PayService {\n    @Override\n    public Result pay() {\n        return Result.of(\"success\", \"Paying by Wechat!\");\n    }\n}\n```\n\n抽象出支付对象，同时有多个实现，如果我们需要通过编号获取对应的支付服务实现，可以通过以下工厂获取\n\n```java\npublic PayService get(String no) {\n  switch (no) {\n    case \"wechat\": return wechatService;\n    case \"ali\": return aliService;\n    default: return null;\n  }\n}\n```\n\n改编成switch expressions，语法上会更简单，将会像下面一样\n\n```java\npublic PayService get(String no) {\n  return switch (no) {\n    case \"wechat\" -> wechatService;\n    case \"ali\" -> aliService;\n    default -> null;\n  };\n}\n```\n\n如果使用完整的代码块写的话，需要像下面那样编写\n\n```java\npublic PayService get(String no) {\n  return switch (no) {\n    case \"wechat\" -> wechatService;\n    case \"ali\" -> {\n      break aliService;\n    }\n    default -> null;\n  };\n}\n```\n\n加括号和break后返回值，预览的特性不是很稳定，上面的写法是jdk12，在jdk13中JEP 354取代JEP 325，对这部分进行的修改，添加了yield关键字进行返回，同时要求你使用switch expressions时，必须穷尽所有情况返回预期值以及不能有跳出switch的操作（return、continue等等）\n\n```java\npublic PayService get(String no) {\n  return switch (no) {\n    case \"wechat\" -> wechatService;\n    case \"ali\" -> {\n      yield aliService;\n    }\n    default:\n      yield null;\n  };\n}\n```\n\n> 毕竟是预览特性，十分不稳定，就目前来看，添加关键字为了一点点的简写，有点得不偿失吧\n\n[Example Source](https://github.com/jiangtj-lab/jdk12-switch-expressions)\n","categories":["后端"],"tags":["Java"]},{"title":"微服务设计笔记","url":"/articles/beechnut/microservices-note/","content":"\n一些重要的，有争议的点\n\n- 边界 - 《领域驱动设计》\n- 服务版本管理\n- 公用数据\n- 安全性\n- 报表\n"},{"title":"微服务设计 - 原则","url":"/articles/beechnut/microservices-principles/","content":"\n# 围绕业务概念建模\n> 原文：经验表明，围绕业务的限界上下文定义的接口，比围绕技术概念定义的接口更加稳定。针对系统如何工作这个领域进行建模，不仅可以帮助我们形成更稳定的接口，也能确保我们能够更好地反映业务流程的变化。使用限界上下文来定义可能的领域边界。\n\n这个原则关于微服务如何确认边界，主张以业务而非技术作为划分基准。缘由我有不同的理解。在互联网涉及的业务中，很大一部分都是原来有的，互联网使它更加简单。例如仓储系统，现实中仓储不是随着互联网的出现而发展的，它拥有悠久的例子，古代的粮仓也是呀。而我们设计服务最佳的方式，将现实中映射过来，当然也需要结合网络优点适当调整。\n\n<!-- more -->\n\n# 接受自动化文化\n> 原文：微服务引入了很多复杂性，其中的关键部分是，我们不得不管理大量的服务。解决这个问题的一个关键方法是，拥抱自动化文化。前期花费一定的成本，构建支持微服务的工具是很有意义的。自动化测试必不可少，因为相比单块系统，确保我们大量的服务能正常工作是一个更复杂的过程。调用一个统一的命令行，以相同的方式把系统部署到各个环境是一个很有用的实践，这也是采用持续交付对每次提交后的产品质量进行快速反馈的一个关键部分。    \n> \n> 请考虑使用环境定义来帮助你明确不同环境间的差异，但同时保持使用统一的方式进行部署的能力。考虑创建自定义镜像来加快部署，并且创建全自动化不可变服务器，这会更容易定位系统本身的问题。\n\n自动化是微服务基础之一，是很关键的部分，如果无法做到足够简单，那么迟早会迎来崩盘。\n\n# 隐藏内部实现细节\n> 原文：为了使一个服务独立于其他服务，最大化独自演化的能力，隐藏实现细节至关重要。限界上下文建模在这方面可以提供帮助，因为它可以帮助我们关注哪些模型应该共享，哪些应该隐藏。服务还应该隐藏它们的数据库，以避免陷入数据库耦合，这在传统的面向服务的架构中也是最常见的一种耦合类型。使用数据泵（data pump）或事件数据泵（event data pump），将跨多个服务的数据整合到一起，以实现报表的功能。    \n> \n> 在可能的情况下，尽量选择与技术无关的 API，这能让你自由地选择使用不同的技术栈。请考虑使用 REST，它将内部和外部的实现细节分离方式规范化，即使是使用 RPC，你仍然可以采用这些想法。\n\n一句话，除边界外，其它都独自完成。\n\n# 让一切都去中心化\n> 原文：为了最大化微服务能带来的自治性，我们需要持续寻找机会，给拥有服务的团队委派决策和控制权。在这个过程初期，只要有可能，就尝试使用资源自助服务，允许人们按需部署软件，使开发和测试尽可能简单，并且避免让独立的团队来做这些事。\n> \n> 在这个旅程中，确保团队保持对服务的所有权是重要的一步，理想情况下，甚至可以让团队自己决定什么时候让那些更改上线。使用内部开源模式，确保人们可以更改其他团队拥有的服务，不过请注意，实现这种模式需要很多的工作量。让团队与组织保持一致，从而使康威定律起作用，并帮助正在构建面向业务服务的团队，让他们成为其构建的业务领域的专家。一些全局的引导是必要的，尝试使用共同治理模型，使团队的每个成员共同对系统技术愿景的演化负责。\n> \n> 像企业服务总线或服务编配系统这样的方案，会导致业务逻辑的中心化和哑服务，应该避免使用它们。使用协同来代替编排或哑中间件，使用智能端点（smart endpoint）确保相关的逻辑和数据，在服务限界内能保持服务的内聚性。\n\n除了组织架构外，微服务设计也需要尽量避免中心出现。中心点一般而言，会成为未来性能的瓶颈点，比如在单体应用扩展常见的通过redis来session共享，如果将它应用在微服务中会怎样？但中心不可能完全避免，微服务本身的服务注册中心也是中心点之一，但它遇到瓶颈可能要成千上万微服务时，所以不是特别大的公司都可暂且不考虑。\n\n# 可独立部署\n> 原文：我们应当始终努力确保微服务可以独立部署。甚至当需要做不兼容更改时，我们也应该同时提供新旧两个版本，允许消费者慢慢迁移到新版本。这能够帮助我们加快新功能的发布速度。拥有这些微服务的团队，也能够越来越具有自治性，因为他们不需要在部署过程中不断地做编配。当使用基于 RPC 的集成时，避免使用像 Java RMI 提供的那种使用生成的桩代码，紧密绑定客户端 / 服务器的技术。\n> \n> 通过采用单服务单主机模式，可以减少部署一个服务引发的副作用，比如影响另一个完全不相干的服务。请考虑使用蓝 / 绿部署或金丝雀部署技术，区分部署和发布，降低发布出错的风险。使用消费者驱动的契约测试，在破坏性的更改发生前捕获它们。\n> \n> 请记住，你可以更改单个服务，然后把它部署到生产环境，无需联动地部署其他任何服务，这应该是常态，而不是例外。你的消费者应该自己决定何时更新，你需要适应他们\n\n没什么补充的。。。\n\n# 隔离失败\n> 原文：微服务架构能比单块架构更具弹性，前提是我们了解系统的故障模式，并做出相应的计划。如果我们不考虑调用下游可能会失败的事实，系统会遭受灾难性的级联故障，系统也会比以前更加脆弱。\n> \n> 当使用网络调用时，不要像使用本地调用那样处理远程调用，因为这样会隐藏不同的故障模式。所以确保使用的客户端库，没有对远程调用进行过度的抽象。\n> \n> 如果我们心中持有反脆弱的信条，预期在任何地方都会发生故障，这说明我们正走在正确的路上。请确保正确设置你的超时，了解何时及如何使用舱壁和断路器，来限制故障组件的连带影响。如果系统只有一部分行为不正常，要了解其对用户的影响。知道网络分区可能意味着什么，以及在特定情况下牺牲可用性或一致性是否是正确的决定。\n\n微服务相对于单体，故障的可能性更多，但也更加容易隔离。\n\n# 高度可观察\n> 原文：我们不能依靠观察单一服务实例，或一台服务器的行为，来看系统是否运行正常。相反，我们需要从整体上看待正在发生的事情。通过注入合成事务到你的系统，模拟真实用户的行为，从而使用语义监控来查看系统是否运行正常。聚合你的日志和数据，这样当你遇到问题时，就可以深入分析原因。而当需要重现令人讨厌的问题，或仅仅查看你的系统在生产环境是如何交互时，关联标识可以帮助你跟踪系统间的调用。\n\n日志、请求链路追踪等，为微服务保障护航。\n\n# 参考\n- 《微服务设计》 Sam Newman 著 崔力强 张俊 译\n\n这几点，说起来容易，但实施过程中，很容易走入误区，所以需要时刻谨记！\n","categories":["架构"],"tags":["微服务"]},{"title":"Git LFS使用--Netlify Large Media","url":"/articles/beechnut/netlify-lm/","content":"\n# 前言\nGit LFS一直都想尝试，但，GitHub上\n\n{% asset_img 1.png %}\n\n1G的存储，1G的带宽是，这量实在是。。。在2月26日，Netlify宣布了流量限制100G，也宣布新的功能，图像转换功能为流量限制做铺垫，以及这个转换功能所附带的大文件存储。一半伤心一半心动。虽然转换功能也有限制，2500次每月（同一次相同转换会缓存，只消耗1次次数），所以对于大部分中小型网站来说都够用了，当然100G的带宽，也是一样。\n\n作为转换功能基础的文件存储，则没提及，可能无限制吧。所以是时候升级啦。\n\n<!-- more -->\n\n# 为什么要使用LFS\n原因涉及到Git的底层原理，很多介绍上只说了会使存储库变的很大，所以要用LFS，但事实上二进制文件就是很大的，用了LFS，最后还不是得下一堆二进制文件。根本原因不是这个，而是Git的底层文件系统。Git的所有文件都存放在`.git\\objects`中，而修改是保存一个新的文件，而目录中以hash值引用，旧文件是不会被删除的，删除也是一样。所以整个`.git`文件夹会变得特别膨大。\n\nGit LFS能将二进制存储在别处，在Git中存储的只是标记文件，占用空间十分小。所以，当文件被删除后，空间占用也就少了，不会想原先那样，只增不减。\n\n# 如何使用\n这里使用Netlify Large Media做存储库。\n\n1. 安装netlify-cli，以及登录\n```bash\nnpm install netlify-cli -g\nnetlify login\n```\n2. 安装Large Media插件\n```bash\nnetlify plugins:install netlify-lm-plugin\nnetlify lm:install\n```\n3. 关联netlify实例，以及初始化Git LFS配置\n```bash\nnetlify link\nnetlify lm:setup\n```\n4. 添加需要Git LFS管理的文件\n```bash\ngit lfs track \"source/images/**\"\ngit lfs track \"*.jpg\"\n```\n5. 想正常一样操作Git即可\n```bash\ngit commit -m \"track\"\ngit push origin master\n```\n\n注意：在初次安装Large Media插件时，可能需要关掉命令终端，重新启动来加载脚本\n\n# 图像转换功能\n这是另一大激动人心的功能，能帮我们自动转换图片大小。可以省下我们很多事。或者说我们可以不再准备多套分辨率了，想调用api一样获得\n\n通过响应式懒加载库lazod.js实现了该功能，[过滤器](https://github.com/JiangTJ/hexo-theme-next/blob/neet/scripts/filters/lazyload.js)，但奇怪的地方是图片明明一样的，但在不同屏幕下，显示大小不同。所以我改为宽度100%作为默认方案。\n\n# 参考\n1. [Netlify Large Media Doc](https://www.netlify.com/docs/large-media/)\n","categories":["工具"],"tags":["Git"]},{"title":"npm 免密 publish","url":"/articles/beechnut/npm-publish-no-password/","content":"\n> 做个笔记，毕竟多台电脑，需要配置\n\n1. 创建token\n\n![](https://jiangtj-lab.github.io/pic-repo/img-apricot/20190927110154.png)\n\n![](https://jiangtj-lab.github.io/pic-repo/img-apricot/20190927110633.png)\n\n2. 添加.npmrc文件至用户目录下\n```\n//npm.pkg.github.com/:_authToken=*****************\n//registry.npmjs.org/:_authToken=*****************\n```\n","categories":["前端"],"tags":["NPM"]},{"title":"一个简单的retrofit工具类","url":"/articles/beechnut/retrofit-utils/","content":"\n# 使用\n\n```java\n// 同步返回Optional<T>\nvar repos = RetrofitUtils.execute(service.listRepos(\"octocat\")).orElse(new ArrayList<>());\n// 异步\nRetrofitUtils.execute(service.listRepos(\"octocat\"), repos -> {\n  //业务逻辑\n});\n```\n\n<!-- more -->\n\n# Gist\n\n<script src=\"https://gist.github.com/jiangtj/9ced3e62e8b5668a7e5a40b23a6f121d.js\"></script>\n\n- 如果无法查看，可到知乎查看：https://zhuanlan.zhihu.com/p/81420563\n- 需要安装lombok依赖，或者修改日志方法（log）\n","categories":["后端"],"tags":["Java","Retrofit"]},{"title":"Spring Cloud Contract DSL","url":"/articles/beechnut/spring-cloud-contract-dsl/","content":"\n这是一篇介绍Spring Cloud Contract语言定义的文章，也就是该怎么写契约内容。如果您对Spring Cloud Contract不是很了解，不知如何更好的实践的话，可以先看下我之前的文章[《Spring Cloud Contract 契约测试》](/articles/beechnut/spring-cloud-contract)\n\n在这个框架中，我们既可以采用Groovy，也可以yaml。但由于本身属于Java的框架，在支持上Groovy要更好些，推荐且这里只介绍Groovy（事实上，我对Spring官方同时支持两种定义方式并不理解，专注一种或许会更好啊）。\n\n> 该文章基于Spring Cloud Contract 2.1.0.GA\n\n<!-- more -->\n\n# 顶级元素\n首先，使用Groovy做契约脚本，必须使用`org.springframework.cloud.spec.Contract.make`，当然，也可以选择`import`，如下\n```groovy\npackage contracts\n\nimport org.springframework.cloud.contract.spec.Contract\n\n//定义单个契约\nContract.make {}\n\n//如果需要有多个存在一个文件中\n[\n    Contract.make {},\n    Contract.make {}\n]\n```\n\n这里将make{}中直接使用的方法或者属性成为顶级元素。在脚本中，不会特别区分方法还是属性的，所以用元素来代替。\n\n在Spring Cloud Contract中有以下几种顶级元素\n- name: 名称\n- description: 描述\n- ignored: 忽略\n- priority: 优先级\n- HTTP元素\n\n## Name\n在定义一个文件中多个契约时，默认会使用`-[index]`后缀来区分不同的契约，这样的测试用例可读性较差（不清楚哪个是做什么的）。当然，单个可能也会遇到文件名称无法表达的情况。所以我们需要通过`name()`来修改生成的测试用例名称，当然它也会同时修改`WireMock stub`（指契约mock时，所使用的json文件）名称。\n\n例如：\n```groovy\nContract.make {\n    name('第一个契约呀')\n}\n```\n\n结果：测试用例\n```java\n@Test\npublic void validate_第一个契约呀() throws Exception {}\n```\n\n结果：WireMock stub\n```\n第一个契约呀.json\n```\n\n> 你们不要用中文哦~\n\n## Description\n\n描述用途，或者在BDD中所需要描述的角色、想要、目的、场景、限制等等，可以写在这里。它不会生成到单元测试或者存根中，仅仅做记录而已。但，请看下面的例子：\n```groovy\nContract.make {\n    description(\"\"\"\n        [运营]需要[去掉操作A]，目的是[减少流程与人工成本]，存在的问题[减少A操作，会使部分数据未记录（运营人员已知晓（见邮件‘邮件主题’））]\n    \"\"\")\n}\n```\n\n然而某天，由于缺少A操作的记录，导致部分问题无法解决，他们会“趾高气扬”的责备，这程序设计的怎么怎么烂。但如果有这段描述，你就淡定了，喝杯咖啡，查下邮件，转发某某，抄送领导A、领导B。。。（这样的事在业务驱动的公司十分常见）\n\n## Ignored\n如果你不希望生成某个契约，你可以在插件`<configuration><includedFiles>`中忽略或者在契约内添加`ignored()`\n```groovy\nContract.make {\n    ignored()\n}\n```\n\n## Priority\n有时我们会定义相似的契约，比如当调用接口`/user/{id}`，id为10时失败，其它都成功。那么我们需要为id为10设置更高的优先级\n```groovy\n//url与urlPath稍后讲，一个指定值，一个进行正则匹配\nContract.make {\n    request {\n        url \"/user/10\"\n        //...\n    }\n    priority(1)\n}\nContract.make {\n    request {\n        urlPath($(c(regex('^/user/.+')),p(1)))\n        //...\n    }\n    priority(2)\n}\n```\n\n## HTTP元素\n\n除了上面的，还包含HTTP元素，即request、response。这两个元素是契约最重要的组成部分，必不可少。在官方文档中priority算在了这里，但我更倾向于分开（我们常说的HTTP请求有优先级？）\n\nhttp是十分重要的，所以放在单独的两章中\n\n# Request\n\n一个HTTP Request一般情况由method、url、header、requestBody这几部分组成，HTTP协议中method、url是强制的，同样的在契约里也属于必须提供的内容\n\n## Method\n在Request设置Method属性\n```groovy\nContract.make {\n    request {\n        method 'PUT'\n    }\n}\n```\n\n## Url\n\n最简单设置url的方式是，直接设置url属性\n```groovy\nContract.make {\n    request {\n        url '/user/10'\n    }\n}\n```\n\n或者你可以使用urlPath，一个Path组件来定义url\n```groovy\nContract.make {\n    request {\n        urlPath('/users') {\n            queryParameters {\n                parameter 'limit': 100\n                parameter 'filter': equalTo(\"email\")\n                parameter 'gender': value(consumer(containing(\"[mf]\")), producer('mf'))\n                parameter 'offset': value(consumer(matching(\"[0-9]+\")), producer(123))\n                parameter 'loginStartsWith': value(consumer(notMatching(\".{0,2}\")), producer(3))\n                parameter 'uuid': $(anyUuid())\n            }\n        }\n    }\n}\n```\n\nurlPath分为两部分，本身的路径以及参数。路径可以是正则（前面的例子）也可以是想url里那样的普通字符串。\n\n另一部分`queryParameters`是`？`后面的参数，其中简单的，如`'limit': 100`与`'filter': equalTo(\"email\")`是一样的，只是写法不同，表示值相等的情况。另外就涉及的动态参数。\n\n### 动态参数\n\n除了`equalTo`我们还看到了`value()``$()`，这是Spring Cloud Contract另一大特性，动态参数。可以试想一下如果我们调用的参数是指定，那么会怎样呢？\n\n首先，我们无法保证调用方是一个还是多个，假如一个业务需要模拟多用户调用，那么我们需要mock不同参数的数据。在指定参数的情况下意味着我们需要多份契约，以便消费方调用。这显然不合理，多份契约是冗余的，没有启到任何作用，而且每次的修改，需要同时修改多个地方。\n\n所以，我们应当接受任意我们所能接受的数据，并返回预期结果，以方便消费者也可以根据其业务定制他的参数。\n\n在动态参数中，有些写法不同，但实际是一样的，比如：\n```js\nvalue() = $()\nconsumer(...) = c(...) = stub(...) = client(...)\nproducer(...) = p(...) = test(...) = server(...)\n```\n\n在动态属性中，基本的结构是`$(consumer(...),producer(...))`。consumer定义接受的参数，或者消费方的定义。producer表示验证的数据，提供方验证用的数据，也就是单元测试中用到的数据\n\nconsumer一般都多种匹配方式，`containing`包含，`matching`正则匹配，`notMatching`正则不匹配。\n\n其中正则匹配，Spring Cloud Contract内置了一些正则表达式，可以直接使用\n```groovy\nprotected static final Pattern TRUE_OR_FALSE = Pattern.compile(/(true|false)/)\nprotected static final Pattern ALPHA_NUMERIC = Pattern.compile('[a-zA-Z0-9]+')\nprotected static final Pattern ONLY_ALPHA_UNICODE = Pattern.compile(/[\\p{L}]*/)\nprotected static final Pattern NUMBER = Pattern.compile('-?(\\\\d*\\\\.\\\\d+|\\\\d+)')\nprotected static final Pattern INTEGER = Pattern.compile('-?(\\\\d+)')\nprotected static final Pattern POSITIVE_INT = Pattern.compile('([1-9]\\\\d*)')\nprotected static final Pattern DOUBLE = Pattern.compile('-?(\\\\d*\\\\.\\\\d+)')\nprotected static final Pattern HEX = Pattern.compile('[a-fA-F0-9]+')\nprotected static final Pattern IP_ADDRESS = Pattern.\n\t\tcompile('([01]?\\\\d\\\\d?|2[0-4]\\\\d|25[0-5])\\\\.([01]?\\\\d\\\\d?|2[0-4]\\\\d|25[0-5])\\\\.([01]?\\\\d\\\\d?|2[0-4]\\\\d|25[0-5])\\\\.([01]?\\\\d\\\\d?|2[0-4]\\\\d|25[0-5])')\nprotected static final Pattern HOSTNAME_PATTERN = Pattern.\n\t\tcompile('((http[s]?|ftp):/)/?([^:/\\\\s]+)(:[0-9]{1,5})?')\nprotected static final Pattern EMAIL = Pattern.\n\t\tcompile('[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\\\.[a-zA-Z]{2,6}')\nprotected static final Pattern URL = UrlHelper.URL\nprotected static final Pattern HTTPS_URL = UrlHelper.HTTPS_URL\nprotected static final Pattern UUID = Pattern.\n\t\tcompile('[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}')\nprotected static final Pattern ANY_DATE = Pattern.\n\t\tcompile('(\\\\d\\\\d\\\\d\\\\d)-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])')\nprotected static final Pattern ANY_DATE_TIME = Pattern.\n\t\tcompile('([0-9]{4})-(1[0-2]|0[1-9])-(3[01]|0[1-9]|[12][0-9])T(2[0-3]|[01][0-9]):([0-5][0-9]):([0-5][0-9])')\nprotected static final Pattern ANY_TIME = Pattern.\n\t\tcompile('(2[0-3]|[01][0-9]):([0-5][0-9]):([0-5][0-9])')\nprotected static final Pattern NON_EMPTY = Pattern.compile(/[\\S\\s]+/)\nprotected static final Pattern NON_BLANK = Pattern.compile(/^\\s*\\S[\\S\\s]*/)\nprotected static final Pattern ISO8601_WITH_OFFSET = Pattern.\n\t\tcompile(/([0-9]{4})-(1[0-2]|0[1-9])-(3[01]|0[1-9]|[12][0-9])T(2[0-3]|[01][0-9]):([0-5][0-9]):([0-5][0-9])(\\.\\d{3})?(Z|[+-][01]\\d:[0-5]\\d)/)\n\nprotected static Pattern anyOf(String... values) {\n\treturn Pattern.compile(values.collect({ \"^$it\\$\" }).join(\"|\"))\n}\n\nRegexProperty onlyAlphaUnicode() {\n\treturn new RegexProperty(ONLY_ALPHA_UNICODE).asString()\n}\n\nRegexProperty alphaNumeric() {\n\treturn new RegexProperty(ALPHA_NUMERIC).asString()\n}\n\nRegexProperty number() {\n\treturn new RegexProperty(NUMBER).asDouble()\n}\n\nRegexProperty positiveInt() {\n\treturn new RegexProperty(POSITIVE_INT).asInteger()\n}\n\nRegexProperty anyBoolean() {\n\treturn new RegexProperty(TRUE_OR_FALSE).asBooleanType()\n}\n\nRegexProperty anInteger() {\n\treturn new RegexProperty(INTEGER).asInteger()\n}\n\nRegexProperty aDouble() {\n\treturn new RegexProperty(DOUBLE).asDouble()\n}\n\nRegexProperty ipAddress() {\n\treturn new RegexProperty(IP_ADDRESS).asString()\n}\n\nRegexProperty hostname() {\n\treturn new RegexProperty(HOSTNAME_PATTERN).asString()\n}\n\nRegexProperty email() {\n\treturn new RegexProperty(EMAIL).asString()\n}\n\nRegexProperty url() {\n\treturn new RegexProperty(URL).asString()\n}\n\nRegexProperty httpsUrl() {\n\treturn new RegexProperty(HTTPS_URL).asString()\n}\n\nRegexProperty uuid() {\n\treturn new RegexProperty(UUID).asString()\n}\n\nRegexProperty isoDate() {\n\treturn new RegexProperty(ANY_DATE).asString()\n}\n\nRegexProperty isoDateTime() {\n\treturn new RegexProperty(ANY_DATE_TIME).asString()\n}\n\nRegexProperty isoTime() {\n\treturn new RegexProperty(ANY_TIME).asString()\n}\n\nRegexProperty iso8601WithOffset() {\n\treturn new RegexProperty(ISO8601_WITH_OFFSET).asString()\n}\n\nRegexProperty nonEmpty() {\n\treturn new RegexProperty(NON_EMPTY).asString()\n}\n\nRegexProperty nonBlank() {\n\treturn new RegexProperty(NON_BLANK).asString()\n}\n```\n\n还有，如果你觉得`value(consumer(number()), producer(\"1\"))`有点麻烦的话，这个框架还提供了一种简便写法，`anyNumber()`。任何一个`any*`都代表一个正则，如果使用这个简便写法，在producer不提供的情况下，会随机生成一个符合的参数，用于接口测试。\n```js\nvalue(anyNumber()) = value(consumer(number()), producer(\"一个随机的数字\"))\nvalue(anyNumber(), producer(\"1\")) = value(consumer(number()), producer(\"1\"))\n```\n\n## Header\n\n用于匹配Request头部是否符合规范\n```groovy\nContract.make {\n    request {\n        headers {\n            header('contentType': 'application/json')\n            //在groovy中可以使用内置的函数代替如下面\n            //contentType(applicationJsonUtf8())\n        }\n    }\n}\n```\n\n## Body\n当method为PUT或者POST时，依据http协议，我们可以将数据放在body中。\n```groovy\nContract.make {\n    request {\n        headers {\n            contentType(applicationJson())\n        }\n        body([\n                name: value(anyNonEmptyString(), producer(\"从入门到弃坑\")),\n                price: value(anyNumber(), producer(\"1\"))\n        ])\n    }\n}\n```\n\n根据contentType不同，它会自动转换至Json或者FormParam。body的值也能设置动态参数，参考上文。除此之外，body还支持bodyMatchers，我们可以提供body样例，在外部提供匹配规则\n```groovy\nContract.make {\n    request {\n        headers {\n            contentType(applicationJson())\n        }\n        body ([\n            \"name\":\"YaYaYa\"\n        ])\n        bodyMatchers {\n            jsonPath('$.name', byRegex(nonBlank()))\n        }\n    }\n}\n```\n\n通过`$.[path]`获取json位置，通过`by*`定义匹配规则\n\n> 但需要特别注意：动态参数目前还不支持FormParam。如果存在FormParam，改用QueryParam传参（反正一样的）。    \n参考：[spring-cloud-contract#112](https://github.com/spring-cloud/spring-cloud-contract/issues/112)与[wiremock#383](https://github.com/tomakehurst/wiremock/issues/383)\n\n\n\n# Response\n\nresponse与request存在一些共通点，比如`header` `body`等，这些写法上与Request中是一致的，可以参考上文\n\n## Status\n\n`status code`是响应独有的，而且是必须的一项\n```groovy\nContract.make {\n    response {\n        status OK()\n    }\n}\n```\n\n## FromReques\n\n某些情况下，我们可能需要返回request中的值。比如添加一个用户，成功时，我们应当返回该用户在后端实际存储的信息给前端。所以我们需要调用`fromReques()`获取数据\n```groovy\nContract.make {\n    response {\n        body([\n                \"gender\": fromRequest().query('gender'),\n                \"name\": fromRequest().body('$.name')\n        ])\n    }\n}\n```\n`fromRequest()`有以下一些方法：\n- fromRequest().url(): 返回URL与query parameters.\n- fromRequest().query(String key): 返回第一个匹配到的query parameter值.\n- fromRequest().query(String key, int index): 返回第[index]个匹配到的query parameter值.\n- fromRequest().path(): 返回完整的url路径.\n- fromRequest().path(int index): 返回第[index]个url路径元素.\n- fromRequest().header(String key):返回第一个匹配到的header值.\n- fromRequest().header(String key, int index): 返回第[index]个匹配到的header值.\n- fromRequest().body(): 返回完整的body.\n- fromRequest().body(String jsonPath): 返回body中指定JSON路径的元素.\n\n## Body\n\n在Response中，我们可以使用其他的写法给body赋值，比如`\"\"\"`添加字符串\n```groovy\nContract.make {\n    response {\n        body \"\"\"{\"name\":\"YaYaYa\"}\"\"\"\n    }\n}\n```\n\n又或者我们可以将它放在外部（如果样例非常大时，是个不错的方案）\n```groovy\nContract.make {\n    response {\n        body (file('文件的相对路径，例如xxxx.json'))\n    }\n}\n```\n\n> 这块内容在Request中也是可用的，但如果与动态属性结合会出错，可能是[issue](https://github.com/spring-cloud/spring-cloud-contract/issues/1065)吧。所以尽量不要在Request中使用这块内容。\n\n# 一个比较完整示例\n在最后，给个比较完整的例子，将就着看吧~~\n```groovy\npackage contracts\n\nimport org.springframework.cloud.contract.spec.Contract\n\nContract.make {\n    priority(1)\n    name('第一个契约呀')\n    description(\"\"\"\n        [运营]需要[去掉操作A]，目的是[减少流程与人工成本]，存在的问题[减少A操作，会使部分数据未记录（运营人员已知晓（见邮件‘邮件主题’））]\n    \"\"\")\n    request {\n        method 'PUT'\n        urlPath($(c(regex('^/user/.+')),p('/user/1'))) {\n            queryParameters {\n                parameter 'limit': 100\n                parameter 'filter': equalTo(\"email\")\n                parameter 'gender': value(consumer(containing(\"[mf]\")), producer('mf'))\n                parameter 'offset': value(consumer(matching(\"[0-9]+\")), producer(123))\n                parameter 'loginStartsWith': value(consumer(notMatching(\".{0,2}\")), producer(3))\n                parameter 'uuid': $(anyUuid())\n            }\n        }\n        headers {\n            contentType(applicationJson())\n        }\n        body([\n                name: value(anyNonEmptyString(), producer(\"从入门到弃坑\")),\n                price: value(anyNumber(), producer(\"1\"))\n        ])\n    }\n    response {\n        status OK()\n        body([\n                \"gender\": fromRequest().query('gender'),\n                \"name\": fromRequest().body('$.name')\n        ])\n        headers {\n            contentType(applicationJsonUtf8())\n        }\n    }\n}\n```\n\n","categories":["后端"],"tags":["Spring Cloud","微服务"]},{"title":"Spring Cloud Contract 契约测试","url":"/articles/beechnut/spring-cloud-contract/","content":"\nSpring Cloud Contract是契约测试的一个实现，最早看到契约测试还是在《微服务设计》书中，不过那时候绝对想不到真的会接触它。\n\n# 什么是契约测试？\n\n首先，先谈谈思想，什么是契约测试？事实上在很多地方都称为消费者驱动契约(CDC) ，似乎都喜欢加驱动，比如TDD测试驱动等，但我不喜欢在这里加，契约是由提供者与消费者共同制定的，不可能由一方驱动。而契约测试也将同时作用于两方：\n- 验证提供方是否履约\n- 验证消费方在提供方履约下是否正常工作\n\n由于一般都只考虑提供方的履约验证，所以误解为消费者驱动。事实呢，提供方与消费方是唯一的么？你的契约不会变么？一旦发生改变，那么契约测试也会对消费方进行验证。\n\n<!-- more -->\n\n# 为什么要使用\n随着服务拆分，服务间的调用变得更加频繁。原本的测试方案（单元测试与集成测试）变得力不从心\n\n单元测试，我们会mock服务间的调用，确保我们对很小的原本测试。但是，一旦提供方提供的服务发生改变，这不会及时的响应在单元测试中，这种疏漏会导致单元测试失效。\n\n集成测试，每次我们都需要运行多个服务，以配合完成。其中涉及到服务的配置等等各种问题。\n\n这就好比是场舞台戏，如果每个人都练自己的，那么很可能配合失败。如果一直一起排练，又很占时间。所以需要一份实时都是最新的剧本，每个人都依据它，练习自己的部分。\n\n# 实现\nSpring Cloud Contract 提供不错的实现，它分为验证服务（Verifier）和对契约内容Mock服务（Stub Runner）两部分。\n\n## Verifier\n通过groovy脚本或者yaml定义接口，由Spring Cloud Contract帮助我们生成测试用例并验证。\n\n**Step 1：环境配置**\n\n需要引入依赖\n```xml\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-contract-verifier</artifactId>\n            <scope>test</scope>\n        </dependency>\n        <plugins>\n            <plugin>\n                <groupId>org.springframework.cloud</groupId>\n                <artifactId>spring-cloud-contract-maven-plugin</artifactId>\n                <extensions>true</extensions>\n                <configuration>\n                    <baseClassMappings>\n                        <baseClassMapping>\n                            <contractPackageRegex>.*</contractPackageRegex>\n                            <baseClassFQN>com.jtj.cloud.springcontractexample.AbstractDnocmTest</baseClassFQN>\n                        </baseClassMapping>\n                    </baseClassMappings>\n                </configuration>\n            </plugin>\n        </plugins>\n```\n\n其中插件的baseClassFQN配置是，为了让生成的类继承指定类。\n\n需要配置web容器\n\n```java\n@RunWith(SpringRunner.class)\n@SpringBootTest(\n        classes = SpringContractExampleApplication.class,\n        webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT\n)\n@AutoConfigureMockMvc\npublic abstract class AbstractDnocmTest {\n\n    @Autowired\n    private WebApplicationContext context;\n\n    @Before\n    public void setup(){\n        RestAssuredMockMvc.webAppContextSetup(context);\n    }\n\n}\n```\n\n注意：webflux没有WebApplicationContext，所以目前只能配Controller\n\n**Step 2：编写契约，可以使用groovy，也可以yaml**\n\n```groovy\npackage contracts\n\nimport org.springframework.cloud.contract.spec.Contract\n\nContract.make {\n  request {\n    method 'GET'\n    urlPath('/groovy') {\n      queryParameters {\n        parameter \"name\": value(consumer(regex(nonEmpty())), producer(\"从入门到弃坑\"))\n      }\n    }\n  }\n  response {\n    status OK()\n    body([\n            \"name\": fromRequest().query(\"name\"),\n            \"price\": 1000\n    ])\n    headers {\n      contentType('application/json;charset=UTF-8')\n    }\n  }\n}\n```\n\n```yml\nrequest:\n  method: GET\n  url: /yaml\n  queryParameters:\n    name: \"从入库到精通\"\n    price: 666\n  matchers:\n    url:\n    queryParameters:\n      - {key: name, type: matching, value: \"[\\\\S\\\\s]+\"}\n      - {key: price, type: matching, value: '^[0-9]{1,}$'}\nresponse:\n  status: 200\n  body:\n    name: \"{{{ request.query.name.[0] }}}\"\n    price: \"{{{ request.query.price.[0] }}}\"\n  headers:\n    Content-Type: application/json;charset=UTF-8\n```\n\n注意：matchers的queryParameters部分貌似没有效果（按照文档，照理说没问题的唉），yaml可读性较强，但相对来说自定义较差，如果可能尽可能选择groovy\n\n**Step 3：运行**\n\n1. 使用命令`mvn spring-cloud-contract:generateTests`生成测试用例（在target\\generated-test-sources\\contracts目录下），并执行单条测试\n2. 运行`mvn test`会生成并执行所有测试用例\n\n**Step 4：发布**\n\n时效性对于契约来说十分重要，若无法保证，那单元测试中的问题就等于没解决，所以需要及时的发布生成的-stubs jar包\n\n1. 配置nexus oss，并发布至上面，与一般的上传一致`mvn deploy`，在例子，我使用的是[jfrog bintray](https://bintray.com/jiangtj/maven)发布\n2. 如果没有二进制存储库，可以选择Git进行发布\n3. 还可以通过Pack，但是，在pack上需要先由前端定义好契约\n\n三个方案各有优缺点：\n\n第一个方案，利用maven来处理是非常合理的，maven本身就是用于二进制文件管理，但如果你无法做到独立升级部署（多个微服务一同修改），那么你可能需要依赖于SNAPSHOT jar，不稳定的版本需要你多次上传，而且maven的快照机制也造成每次都需要检测获取最新版本\n\n第二个方案，对于契约的存储独立存放在git仓库，它的工作原理是clone整个存储库至本地，解析版本以及一些其他的定义，获取契约数据。问题在于clone，本身契约内容是不多的，也就是clone并不会浪费太多时间。但假如多年后呢，如果契约定义不规范频繁改动的情况出现（在企业内，这是很常见的现象），可能造成存储库变得庞大\n\n第三个方案，这是有别于前两个，由消费方定义契约。所以使用场景也更加明确，那就是前端人员充足时。Pact提供了图形化的界面展示契约的验证情况，这是挺好的特性。但是对于后端微服务来说，提供契约需要通过其它方式（未很好的集成），这无疑造成了学习成本增加\n\n## Stub Runner\n由于服务提供方对契约是校验的，所以我们可以认为这个mock数据是基本准确的。mock方式有多种\n\n方案一：下载提供方源码，编译并运行`mvn spring-cloud-contract:convert && mvn spring-cloud-contract:run`\n\n方案二：在单元测试中使用，可以配合spring cloud替换一些注册中心的服务，在运行时，不再需要启动多个外部服务\n\n方案三：独立部署契约进行mock，一个很好的前后端分离方案是，前端依据契约mock数据开发，后端依据契约校验提供数据\n\n方案四：使用spring cloud cli运行，\n安装spring boot cli[文档](https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#getting-started-installing-the-cli)，\n安装spring cloud cli（待再次实践 按文档教程操作失败路过）\n\n### 单元测试\n\n需要的依赖\n```xml\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-contract-stub-runner</artifactId>\n            <scope>test</scope>\n        </dependency>\n```\n\n需要添加自动配置注解\n```\n@AutoConfigureStubRunner\n```\n\n没然后了，接下来都是些契约配置\n```yml\n# 关闭为了能替换ribbon服务\neureka:\n  client:\n    enabled: false\nstubrunner:\n  ids:\n    # - [groupId]:artifactId:[version]:[classify]:[port]\n    - com.jtj.cloud:spring-contract-example:1.0.0\n  ids-to-service-ids:\n    # 映射服务\n    spring-contract-example: none-service\n  # 该模式下会从远程maven仓库缓存到本地\n  stubs-mode: local\n```\n\n### 独立部署\n\n首先下载`stub-runner.jar` \n```bash\nwget -O stub-runner.jar 'https://search.maven.org/remotecontent?filepath=org/springframework/cloud/spring-cloud-contract-stub-runner-boot/2.1.1.RELEASE/spring-cloud-contract-stub-runner-boot-2.1.1.RELEASE.jar'\n```\n\n在同路径创建配置文件`application.yml`，并添加stubrunner的配置，如下\n```yml\nstubrunner:\n  ids:\n    # - [groupId]:artifactId:[version]:[classify]:[port]\n    # 指定运行在8081端口\n    - com.jtj.cloud:spring-contract-example:1.0.0:+:8081\n  # 该模式下会从远程maven仓库缓存到本地\n  stubs-mode: local\n```\n\n通过`java -jar stub-runner.jar`运行。即可访问`com.jtj.cloud:spring-contract-example`的mock数据啦！\n\n# 参考\n- [上面所提到的例子工程-mockmvc](https://github.com/JiangTJ/spring-contract-example)\n- [上面所提到的例子工程-webflux](https://github.com/JiangTJ/spring-contract-example/tree/webflux)\n- [spring-cloud-contract doc](https://cloud.spring.io/spring-cloud-static/spring-cloud-contract/2.1.0.RELEASE/single/spring-cloud-contract.html)\n\n","categories":["后端"],"tags":["Spring Cloud","微服务"]},{"title":"Spring Cloud 之 Gateway （Greenwich版）","url":"/articles/beechnut/spring-cloud-gateway/","content":"\n众所周知，netflix OSS 2.0 难产了，上一代的zuul网关虽说不错，但其并不是异步的。所以，Spring团队推出了基于Spring Webflux的全新异步的网关--Spring Cloud Gateway。\n\n> 本文内容基于Spring Cloud Gateway 2.1.0.GA\n\n来跟着我一步步，探索它的~~魅力~~坑吧！\n\n<!-- more -->\n\n# 环境搭建\n\n与所有的微服务组件一样，demo总是很简单的，如果你要启用，创建时勾上相关依赖即可。\n\n就像这样：\n```xml\n<dependencies>\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-gateway</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-netflix-hystrix</artifactId>\n        </dependency>\n\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-configuration-processor</artifactId>\n            <optional>true</optional>\n        </dependency>\n        <dependency>\n            <groupId>org.projectlombok</groupId>\n            <artifactId>lombok</artifactId>\n            <optional>true</optional>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n    </dependencies>\n```\n其中`lombok`是我的习惯，你可以选择不添加。\n\n启动类修改为`@SpringCloudApplication`。\n```java\n@SpringCloudApplication\npublic class SpringCloudGatewayApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(SpringCloudGatewayApplication.class, args);\n    }\n}\n```\n\n添加些简单配置（一个路由），跳转到我的博客，直接填写了url。由于只涉及网关，所以我把不必要的eureka关了，但实际开发中需要使用它，并添加ribbon路由`lb://<service-name>`\n```yml\nspring:\n  cloud:\n    gateway:\n      routes:\n        - id: app\n          uri: http://www.dnocm.com\n          # lb: Ribbon\n          # uri: lb://app-name\n          predicates:\n            - Path=/app/**\n          filters:\n            # Strip first path，such base\n            - StripPrefix=1\n            # - RewritePath=/base/,/\neureka:\n  client:\n    enabled: false\n```\n\n就此完成，启动运行。当你访问`localhost:8080/app/**`路由时，都会调整至`www.dnocm.com/**`。这是因为我设置了`http`一律`302`跳转至`https`。所以，这证明我们的网关搭建完成啦！！\n\n# Route Predicate Factory\nid uri顾名思义，不多说，但predicates是什么呢？predicates做动词有`使基于; 使以…为依据; 表明; 阐明; 断言;`的意思，简单说，用于表明在那种条件下，该路由配置生效。\n\n官方提供给我了许多的predicates\n```yml\nspring:\n  cloud:\n    gateway:\n      routes:\n      - id: example\n        uri: http://example.org\n        predicates:\n        # 匹配在什么时间之后的\n        - After=2017-01-20T17:42:47.789-07:00[America/Denver]\n        # 匹配在什么时间之前的\n        - Before=2017-01-20T17:42:47.789-07:00[America/Denver]\n        # 匹配在某段时间的\n        - Between=2017-01-20T17:42:47.789-07:00[America/Denver], 2017-01-21T17:42:47.789-07:00[America/Denver]\n        # 匹配cookie名称为`chocolate`的值要符合`ch.p`正则.\n        - Cookie=chocolate, ch.p\n        # 匹配header为`X-Request-Id`的值要符合`\\d+`正则.\n        - Header=X-Request-Id, \\d+\n        # 匹配任意符合`**.somehost.org`与`**.anotherhost.org`正则的网址\n        - Host=**.somehost.org,**.anotherhost.org\n        # Host还支持模版变量，会保存在`ServerWebExchange.getAttributes()`的 ServerWebExchangeUtils.URI_TEMPLATE_VARIABLES_ATTRIBUTE中，以Map形式存储\n        - Host={sub}.myhost.org\n        # 匹配GET方法\n        - Method=GET\n        # 路径匹配，与Host一样支持模版变量，存在URI_TEMPLATE_VARIABLES_ATTRIBUTE中。\n        - Path=/foo/{segment},/bar/{segment}\n        # 匹配存在baz查询参数\n        - Query=baz\n        # 匹配存在foo且符合`ba.`正则\n        - Query=foo, ba.\n        # 匹配远程地址\n        - RemoteAddr=192.168.1.1/24\n```\n\n官方几乎提供了我们所需的全部功能，这点值得鼓掌👏，然而假如遇到无法满足的情况呢？我们翻阅文档，发现自定义部分是大写的`TBD`待定ヾ(｡｀Д´｡)。\n\n那么怎么办呢？我们从官方的Predicate Factory看起，去学习。\n\n挑个简单的`HeaderRoutePredicateFactory`\n\n```java\npublic class HeaderRoutePredicateFactory extends AbstractRoutePredicateFactory<HeaderRoutePredicateFactory.Config> {\n\n  public static final String HEADER_KEY = \"header\";\n  public static final String REGEXP_KEY = \"regexp\";\n\n  public HeaderRoutePredicateFactory() {\n    super(Config.class);\n  }\n\n  @Override\n  public List<String> shortcutFieldOrder() {\n    return Arrays.asList(HEADER_KEY, REGEXP_KEY);\n  }\n\n  @Override\n  public Predicate<ServerWebExchange> apply(Config config) {\n    boolean hasRegex = !StringUtils.isEmpty(config.regexp);\n\n    return exchange -> {\n      List<String> values = exchange.getRequest().getHeaders()\n          .getOrDefault(config.header, Collections.emptyList());\n      if (values.isEmpty()) {\n        return false;\n      }\n      // values is now guaranteed to not be empty\n      if (hasRegex) {\n        // check if a header value matches\n        return values.stream().anyMatch(value -> value.matches(config.regexp));\n      }\n\n      // there is a value and since regexp is empty, we only check existence.\n      return true;\n    };\n  }\n\n  @Validated\n  public static class Config {\n\n    @NotEmpty\n    private String header;\n\n    private String regexp;\n\n    public String getHeader() {\n      return header;\n    }\n\n    public Config setHeader(String header) {\n      this.header = header;\n      return this;\n    }\n\n    public String getRegexp() {\n      return regexp;\n    }\n\n    public Config setRegexp(String regexp) {\n      this.regexp = regexp;\n      return this;\n    }\n\n  }\n\n}\n```\n上面的例子，我们可以看出\n- HeaderRoutePredicateFactory的构造方式与继承类视乎是固定的，目的是传递配置类\n- 需要实现`Predicate<ServerWebExchange> apply(Consumer<C> consumer)`\n- shortcutFieldOrder()似乎是为了配置值与配置类属性对应的\n- 需要定义接受的配置类\n- 查看继承可以发现，它通过`NameUtils.normalizeRoutePredicateName(this.getClass())`来获取配置文件中的名称\n\nOkay，验证上面的内容，我们重新编写一个`NonHeaderRoutePredicateFactory`，与head取反。同时配置类属性的交换位置。\n```java\npublic class NonHeaderRoutePredicateFactory extends AbstractRoutePredicateFactory<NonHeaderRoutePredicateFactory.Config> {\n\n  public static final String HEADER_KEY = \"header\";\n  public static final String REGEXP_KEY = \"regexp\";\n\n  public NonHeaderRoutePredicateFactory() {\n    super(Config.class);\n  }\n  @Override\n  public List<String> shortcutFieldOrder() {\n    return Arrays.asList(HEADER_KEY, REGEXP_KEY);\n  }\n  @Override\n  public Predicate<ServerWebExchange> apply(Config config) {\n    boolean hasRegex = !StringUtils.isEmpty(config.regexp);\n    return exchange -> {\n      List<String> values = exchange.getRequest().getHeaders().getOrDefault(config.header, Collections.emptyList());\n      if (values.isEmpty()) {\n        return true;\n      }\n      if (hasRegex) {\n        return values.stream().noneMatch(value -> value.matches(config.regexp));\n      }\n      return false;\n    };\n  }\n  @Data\n  @Validated\n  public static class Config {\n    private String regexp;\n    @NotEmpty\n    private String header;\n  }\n}\n```\n\n配置添加`- NonHeader=tt`，当存在`tt`header时 `404 ERROR`，不存在时，正常访问。符合推测！\n\n# GatewayFilter Factory\n\n除此predicates外，还有filter，用于过滤请求。与predicates一样，Spring官方也提供了需要内置的过滤器。过滤器部分相对于predicates来说难得多，有全局的也有可配置的。甚至一些过滤器不支持通过配置文件来修改。\n\n```yml\nspring:\n  cloud:\n    gateway:\n      routes:\n      - id: example\n        uri: http://example.org\n        filters:\n          # 先介绍简单的路由器\n          # 对header的操作（添加，删除，设置），以及保留原始host的header\n          - AddRequestHeader=X-Request-Foo, Bar\n          - AddResponseHeader=X-Response-Foo, Bar\n          - RemoveRequestHeader=X-Request-Foo\n          - RemoveResponseHeader=X-Response-Foo\n          - RewriteResponseHeader=X-Response-Foo, , password=[^&]+, password=***\n          - SetResponseHeader=X-Response-Foo, Bar\n          - PreserveHostHeader\n          # 对查询参数的过滤\n          - AddRequestParameter=foo, bar\n          # 对Uri的过滤（path与status）\n          - PrefixPath=/mypath\n          - RewritePath=/foo/(?<segment>.*), /$\\{segment}\n          - SetPath=/{segment}\n          - StripPrefix=2\n          - SetStatus=BAD_REQUEST\n          - SetStatus=401\n          - RedirectTo=302, http://acme.org\n          # 保留session，默认情况下是不保留的\n          - SaveSession\n          # 设置最大请求数据大小，这里发现一种新写法，理论上predicates中也能使用\n          - name: RequestSize\n            args:\n              maxSize: 5000000\n          # 重试次数设置\n          - name: Retry\n            args:\n              retries: 3\n              statuses: BAD_GATEWAY\n        \n          # 断路器的配置\n          # 断路器的配置比较复杂，首先指定断路器命令名即可启用断路器（这块我也不熟，需要HystrixCommand的内容）\n          - Hystrix=myCommandName\n          # 另外我们可以设置些错误发生后的跳转，当然现在仅支持forward:\n          - name: Hystrix\n            args:\n              name: fallbackcmd\n              fallbackUri: forward:/incaseoffailureusethis\n          # 我们还可以修改错误信息放置的header\n          - name: FallbackHeaders\n            args:\n              executionExceptionTypeHeaderName: Test-Header\n              executionExceptionMessageHeaderName: Test-Header\n              rootCauseExceptionTypeHeaderName: Test-Header\n              rootCauseExceptionMessageHeaderName: Test-Header\n\n           # 另一块比较困难的是速率限制\n          # 它由RateLimiter的实现来完成的，默认只支持redis，需要添加`spring-boot-starter-data-redis-reactive`依赖\n          # 我们需要提供KeyResolver的实现，因为默认会使用PrincipalNameKeyResolver，在不使用Spring Security的情况下几乎不会用到Principal\n          # 除此外，我们也可以提供自定义的RateLimiter，#{@myRateLimiter}是一个SpEL表达式，用于从Spring上下文内读取bean\n          - name: RequestRateLimiter\n            args:\n              redis-rate-limiter.replenishRate: 10\n              redis-rate-limiter.burstCapacity: 20\n          - name: RequestRateLimiter\n            args:\n              rate-limiter: \"#{@myRateLimiter}\"\n              key-resolver: \"#{@userKeyResolver}\"\n```\n\nKeyResolver的实现参考\n```java\n@Bean\nKeyResolver userKeyResolver() {\n    return exchange -> Mono.just(exchange.getRequest().getQueryParams().getFirst(\"user\"));\n}\n```\n\n除此外还有两个“特别”的过滤器，`modifyRequestBody` `modifyResponseBody`他们只能使用在Fluent Java Routes API中。例如：\n\n```java\n@Bean\npublic RouteLocator routes(RouteLocatorBuilder builder) {\n    return builder.routes()\n        .route(\"rewrite_request_obj\", r -> r.host(\"*.rewriterequestobj.org\")\n            .filters(f -> f.prefixPath(\"/httpbin\")\n                .modifyRequestBody(String.class, Hello.class, MediaType.APPLICATION_JSON_VALUE,\n                    (exchange, s) -> return Mono.just(new Hello(s.toUpperCase())))).uri(uri))\n        .build();\n}\n```\n\n此外，这两个过滤器目前处在Beta中，不稳定。而且，Spring团队对于Body的处理十分愚蠢，我会在Others章节提及。\n\n对于全局过滤器，目前系统提供的一般都用于支持基础功能。如负载均衡、路由转换、生成Response等等。对于我们来说，需要关心这些全局过滤器的顺序，毕竟他们与上面的过滤器会一同工作。\n\n与predicates类似，filter也提供了自定义的能力，相对于鸡肋的predicate的自定义，filter显得有用的多。也可能因此，它居然有官方文档介绍（在predicate中是TBD）。我们可以使用它来完成权限的鉴定与下发，一个好的方案是，网关与客户端之间通过session保存用户的登录状态，在网关内，微服务间的沟通使用JWT来认证安全信息。那么我们需要由过滤器来完成这些工作，一个例子如下：\n\n```java\n@Configuration\npublic class GenerateJwtGatewayFilterFactory extends AbstractGatewayFilterFactory<GenerateJwtGatewayFilterFactory.Config> {\n\n    @Resource\n    private JwtProperties properties;\n    @Resource\n    private JwtAuthServer jwtAuthServer;\n\n    public GenerateJwtGatewayFilterFactory() {\n        super(Config.class);\n    }\n\n    @Override\n    public String name() {\n        return \"GenerateJwt\";\n    }\n\n    @Override\n    public GatewayFilter apply(Config config) {\n\n        String[] place = config.getPlace().split(\":\");\n\n        return (exchange, chain) -> {\n            return Mono\n                    .defer(() -> {\n                        if (\"session\".equals(place[0])) {\n                            return exchange.getSession().map(webSession -> {\n                                return webSession.getAttributes().getOrDefault(place[1], \"\");\n                            });\n                        }\n                        if (\"query\".equals(place[0])) {\n                            String first = exchange.getRequest().getQueryParams().getFirst(place[1]);\n                            return Mono.justOrEmpty(first);\n                        }\n                        if (\"form\".equals(place[0])) {\n                            /*return exchange.getFormData().map(formData -> {\n                                String first = formData.getFirst(place[1]);\n                                return Optional.ofNullable(first).orElse(\"\");\n                            });*/\n                            return new DefaultServerRequest(exchange).bodyToMono(new ParameterizedTypeReference<MultiValueMap<String, String>>() {}).map(formData -> {\n                                String first = formData.getFirst(place[1]);\n                                return Optional.ofNullable(first).orElse(\"\");\n                            });\n                        }\n                        throw new BaimiException(\"不支持的类型！\");\n                    })\n                    .filter(sub -> !StringUtils.isEmpty(sub))\n                    .map(sub -> jwtAuthServer.generate(config.getAudience(), config.getPrefix() + \":\" + sub))\n                    .map(token -> exchange.getRequest().mutate().header(properties.getHeaderName(), properties.getHeaderPrefix() + token).build())\n                    .map(req -> exchange.mutate().request(req).build())\n                    .then(chain.filter(exchange));\n        };\n    }\n\n    @Override\n    public List<String> shortcutFieldOrder() {\n        return Arrays.asList(\"place\", \"audience\", \"prefix\");\n    }\n\n    @Data\n    static class Config {\n        /**\n         * 三种类型的位置.\n         * - session:<param>\n         * - query:<param>\n         * - form:<param>\n         */\n        private String place = \"session:user\";\n        /**\n         * 授权对象\n         * system: 系统用户\n         * wechat: 微信用户\n         * etc\n         */\n        private String audience = \"system\";\n        /**\n         * 授权主体标识\n         */\n        private String prefix = \"id\";\n    }\n}\n```\n\n在配置文件中，直接使用，更多代码见下面参考中的项目源码。\n\n```yml\nspring:\n  cloud:\n    gateway:\n      routes:\n        - id: example\n          uri: http://example.org\n          filters:\n            - GenerateJwt=form:id,system,id\n```\n\n全局的过滤器也能自定义，像下面一样\n\n```java\n@Bean\n@Order(1)\npublic GlobalFilter c() {\n    return (exchange, chain) -> {\n        log.info(\"third pre filter\");\n        return chain.filter(exchange).then(Mono.fromRunnable(() -> {\n            log.info(\"first post filter\");\n        }));\n    };\n}\n```\n\n# Others\n\n## Fluent Java Routes API\n\n关于Java DSL，个人是极度不推荐使用。由于修改后需要重新打包部署。如果由配置文件决定，我们仅需修改配置文件，重新运行即可，程序会更加稳定，因为它仅提供功能给配置文件使用。\n\n## Request/Response Body\n\n> IllegalStateException 问题范围为 Spring Cloud Gateway 2.0.0 至 2.1.1，1.x 理论上正常但未测试，2.1.2已修复。\n\n关于Body，Spring对于其的操作是，在最初始化阶段，读取Body内容放入Flux流中。之后都是对其操作。详细可以看下`AdaptCachedBodyGlobalFilter`全局过滤器的源码。\n\n似乎没什么问题是吧，我们就应该在这个操作流内不断的修改Body的内容，直至其被最终消费（转发）。但是当我们在过滤中使用`exchange.getRequest().getBody()`或者`exchange.getFormData()`之后，我们期望后续Spring是读取我们所产生的流，然而事实上，它仍然产生调用`getBody()`获取最初的流。流是线性的，已消费过的不能再次被消费！所以，我们无法方便的使用它达到我们的目的（当然Java DSL内有提供内置的过滤器，但我不推荐Java DSL本身）。\n\n对此，我们有两种方案解决这个问题\n1. 处理完成后的流放入Request/Response中，以便其后续的消费\n2. 修改getBody()的行为，缓存body内容，且每次生成新的流支持后续操作\n\n由于Request/Response对应的Builder不支持放入Body，所有，方案一每次都需要重新构建Body解码器，就像`modifyRequestBody`做的一样。。。在不需要修改Body的内容的前提（大部分都是这样的）下，方案二我们可以写成通用的Factory，在适当的位置添加即可，显得更加可操作。\n\n下面是一个filter，用于支持RequestBody的缓存：\n\n```java\n@Configuration\npublic class CacheRequestGatewayFilterFactory extends AbstractGatewayFilterFactory<CacheRequestGatewayFilterFactory.Config> {\n\n    public CacheRequestGatewayFilterFactory() {\n        super(Config.class);\n    }\n\n    @Override\n    public String name() {\n        return \"CacheRequest\";\n    }\n\n    @Override\n    public GatewayFilter apply(Config config) {\n        CacheRequestGatewayFilter cacheRequestGatewayFilter = new CacheRequestGatewayFilter();\n        Integer order = config.getOrder();\n        if (order == null) {\n            return cacheRequestGatewayFilter;\n        }\n        return new OrderedGatewayFilter(cacheRequestGatewayFilter, order);\n    }\n\n    public static class CacheRequestGatewayFilter implements GatewayFilter {\n        @Override\n        public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {\n\n            //GET DELETE 不过滤\n            HttpMethod method = exchange.getRequest().getMethod();\n            if (method == null || method.matches(\"GET\") || method.matches(\"DELETE\")) {\n                return chain.filter(exchange);\n            }\n\n            return DataBufferUtils.join(exchange.getRequest().getBody())\n                    .map(dataBuffer -> {\n                        byte[] bytes = new byte[dataBuffer.readableByteCount()];\n                        dataBuffer.read(bytes);\n                        DataBufferUtils.release(dataBuffer);\n                        return bytes;\n                    })\n                    .defaultIfEmpty(new byte[0])\n                    .flatMap(bytes -> {\n                        DataBufferFactory dataBufferFactory = exchange.getResponse().bufferFactory();\n                        ServerHttpRequestDecorator decorator = new ServerHttpRequestDecorator(exchange.getRequest()) {\n                            @Override\n                            public Flux<DataBuffer> getBody() {\n                                if (bytes.length > 0) {\n                                    return Flux.just(dataBufferFactory.wrap(bytes));\n                                }\n                                return Flux.empty();\n                            }\n                        };\n                        return chain.filter(exchange.mutate().request(decorator).build());\n                    });\n        }\n    }\n\n    @Override\n    public List<String> shortcutFieldOrder() {\n        return Collections.singletonList(\"order\");\n    }\n\n    @Data\n    static class Config {\n        private Integer order;\n    }\n\n}\n```\n\n配置文件添加CacheRequest，用于添加过滤器（如果不加，从form中读取数据是会报错的）\n\n```yml\nspring:\n  cloud:\n    gateway:\n      routes:\n        - id: jwt\n          uri: lb://app-name\n          predicates:\n            - Path=/jwt/**\n          filters:\n            - CacheRequest\n            - GenerateJwt=form:id,system,id\n```\n\n当然，`exchange.getFormData()`的问题没有解决，需要对Body操作，请使用`exchange.getRequest().getBody()`\n\n> 在下方 issues:946 提了简化操作的建议，然后官方添加了相关Cache方法，然后发现不使用这个方法也不出问题。。。问题原因就是`AdaptCachedBodyGlobalFilter`对body解码器的封装，默认情况下2.1.2中不做处理，所以好了。。。\n\n# 参考\n- [项目源码](https://github.com/jiangtj-lab/spring-cloud-gateway-example)\n- [官方文档](https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.1.0.RELEASE/single/spring-cloud-gateway.html#_modify_request_body_gatewayfilter_factory)\n- [issues:946 关于Body流操作需要简化的建议](https://github.com/spring-cloud/spring-cloud-gateway/issues/946)\n","categories":["后端"],"tags":["Spring Cloud","微服务"]},{"title":"Theme Show Case","url":"/articles/beechnut/theme-show-case/","content":"\n展示些样式，逐步修改中~\n\n<!-- more -->\n\n# Title 1 `code`\n\n## Title 2 `code`\n\n### Title 3 `code`\n\n#### Title 4 `code`\n\n##### Title 5 `code`\n\n###### Title 6 `code`\n\n正文内容1\n\n正文内容2\n\n\n# Same title\n标题一样的情况\n\n# Same title\n标题一样的情况\n\n## Same title\n标题一样的情况\n\n# List\n\n## Ordered List\n1. 第一步修改布局\n  1. 布局A要下移\n    1. YaYaYaYaYaYaYaYaYaYa\n    2. Who care?\n  2. 布局B去掉\n2. 调整css样式！！\n\n## Unordered List\n- 第一步修改布局\n  - 布局A要下移\n    - YaYaYaYaYaYaYaYaYaYa\n    - Who care?\n  - 布局B去掉\n- 调整css样式！！\n\n## Checked List\n- [ ] check this point!\n- [x] do you like it?\n\n# Code\n\n```js\nhexo.extend.filter.register('theme_inject', function(injects) {\n  injects.head.file('custom', 'source/_data/head.swig', {}, {cache: true});\n  injects.sidebar.raw('custom', 'Put some in sidebar!');\n});\n```\n\n## codeblock\n{% codeblock 描述 lang:objc http://localhost:4000/articles/beechnut/theme-show-case/ haha.ocjc? %}\n[rectangle setX: 10 y: 10 width: 20 height: 20];\n{% endcodeblock %}\n\n## include_code\n{% include_code title lang:js hexo-newd.js %}\n\n## jsfiddle\n{% jsfiddle jiangtj/n1tg3hq2 %}\n\n## gist\n{% gist JiangTJ/2f2a8d5089193e5fa60ea45adedfcdec %}\n\n\n# Table\n\n| 水果        | 价格    |  数量  |\n| :--------   | -----:  | :----: |\n| 香蕉        | $1      |   5    |\n| 苹果        | $1      |   6    |\n| 草莓        | $1      |   7    |\n\n## Long Table\n\n|水果|价格|数量|水果|价格|数量|水果|价格|数量|水果|价格|数量|水果|价格|数量|水果|价格|数量|\n|---|---:|:--:|---|---:|:--:|---|---:|:--:|---|---:|:--:|---|---:|:--:|---|---:|:--:|\n|香蕉|$1|5    |香蕉|$1|5    |香蕉|$1|5    |香蕉|$1|5    |香蕉|$1|5    |香蕉|$1|5    |\n|苹果|$1|6    |苹果|$1|6    |苹果|$1|6    |苹果|$1|6    |苹果|$1|6    |苹果|$1|6    |\n|草莓|$1|7    |草莓|$1|7    |草莓|$1|7    |草莓|$1|7    |草莓|$1|7    |草莓|$1|7    |\n\n# blockquote\n{% blockquote %}\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque hendrerit lacus ut purus iaculis feugiat. Sed nec tempor elit, quis aliquam neque. Curabitur sed diam eget dolor fermentum semper at eu lorem.\n{% endblockquote %}\n\n# Images\nInline pic ok? {% asset_img gua.png 100 %}\n\n![](/articles/beechnut/theme-show-case/gua.png)\n\n或者居中显示，你可以使用center或者box样式：\n```md\n{% asset_img center gua.png 呱呱呱 %}\n{% asset_img box gua.png 呱呱呱 %}\n```\n\n{% asset_img center gua.png 呱呱呱 %}\n\n{% asset_img box gua.png 呱呱呱 %}\n\n# Link\n\nAutolink: https://jiangtj.com/\n\n[dnocm 站点](https://www.dnocm.com/)\n\n# Button\n\n```md\n{% btn #, Text & Icon (buggy), fas fa-home %}\n```\n\n{% btn #, Text & Icon (buggy), fas fa-home %}\n\n# Note\n\n{% note icon:disable %}\ncontent\n{% endnote %}\n\n{% note default default title %}\ncontent\n{% endnote %}\n\n{% note primary default title %}\n**Welcome** to [Hexo!](https://hexo.io)\n{% endnote %}\n\n{% note info default title %}\n**Welcome** to [Hexo!](https://hexo.io)\n{% endnote %}\n\n{% note success default title %}\n**Welcome** to [Hexo!](https://hexo.io)\n{% endnote %}\n\n{% note warning default title %}\n**Welcome** to [Hexo!](https://hexo.io)\n{% endnote %}\n\n{% note danger default title %}\n**Welcome** to [Hexo!](https://hexo.io)\n{% endnote %}\n\n","categories":["前端"],"tags":["Theme"]},{"title":"想写个自己的主题","url":"/articles/beechnut/todo-an-new-theme/","content":"\n目前使用的NexT主题，也是NexT成员。但果然还是希望自己的站点能够与众不同点，所以想写个自己的主题。整理下一些资源\n\n**参考主题**\n- [NexT](https://github.com/theme-next/hexo-theme-next)：最熟悉的\n- [Inside](https://github.com/elmorec/hexo-theme-inside)：厉害的作者，使用Angular重写了生成器\n\n计划：基于NexT改进，参照Inside的设计风格\n\nCanary Channel：\n- 圆润化设计\n- 扁平化，去除阴影效果\n- banner图支持\n\nNext Plan：多评论系统支持，重构并简化配置（@w@现在好多）\n","tags":["Todo"]},{"title":"小白VPN教程","url":"/articles/beechnut/vpn-white/","content":"\n删除图文化的教材，我认为 Outline Manage 是很简单的，你可能只需要懂一点点服务器就行了，你可能好奇我为什么要删除这篇文章，所以我在这回答两个问题\n\nQ：为什么要搭建 VPN？\n\nA：这对于程序员来说，答案是一致的。我们需要外部的资源，可能是文档，可能是lib，可能是问答社区。然而合规的搭建 vpn 需要满足两个条件，第一是企业，第二有外贸。这对于我们个人学习为目的是不可能申请下来的。所以才需要私自搭建\n\nQ：那么为什么要删除教程？\n\nA：我也一度以为，“墙”的存在，造就了诸多不便，它至少使中国的软件方面学习难度高了数倍。但近年来发生了很多事，我看到了美国这类的国家，对于中国进行诸多污蔑，并不是没人为中国发声，而是你能在推特上看到内容，基本都是被控制的。我就遇到过被推特删评的情况，这就是所谓的“民主”与“自由”。所以，如果你找到这篇文章，仅仅是希望访问外网的资讯，而不是用于其他目的（目前也就程序员有这需求吧），那么我拒绝提供相关教程，如果你是程序员，那么看我的另一篇文章，相信对于你来说这不会很难\n\n另一篇[VPN教程](/more/vpn)\n","categories":["工具"],"tags":["vpn"]},{"title":"一点点解析Vue CLI之Create","url":"/articles/beechnut/vue-cli-create/","content":"\nNodejs除了赋予前端后端的能力外，还能有各种各样的脚本，极大的简单各种操作。在早期，脚本做的工作大都是生成固定的模版，所以你需要了解的，仅仅生成的项目就够了。然而，随着框架的完善，架构师往往希望通过脚本处理默认的配置或者环境，这样能减少环境差异导致的问题，还能简化升级核心框架的升级，例如Vue CLI做的事。\n\n这时候，我们不得不探一探它的神秘面纱。\n\n这次带来的是Create的原理解析。\n\n<!-- more -->\n\n# Package\n\n怎么看的呢？第一步是寻找package.json文件，它定义了项目所需的依赖以及项目的名称等信息，所以都存这样的文件。CLI的脚本放在[bin属性](https://yarnpkg.com/zh-Hant/docs/package-json/#toc-bin)下，它会随着安装放入系统的环境变量中，所以我们可以在任意的位置使用它。\n\n在Vue CLI的项目中，目录结构是奇怪的。一般情况下，最外面的是项目本身，也就是CLI工程，然而它是文档。他的CLI项目放在[packages/@vue](https://github.com/vuejs/vue-cli/tree/dev/packages/%40vue)目录下。\n\n这里做个备注，此时的hash值是`7375b12c8e75bd4ddc5f04a475512971e1f2bd04`，你们可以看这个位置的源码。\n\n里面的CLI项目很多，不过我这次找的算简单的，在cli的这个项目里，他的package.json如下。\n\n```json\n{\n  \"name\": \"@vue/cli\",\n  \"version\": \"3.6.3\",\n  \"description\": \"Command line interface for rapid Vue.js development\",\n  \"bin\": {\n    \"vue\": \"bin/vue.js\"\n  },\n  //...\n}\n```\n\n`bin/vue.js`这是所执行的脚本。\n\n# vue.js\n接下来看一下第一个脚本。\n```js\n#!/usr/bin/env node\n// 定义使用node环境\n\nconst minimist = require('minimist')\nconst program = require('commander')\nconst loadCommand = require('../lib/util/loadCommand')\n\n\nprogram\n  .command('create <app-name>')\n  .description('create a new project powered by vue-cli-service')\n  .option('-p, --preset <presetName>', 'Skip prompts and use saved or remote preset')\n  //...more option\n  .option('--skipGetStarted', 'Skip displaying \"Get started\" instructions')\n  .action((name, cmd) => {\n    const options = cleanArgs(cmd)\n\n    if (minimist(process.argv.slice(3))._.length > 1) {\n      console.log(chalk.yellow('\\n Info: You provided more than one argument. The first one will be used as the app\\'s name, the rest are ignored.'))\n    }\n    // --git makes commander to default git to true\n    if (process.argv.includes('-g') || process.argv.includes('--git')) {\n      options.forceGit = true\n    }\n    require('../lib/create')(name, options)\n  })\n\n// commander passes the Command object itself as options,\n// extract only actual options into a fresh object.\nfunction cleanArgs (cmd) {\n  const args = {}\n  cmd.options.forEach(o => {\n    const key = camelize(o.long.replace(/^--/, ''))\n    // if an option is not present and Command has a method with the same name\n    // it should not be copied\n    if (typeof cmd[key] !== 'function' && typeof cmd[key] !== 'undefined') {\n      args[key] = cmd[key]\n    }\n  })\n  return args\n}\n\n```\n\n上面，我只拷贝了相关代码。\n\n我们可以看到，create命令是通过[commander](https://www.npmjs.com/package/commander)创建的，这是个转换命令行的工具，简单说就是将`vue create xxx --a aaa --b vvv`这些东西格式化。`cleanArgs`函数，将program属性想换为配置对象，便于后面的操作\n\n其中[process](https://nodejs.org/api/process.html)是node的线程也是就是这次命令的线程，它可以用来获取当前目录以及变量等，当然也可以通过它异常结束。比如`process.argv.slice(3)`这因为在命令行中，第一个变量是自己本身，而vue create分别占据第二第三变量，所需从第四个起。\n\n`minimist`也是同样，起到格式化的作用，详见[它的文档](https://www.npmjs.com/package/minimist)。\n\n接下来，它调用`../lib/create`脚本。\n\n# create\n\n第二个脚本\n\n```js\nconst fs = require('fs-extra')\nconst path = require('path')\nconst chalk = require('chalk')\nconst inquirer = require('inquirer')\nconst Creator = require('./Creator')\nconst { clearConsole } = require('./util/clearConsole')\nconst { getPromptModules } = require('./util/createTools')\nconst { error, stopSpinner, exit } = require('@vue/cli-shared-utils')\nconst validateProjectName = require('validate-npm-package-name')\n\nasync function create (projectName, options) {\n  if (options.proxy) {\n    process.env.HTTP_PROXY = options.proxy\n  }\n\n  const cwd = options.cwd || process.cwd()\n  const inCurrent = projectName === '.'\n  const name = inCurrent ? path.relative('../', cwd) : projectName\n  const targetDir = path.resolve(cwd, projectName || '.')\n\n  const result = validateProjectName(name)\n  if (!result.validForNewPackages) {\n    console.error(chalk.red(`Invalid project name: \"${name}\"`))\n    result.errors && result.errors.forEach(err => {\n      console.error(chalk.red.dim('Error: ' + err))\n    })\n    result.warnings && result.warnings.forEach(warn => {\n      console.error(chalk.red.dim('Warning: ' + warn))\n    })\n    exit(1)\n  }\n\n  if (fs.existsSync(targetDir)) {\n    if (options.force) {\n      await fs.remove(targetDir)\n    } else {\n      await clearConsole()\n      if (inCurrent) {\n        const { ok } = await inquirer.prompt([\n          {\n            name: 'ok',\n            type: 'confirm',\n            message: `Generate project in current directory?`\n          }\n        ])\n        if (!ok) {\n          return\n        }\n      } else {\n        const { action } = await inquirer.prompt([\n          {\n            name: 'action',\n            type: 'list',\n            message: `Target directory ${chalk.cyan(targetDir)} already exists. Pick an action:`,\n            choices: [\n              { name: 'Overwrite', value: 'overwrite' },\n              { name: 'Merge', value: 'merge' },\n              { name: 'Cancel', value: false }\n            ]\n          }\n        ])\n        if (!action) {\n          return\n        } else if (action === 'overwrite') {\n          console.log(`\\nRemoving ${chalk.cyan(targetDir)}...`)\n          await fs.remove(targetDir)\n        }\n      }\n    }\n  }\n\n  const creator = new Creator(name, targetDir, getPromptModules())\n  await creator.create(options)\n}\n\nmodule.exports = (...args) => {\n  return create(...args).catch(err => {\n    stopSpinner(false) // do not persist\n    error(err)\n    if (!process.env.VUE_CLI_TEST) {\n      process.exit(1)\n    }\n  })\n}\n```\n\n`module.exports = (...args) `接受不定参，然后，不管是传入也好调用也好，都是固定的两个参数，不明白这里的目的，偷懒？\n\n这里的代码大部分都是对命令行参数的校验与解析，不存在难点。\n\n最后，通过`new Creator(name, targetDir, getPromptModules())`创建创建者对象，以及执行`create`。所以重点在Creator对象中。\n\n# Creator\n\n太长了！😖所以这部分不细说了，大体上与之前一致，只不过复杂点。值得一提的是Creator继承了`EventEmitter`，所以它在创建过程的不同阶段发布事件，根据这个，我们可以拆分着看。\n\n```js\nthis.emit('creation', { event: 'fetch-remote-preset' })\nthis.emit('creation', { event: 'creating' })\nthis.emit('creation', { event: 'git-init' })\nthis.emit('creation', { event: 'plugins-install' })\nthis.emit('creation', { event: 'invoking-generators' })\nthis.emit('creation', { event: 'deps-install' })\nthis.emit('creation', { event: 'completion-hooks' })\nthis.emit('creation', { event: 'done' })\n```\n\n一共有以上几个事件，当然，也有可能由于配置原因，某些步骤会跳过。比如设置shouldInitGit为false。\n\n\n> 大体上就是这样。唉，这可能是唯一的一篇讲解Vue CLI源码的文章，太忙了（我是后端，后端，后端~~）\n","categories":["前端"],"tags":["Vue","Vue CLI"]},{"title":"Web Components实践","url":"/articles/beechnut/web-components/","content":"\n组件化、复用，这几乎是所有开发者追求的东西。Web Components就是为此而提出。可以使用来创建封装功能的定制元素，可以在你喜欢的任何地方重用，不必担心代码冲突。\n\n这样的理念和Vue十分相似，专注于组件。所以Web Components或许是未来的方向！我在这里写一些Web Components的例子，供学习与参考！\n\n<!-- more -->\n\n> 假如您无法查看例子，请使用最新的Chrome访问该页面\n\n# 自定义elements\nWeb Components通过CustomElementRegistry.define()来定义elements，目前有两种elements，独立的element与继承自基本的HTML element\n\n## 独立的element\n独立的element像`<custom-element>`这样的自定义标签。代码如下：\n\n```js\ncustomElements.define('custom-element',\n  class MyCustomElement extends HTMLElement {\n    constructor() {\n      super();\n\n      //创建<p stype='color:red'></p>\n      const pElem = document.createElement('p');\n      pElem.textContent = this.textContent;\n      pElem.style.color = 'red';\n      //加入根节点\n      const shadowRoot = this.attachShadow({mode: 'closed'});\n      shadowRoot.appendChild(pElem);\n\n    }\n  }\n)\n```\n\n```html\n<custom-element>红色字体的段落！</custom-element>\n```\n\n实际的效果如下：\n\n<custom-element>红色字体的段落！</custom-element>\n<script defer>\ncustomElements.define('custom-element',\n  class MyCustomElement extends HTMLElement {\n    constructor() {\n      super();\n      //创建<p stype='color:red'></p>\n      const pElem = document.createElement('p');\n      pElem.textContent = this.textContent;\n      pElem.style.color = 'red';\n      //加入根节点\n      const shadowRoot = this.attachShadow({mode: 'closed'});\n      shadowRoot.appendChild(pElem);\n    }\n  }\n)\n</script>\n\n## 继承自基本的HTML element\n\n通过例如`<p is='custom-p'>`的方式调用，例如：\n\n```js\ncustomElements.define('custom-p',\n  class MyCustomElement extends HTMLParagraphElement  {\n    constructor() {\n      super();\n      //创建<span stype='color:red'></span>\n      const pElem = document.createElement('span');\n      pElem.textContent = this.textContent;\n      pElem.style.color = 'red';\n      //加入根节点\n      const shadowRoot = this.attachShadow({mode: 'closed'});\n      shadowRoot.appendChild(pElem);\n    }\n  },\n  { extends: 'p' }\n)\n```\n\n```html\n<p is='custom-p'>红色字体的段落！</p>\n```\n\n实际的效果如下：\n\n<p is='custom-p'>红色字体的段落！</p>\n\n<script defer>\ncustomElements.define('custom-p',\n  class MyCustomP extends HTMLParagraphElement  {\n    constructor() {\n      super();\n      const pElem = document.createElement('span');\n      pElem.textContent = this.textContent;\n      pElem.style.color = 'red';\n      const shadowRoot = this.attachShadow({mode: 'closed'});\n      shadowRoot.appendChild(pElem);\n    }\n  },\n  { extends: 'p' }\n)\n</script>\n\n## 生命周期回调函数\n\n在自定义的element的构造函数中，可以指定多个不同的回调函数，它们将会在元素的不同生命时期被调用：\n\n- connectedCallback：当 custom element首次被插入文档DOM时，被调用。\n- disconnectedCallback：当 custom element从文档DOM中删除时，被调用。\n- adoptedCallback：当 custom element被移动到新的文档时，被调用。\n- attributeChangedCallback: 当 custom element增加、删除、修改自身属性时，被调用。\n\n例如：\n```js\ncustomElements.define('other-custom-element',\n  class MyOtherCustomElement extends HTMLElement  {\n    constructor() {\n      super();\n      //......\n    }\n    connectedCallback() {\n      console.log('Custom square element added to page.');\n    }\n    disconnectedCallback() {\n      console.log('Custom square element removed from page.');\n    }\n    adoptedCallback() {\n      console.log('Custom square element moved to new page.');\n    }\n    attributeChangedCallback(name, oldValue, newValue) {\n      console.log('Custom square element attributes changed.');\n    }\n  }\n)\n```\n\n# Shadow DOM\n\n{% asset_img shadow-dom.png %}\n\n如图，Shadow DOM会在自定义标签解析时，加载到普通的DOM上。内部可以通过Element.attachShadow()来获取shadow root。它有一个mode属性，值可以是`open`或者`closed`,表示能否在外部获取Shadow DOM对象，一般而言应当为`closed`，内部实现不应该对外可见。\n\n# HTML templates\n如果你熟悉Vue的话，这块与它很相似，是template与slot。\n\n```html\n<template id=\"person-template\">\n  <div>\n    <h2>Personal ID Card</h2>\n    <slot name=\"person-name\">NAME MISSING</slot>\n    <ul>\n      <li><slot name=\"person-age\">AGE MISSING</slot></li>\n      <li><slot name=\"person-occupation\">OCCUPATION MISSING</slot></li>\n    </ul>\n  </div>\n</template>\n<person-details>\n    <!-- 官方例子p slot=\"person-name\"，由于hexo对p的解析会出错，这里改成了<span> -->\n    <span slot=\"person-name\">Morgan Stanley</span>\n    <span slot=\"person-age\">36</span>\n    <span slot=\"person-occupation\">Accountant</span>\n</person-details>\n```\n\n```js\ncustomElements.define('person-details',\n  class extends HTMLElement {\n    constructor() {\n      super();\n      const template = document.getElementById('person-template');\n      const templateContent = template.content;\n      const shadowRoot = this.attachShadow({mode: 'closed'});\n      shadowRoot.appendChild(templateContent.cloneNode(true));\n  }\n});\n```\n\n实际效果如下：\n\n<template id=\"person-template\"><div><h2>Personal ID Card</h2><slot name=\"person-name\">NAME MISSING</slot><ul><li><slot name=\"person-age\">AGE MISSING</slot></li><li><slot name=\"person-occupation\">OCCUPATION MISSING</slot></li></ul></div></template>\n\n<p>\n<person-details><span slot=\"person-name\">Morgan Stanley</span><span slot=\"person-age\">36</span><span slot=\"person-occupation\">Accountant</span></person-details>\n</p>\n\n<script defer>\ncustomElements.define('person-details',\n  class PersonDetails extends HTMLElement {\n    constructor() {\n      super();\n      const template = document.getElementById('person-template');\n      const templateContent = template.content;\n      const shadowRoot = this.attachShadow({mode: 'closed'});\n      const style = document.createElement('style');\n      style.textContent = `\n        div { padding: 10px; border: 1px solid gray; width: 200px; margin: 10px; }\n      `;\n      shadowRoot.appendChild(style);\n      shadowRoot.appendChild(templateContent.cloneNode(true));\n  }\n});\n</script>\n\n# HTML Imports\n这块存在争议，Mozilla认为将来应该用更合适的方式。不多做介绍。\n\n# 参考\n- [MDN Web_Components](https://developer.mozilla.org/zh-CN/docs/Web/Web_Components)\n\n近期，打算利用这个技术写自己的个人主页！！\n","categories":["前端"],"tags":["组件化"]},{"title":"JPromise:Java版的Promise","url":"/articles/cherry/JPromise/","content":"\n由于Java是强类型语言，js的Promise是不能在Java中实现的，所以也就写着玩玩\n\n![](https://jiangtj-lab.github.io/pic-repo/img-apricot/20200423165107.png)\n\n发布在github上，但下载有点麻烦，有兴趣可以看下我的这个项目路\n\nhttps://github.com/jiangtj-lab/jpromise\n","categories":["后端"]},{"title":"暗色模式上线啦！！","url":"/articles/cherry/dark-mode/","content":"\n馋好久了，最近总算是改完了\n\n当切换系统的色彩方案（亮/暗）时，能自动切换到对应的模式\n\n![](https://jiangtj-lab.github.io/pic-repo/img-apricot/20200511154312.png)\n\n\n# 相关提交\n\n- https://github.com/jiangtj/hexo-theme-cake/pull/55\n- https://github.com/jiangtj-lab/hexo-cake-local-search/commit/350e77722eca991e9678abdd8278663eda66d1dc\n- https://github.com/jiangtj-lab/hexo-cake-moon-menu/commit/8556fe6cb26e993c99805cd9b9d28d80039734b1\n\n"},{"title":"部署 Spring Boot 应用为 systemd 服务","url":"/articles/cherry/deploy-spring-boot/","content":"\n很久之前，我写过一个[脚本](https://dnocm.com/articles/almond/spring-boot-autorun-with-gitlab/)用于重启Spring Boot应用，但最近在看Spring Boot文档，发现之前写的的确不够优雅\n\nSpring Boot 文档中，有一大章专门写[关于如何在系统中部署](https://docs.spring.io/spring-boot/docs/current/reference/html/deployment.html#deployment)，其中，个人认为最佳的方案是作为一个systemd服务运行，由Liunx服务直接调度\n\n<!-- more -->\n\n# 编译一个可执行的Jar\n\n首先，我们需于改变我们的Jar，能在Linux系统中直接运行\n\n在Maven中，添加executable配置为true\n\n```xml\n<plugin>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-maven-plugin</artifactId>\n    <configuration>\n        <executable>true</executable>\n    </configuration>\n</plugin>\n```\n\n或者，如果你使用的是Gradle，添加`launchScript()`\n\n```gradle\nbootJar {\n    launchScript()\n}\n```\n\n*注意：可执行的Jar由于嵌入了脚本，所以无法通过`jar -xf`命令解压*\n\n# 创建systemd服务\n\n在`/etc/systemd/system`文件下，创建`myapp.service`(假设你的服务名叫做myapp，请依据实际情况修改)\n\n```service\n[Unit]\nDescription=myapp\nAfter=syslog.target\n\n[Service]\n# User=myapp\nExecStart=/var/myapp/myapp.jar\nSuccessExitStatus=143\n\n[Install]\nWantedBy=multi-user.target\n```\n\n# 上传Jar\n\n我们需要上传并将生成的可执行Jar，放在与`myapp.service`中`ExecStart`相同的位置\n\n# 运行systemd服务\n\n当我们完成上面步骤，就可以直接通过`systemctl`来运行或控制Spring Boot应用\n\n```bash\n# 启用开机运行\nsystemctl enable myapp.service\n# 禁用开机运行\nsystemctl disable myapp.service\n# 运行\nsystemctl start myapp.service\n# 停止\nsystemctl stop myapp.service\n# 重新运行\nsystemctl restart myapp.service\n# 查看服务状态\nsystemctl status myapp.service\n```\n\n这是不是比用`pgrep` `pgrep` `java -jar`之类的简单方便多了\n","categories":["后端"],"tags":["Java"]},{"title":"在 Docker 中使用 Hexo","url":"/articles/cherry/docker-dev/","content":"\n在项目的根目录创建一个 `compose-dev.yaml` 定义docker compose用于生成开发环境，由于博客不需要额外的数据库等，所以很简单\n\n```yaml\nservices:\n  blog:\n    build:\n      context: .\n      target: dev-envs\n```\n\n- context 指定docker位置\n- target 指定docker镜像构建目标\n\n然后创建 `Dockerfile`\n\n```Dockerfile\n# syntax=docker/dockerfile:1.4\n\nFROM node:lts AS buildhexo\nRUN yarn global add hexo-cli\n\nFROM buildhexo AS development\nWORKDIR /app\nCOPY . .\nRUN yarn install\nCMD hexo s\n\nFROM buildhexo as dev-envs\n# 添加工具git docker vscode\n# RUN <<EOF\n# apt-get update\n# apt-get install -y --no-install-recommends git\n# EOF\n# RUN <<EOF\n# useradd -s /bin/bash -m vscode\n# groupadd docker\n# usermod -aG docker vscode\n# EOF\n# install Docker tools (cli, buildx, compose)\n# COPY --from=gloursdocker/docker / /\nCMD /bin/sh -c \"while sleep 1000; do :; done\"\n```\n\n上面`dev-envs`是被指定执行的，而`development`不会被执行，注释的内容是因为我遇到了网络问题，是从其他模板中复制过来的，理论上没问题，结尾的`CMD /bin/sh -c \"while sleep 1000; do :; done\"`用于保持容器运行\n\n最后，在docker桌面版中，按提示，创建Dev Environments即可\n"},{"title":"Flutter 环境搭建注意事项","url":"/articles/cherry/flutter-install/","content":"\n国内无法访问谷歌的服务，所以参考这篇 [Using Flutter in China](https://flutter.dev/community/china) 官方的文档，进行配置\n\nFlutter的中文社区为： https://flutter.cn\n\n# SDK下载\n\n使用 https://storage.flutter-io.cn/ 代替 https://storage.googleapis.com/ ,下载对应的SDK，例如\n\n- Original URL: https://storage.googleapis.com/flutter_infra/releases/stable/windows/flutter_windows_v1.0.0-stable.zip\n\n- Mirrored URL: https://storage.flutter-io.cn/flutter_infra/releases/stable/windows/flutter_windows_v1.0.0-stable.zip\n\n或者使用迅雷下载，迅雷P2P加速可以绕过([迅雷11内测版下载](http://down.sandai.net/thunder11/XunLeiSetup11.0.2.52Preview.exe))\n\n# Android Studio\n\nJetbrains 的[下载工具](https://www.jetbrains.com/toolbox-app/)已经支持下载 Android Studio, 可以通过它下载\n\nAndroid SDK 现在似乎不被屏蔽了。。。\n\n# 使用镜像\n\nFlutter 依赖于 Dart 的依赖环境，在国内需要通过镜像访问。所以在在运行Fltter命令之前，需要设置两个环境变量：`PUB_HOSTORD_URL`和`FALTER_STORKER_BASE_URL`。\n\nMacOS/Linux 用户\n\n```bash\nexport PUB_HOSTED_URL=https://pub.flutter-io.cn\nexport FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn\n```\n\nWindows 用户\n\n在 `电脑 -> 属性 -> 高级系统设置 -> 高级 -> 环境变量` 中修改\n\n# 下载 Gradle\n\nGradle 没被墙，但是下载很慢，如果不手动下载，可能长时间卡在这一步\n\n当你创建一个新项目时，会生成一些文件，其中有个`${project}/android/gradle/wrapper/gradle-wrapper.properties`\n\n```properties\n#Fri Jun 23 08:50:38 CEST 2017\ndistributionBase=GRADLE_USER_HOME\ndistributionPath=wrapper/dists\nzipStoreBase=GRADLE_USER_HOME\nzipStorePath=wrapper/dists\ndistributionUrl=https\\://services.gradle.org/distributions/gradle-5.6.2-all.zip\n```\n\n这个文件描述了 Gradle 下载的位置，以及它的分发地址(我这需要下载bin归档，不知道是我环境问题还是什么，即<https://services.gradle.org/distributions/gradle-5.6.2-bin.zip>)\n\n存放的位置很奇怪，是`${GRADLE_USER_HOME}/wrapper/dists/gradle-S{version}-all/${sha}/`，比较简单的方法是先运行下，再去找这个目录，把已经下好的 gradle 归档文件直接丢进去，不需要减压或重命名\n\n暂时就这些，如果还有以后补充\n","categories":["前端"],"tags":["Dart","Flutter","Android"]},{"title":"发布 npm 包到 GitHub Packages","url":"/articles/cherry/github-packages-npm/","content":"\nGitHub Packages在半年前尝试过，那时候存在些问题\n\n1. ~~不能使用yarn安装（这个已经修复了）~~\n2. 必须认证授权才能使用，即便你的包是开源的，很不方便\n\n![](https://jiangtj-lab.github.io/pic-repo/img-apricot/20200422094211.png)\n\n但不管怎样，GitHub Packages始终是个不错的备选方案\n\n<!-- more -->\n\n# 授权\n\n与其它包管理不同，在GitHub Packages上，无论上传还是下载安装都需要授权\n\n首先需要在`Developer settings/Personal access tokens`中创建一个token，选择你需要的权限\n\n![](https://jiangtj-lab.github.io/pic-repo/img-apricot/20200422095056.png)\n\n然后将token添加至`~/.npmrc`(win用户路径`C://用户/你当前登录用户`)\n\n```\n//npm.pkg.github.com/:_authToken=TOKEN\n```\n\n或者使用`npm login`命令进行授权\n\n```\n$ npm login --registry=https://npm.pkg.github.com\n> Username: USERNAME\n> Password: TOKEN\n> Email: PUBLIC-EMAIL-ADDRESS\n```\n\n# 发布一个包\n\n需要先完成授权，GitHub Packages的发布与npm上基本一致，除了包名称有规定和发布地址修改外\n\n在GitHub Packages中，你的包名称必须与项目名称对应，例如`user/test`项目，对应的包名称为`@user/test`\n\n其次需要指定发布地址，选择以下两种途径中的一种\n\n- 编辑项目中的`.npmrc`(与`package.json`同路径下)，添加GitHub Packages的地址\n  ```\n  registry=https://npm.pkg.github.com/OWNER\n  //或者@OWNER:registry=https://npm.pkg.github.com\n  ```\n\n- 在`package.json`中添加`publishConfig`\n  ```json\n  \"publishConfig\": {\n    \"registry\":\"https://npm.pkg.github.com/\"\n  }\n  ```\n\n在完成上述步骤后，就是简单的`npm publish`，即可完成发布\n\n# 安装使用\n\n首先，仍然需要先进行授权（这个真不合理，别人要用放在GitHub Packages，必须要先申请帐号，再token等做一堆事...如果不是这个，真的推荐使用GitHub Packages来管理开源组织的包）\n\n然后添加一个本地的`.npmrc`，与发布中的一样\n\n```\nregistry=https://npm.pkg.github.com/OWNER\n//或者@OWNER:registry=https://npm.pkg.github.com\n```\n\n完成上述步骤后，就可以使用了`npm install`\n","categories":["前端"],"tags":["Packages"]},{"title":"Gradle 初探","url":"/articles/cherry/gradle-start/","content":"\n第一次接触 Gradle 是在数年前做android开发的时候，然而后来我的工作都是 Maven 做web开发，所以 Gradle 也就忘得差不多了（其实本来就没学多少）\n\n我相信每个看到这篇文章的人，都是用过 Maven 的， 想学习 Gradle，但在开始前，我们应该弄清楚为什么要学它，它能带来怎样的益处（相对于 Maven）？\n\n# Why\n\n如果你问 Gradle 优于 Maven 么？ 答案必定是不一定\n\n在 Maven 中有完善的依赖管理以及成熟的构建流程，在绝大多数的项目中都能很好的运行。但也是那一套流程，使的 Maven 十分死板。而且 Maven 是只属于 Java 的项目构建工具\n\n在 Gradle 中就灵活的多，你可以随意的定义流程，但一个大型的项目规范是十分重要的，即便是构建流程，也要有规范，也是要统一的，试问假如我要构建一个普通的Web应用，自己定的构建流程又怎么能比过这么长时间积累下来的 Maven 的流程的？ 但我的项目是个缝合怪呢，有java有node，那么 Gradle 就能同时组织它们。 Gradle 是 Java 环境下的构建工具， 它不是 Java 项目构建工具， 就如 node 里的 Gulp\n\n<!-- more -->\n\n# 创建 Basic 项目\n\nGradle 是通用的构建工具，所以没必要从 Java Web 项目学起，相反，我们可以先创一个空的项目（运行`gradle init`命令可以快速创建）\n\n```\nPS C:\\Users\\MrTT\\Desktop\\2513\\g1> gradle init\nSelect type of project to generate:\n  1: basic\n  2: application\n  3: library\n  4: Gradle plugin\nEnter selection (default: basic) [1..4] 1\n\nSelect build script DSL:\n  1: Groovy\n  2: Kotlin\nEnter selection (default: Groovy) [1..2] 2\n\nProject name (default: g1):\n\n\n> Task :init\nGet more help with your project: https://guides.gradle.org/creating-new-gradle-builds\n\nBUILD SUCCESSFUL in 11s\n2 actionable tasks: 2 executed\n```\n\n我们可以得到下面这样的一个项目\n\n```\n.\n├── .gitattributes\n├── .gitignore\n├── .gradle\n│   ├── ...\n├── build.gradle.kts\n├── gradle\n│   └── wrapper\n│       ├── gradle-wrapper.jar\n│       └── gradle-wrapper.properties\n├── gradlew\n├── gradlew.bat\n└── settings.gradle.kts\n```\n\n`build.gradle.kts`与`settings.gradle.kts`是主要的两个文件，其它`.gitattributes` `.gitignore`是Git的，`.gradle`是 Gradle 构建的缓存，`gradle/wrapper` `gradlew` `gradlew.bat`是为了保证不同的用户使用相同的 Gradle 版本\n\n接下来运行`gradle`命令（实际与`gradle help`一样）\n\n```\nPS C:\\Users\\MrTT\\Desktop\\2513\\g1> gradle\n\n> Task :help\n\nWelcome to Gradle 6.5.\n\nTo run a build, run gradle <task> ...\n\nTo see a list of available tasks, run gradle tasks\n\nTo see a list of command-line options, run gradle --help\n\nTo see more detail about a task, run gradle help --task <task>\n\nFor troubleshooting, visit https://help.gradle.org\n\nBUILD SUCCESSFUL in 1s\n1 actionable task: 1 executed\n```\n\n从帮助信息中，了解到运行`gradle tasks`查看所有任务\n\n```\nPS C:\\Users\\MrTT\\Desktop\\2513\\g1> gradle tasks\n\n> Task :tasks\n\n------------------------------------------------------------\nTasks runnable from root project\n------------------------------------------------------------\n\nBuild Setup tasks\n-----------------\ninit - Initializes a new Gradle build.\nwrapper - Generates Gradle wrapper files.\n\nHelp tasks\n----------\nbuildEnvironment - Displays all buildscript dependencies declared in root project 'g1'.\ncomponents - Displays the components produced by root project 'g1'. [incubating]\ndependencies - Displays all dependencies declared in root project 'g1'.\ndependencyInsight - Displays the insight into a specific dependency in root project 'g1'.\ndependentComponents - Displays the dependent components of components in root project 'g1'. [incubating]\nhelp - Displays a help message.\nkotlinDslAccessorsReport - Prints the Kotlin code for accessing the currently available project extensions and conventions.\nmodel - Displays the configuration model of root project 'g1'. [incubating]\noutgoingVariants - Displays the outgoing variants of root project 'g1'.\nprojects - Displays the sub-projects of root project 'g1'.\nproperties - Displays the properties of root project 'g1'.\ntasks - Displays the tasks runnable from root project 'g1'.\n\nTo see all tasks and more detail, run gradle tasks --all\n\nTo see more detail about a task, run gradle help --task <task>\n\nBUILD SUCCESSFUL in 1s\n1 actionable task: 1 executed\n```\n\n默认情况下，已经存在了任务（辅助任务？），可以随便执行个看看，比如`buildEnvironment`\n\n```\nPS C:\\Users\\MrTT\\Desktop\\2513\\g1> gradle buildEnvironment\n\n> Task :buildEnvironment\n\n------------------------------------------------------------\nRoot project\n------------------------------------------------------------\n\nclasspath\nNo dependencies\n\nA web-based, searchable dependency report is available by adding the --scan option.\n\nBUILD SUCCESSFUL in 1s\n1 actionable task: 1 executed\n```\n\n这就是一个空项目，相信你已经了解了\n\n## 创建第一个任务\n\n程序猿的第一个任务，必然是打印`Hello world!`，打开`build.gradle.kts`，在里面添加以下代码\n\n```kotlin\ntasks.register(\"hello\") {\n    doLast {\n        println(\"Hello world!\")\n    }\n}\n```\n\n`gradle` 会在`build.gradle.kts`中寻找任务，至于为什么这么写，doLast什么鬼，别问，我也不懂。等学完后应该能理解把\n\n运行`gradle tasks --all`我们可以在Other里看到我们定义的`hello`任务，执行它`gradle -q hello`（`-q` 影藏任务以外的输出），控制台就输出`Hello world!`啦\n\n第一个任务到此完成\n\n## 在任务中写代码\n\n```kotlin\ntasks.register(\"upper\") {\n    doLast {\n        val someString = \"mY_nAmE\"\n        println(\"Original: $someString\")\n        println(\"Upper case: ${someString.toUpperCase()}\")\n    }\n}\n```\n\n可以用 kotlin 或者 groovy 直接写脚本代码\n\n## 任务间依赖\n\n```kotlin\ntasks.register(\"intro\") {\n    dependsOn(\"hello\")\n    doLast {\n        println(\"I'm Gradle\")\n    }\n}\n```\n\n*任务间依赖是懒加载的，在依赖时不需要提前定义*\n\n执行结果为\n\n```\nPS C:\\Users\\MrTT\\Desktop\\2513\\g1> gradle intro\n\n> Task :hello\nHello world!\n\n> Task :intro\nI'm Gradle\n\nBUILD SUCCESSFUL in 1s\n```\n\n## 动态添加任务\n\n```kotlin\nrepeat(4) { counter ->\n    tasks.register(\"task$counter\") {\n        doLast {\n            println(\"I'm task number $counter\")\n        }\n    }\n}\n```\n\n几乎可以在`build.gradle.kts`中任意位置写任何代码，*repeat(4)是kotlin的语法*\n\n## 修改已有的任务\n\n```kotlin\ntasks.named(\"task0\") { dependsOn(\"task2\", \"task3\") }\n```\n\n`named()`应该是通过任务名查询已经的任务\n\n```kotlin\nval hello1 by tasks.registering {\n    doLast {\n        println(\"Hello Earth\")\n    }\n}\nhello1 {\n    doFirst {\n        println(\"Hello Venus\")\n    }\n}\nhello1 {\n    doFirst {\n        println(\"Hello Venus2\")\n    }\n}\nhello1 {\n    doLast {\n        println(\"Hello Mars\")\n    }\n}\nhello1 {\n    doLast {\n        println(\"Hello Jupiter\")\n    }\n}\n```\n\n结果为：\n\n```\nHello Venus2\nHello Venus\nHello Earth\nHello Mars\nHello Jupiter\n```\n\n`doFirst` `doLast` 分别在任务的开头与结尾添加，可以多次执行，按添加顺序排序。之前`doLast`的问题解决了，但是这kotlin的语法真是怪（对习惯Java的我来说）\n\n- https://kotlinlang.org/docs/reference/delegated-properties.html\n\n上面是我能找的`by`的语法，至于`val a by b{}; a{}; a{}`这语法，翻遍了文档都没找到，以后再说吧\n\n## 配置默认任务\n\n```kotlin\ndefaultTasks(\"hello\", \"task0\")\n```\n\n设置`gradle`执行的任务，默认是`help`\n\n## 生命周期\n\n```kotlin\ntasks.register(\"distribution\") {\n    doLast {\n        println(\"We build the zip with version=$version\")\n    }\n}\n\ntasks.register(\"release\") {\n    dependsOn(\"distribution\")\n    doLast {\n        println(\"We release now\")\n    }\n}\n\ngradle.taskGraph.whenReady {\n    version =\n        if (hasTask(\":release\")) \"1.0\"\n        else \"1.0-SNAPSHOT\"\n}\n```\n\nwhenReady在任务全部加载后触发（未开始执行），所以执行`distribution`与`release`时，得到不同的`version`\n\n## 添加外部依赖\n\n```kotlin\nimport org.apache.commons.codec.binary.Base64\n\nbuildscript {\n    repositories {\n        mavenCentral()\n    }\n    dependencies {\n        \"classpath\"(group = \"commons-codec\", name = \"commons-codec\", version = \"1.2\")\n    }\n}\n\ntasks.register(\"encode\") {\n    doLast {\n        val encodedString = Base64().encode(\"hello world\\n\".toByteArray())\n        println(String(encodedString))\n    }\n}\n```\n\n使用`commons-codec`的`Base64`\n\n\n# Tasks 高级教程\n\n# 插件的使用\n","categories":["后端"],"tags":["Java","Gradle"]},{"title":"使用 Helm 管理开发环境","url":"/articles/cherry/helm-for-dev/","content":"\n# 添加负载均衡\n\n在云端，这个通常是由云服务商提供的，但由于我们是本地。所以需要自己添加，traefik 是目前最主流的\n\n```bash\nhelm repo add traefik https://traefik.github.io/charts\nhelm repo update\nhelm install traefik traefik/traefik\n```\n\n运行下面命令，可以在 `http://127.0.0.1:9000/dashboard/` 查看仪表\n\n```bash\nkubectl port-forward $(kubectl get pods --selector \"app.kubernetes.io/name=traefik\" --output=name) 9000:9000\n```\n\n# Nacos\n\nNacos 是 Spring Cloud 最好的服务发现与配置中心，我仍然使用了它的 `k8s operator`\n\n首先安装 operator\n```bash\ngit clone https://github.com/nacos-group/nacos-k8s.git\ncd operator\nhelm install nacos-operator ./chart/nacos-operator \n```\n\n其次安装 nacos\n```bash\nhelm repo add jiangtj https://jiangtj.github.io/helm-charts\nhelm install nacos jiangtj/nacos-simple \n```\n\n`nacos-simple` 包含了一个 `nacos.yaml` 定义nacos服务和一个 `ingress.yaml` 定义转发，[详见GitHub](https://github.com/jiangtj/helm-charts/tree/master/charts/nacos-simple)\n\n# 总结\n\nk8s 能定义一系列的服务，对于一个复杂开发环境来说，会比 docker 更加简单，比如同时需要redis rabbitmq mysql等等，尤其还能通过 helm 同步定义，当然简单的环境，还是 docker 吧\n","categories":["运维"]},{"title":"Hexo 5.0.0 正式发布","url":"/articles/cherry/hexo-5/","content":"\nNode.js 上最快的静态站点生成器 Hexo 发布了 5.0.0 版本。作为 Hexo 核心团队成员，让我为大家介绍一下 Hexo 5.0.0 中的新特性，以及如何从 Hexo 4.x 版本升级到 Hexo 5.0.0。\n\n<!-- more -->\n\n# 新特性\n\n## 通过 npm 安装主题\n\n过去，安装 Hexo 主题需要 `git clone` 或者下载、解压 zip；更新主题时还需要迁移 `_config.yml` 。Hexo 5.0.0 支持通过 npm 安装主题。现在安装一个主题只需要三步：\n\n- 使用 `npm install hexo-theme-[主题的名称]` 即可安装主题；\n- 在站点的 `_config.yml` 中指定主题的名称：\n  ```yml\n  theme: \"[主题的名称]\"\n  ```\n- 在站点根目录下新建一个文件 `_config.[主题的名称].yml`，在该文件中填入主题的配置即可。\n\n对于主题的开发者、插件开发者，以及进阶的 Hexo 用户来说，这是你们想要了解的技术细节：\n\n- 为了保证向后兼容性，Hexo 依然支持从 `themes/[主题的名称]` 目录加载主题。其中，`themes/[主题的名称]` 的优先级高于 `node_modules/hexo-theme-[主题的名称]`。也就是说，只有当 Hexo 发现 `themes/[主题的名称]` 目录不存在时，才会从 `node_modules/hexo-theme-[主题的名称]` 目录中加载主题。\n- Hexo 5.0.0 新增了通过站点根目录下 `_config.[主题的名称].yml` 文件配置主题的功能。这是除主题目录下的 `_config.yml` 文件、以及站点配置文件的 `theme_config` 字段外第三种配置主题的方式。\n- 为保证向后兼容性，Hexo 会按照如下优先级 deep merge 三份主题配置：`站点配置文件的 theme_config 字段 > 站点根目录下的 _config.[主题的名称].yml > 主题目录下的 _config.yml`。因此，我们建议主题开发者尽量限制配置文件层级为 1 级，避免在 deep merge 时更深层级的配置项会被合并而不是被覆盖。\n\n## PrismJS 代码高亮支持\n\nHexo 5.0.0 新增了 PrismJS 代码高亮支持。\n\n相比 highlight.js 可以在 Node.js 环境执行（即：可在 Hexo 生成页面时进行代码高亮）不同，PrismJS 是一个轻量级的代码高亮库，绝大部分插件都依赖浏览器中执行。Hexo 为了尽可能兼容 PrismJS 的功能和插件，提供了「生成时渲染」和「浏览器渲染」两种模式：前者只需在主题之中引入 PrismJS 的 CSS 即可，但是无法使用大部分 PrismJS 的插件；后者需要在主题中同时引入 PrismJS 的 CSS 和 `prism.js`，但是可以兼容 PrismJS 大部分插件。\n\n关于 Hexo 主题的开发者适配 Hexo 的两种代码高亮的技术细节，我们专门撰写了 [相关的文档页面](https://hexo.io/docs/syntax-highlight) 以供参考。\n\n## 静态 HTML 片段插入\n\n插件开发者经常需要在页面中插入 HTML 片段：播放器插件需要往页面中插入 `player.css` 和 `player.js`，lazyload 插件的作者需要往页面中插入 `lazyload.js`，Live2D 插件的作者需要往页面中插入对应的 CSS 和 JS，等等。Hexo 5.0.0 新增了一个插件 API 接口 Injector，用于往页面的 `<head>` 和 `<body>` 标签中注入静态 HTML 片段。这一功能支持：\n\n- 在 `<head>` 之后、`</head>` 之前、`<body>` 之后 和 `</body>` 之前四个位置插入代码。\n- 支持只在特定页面注入 HTML 片段 —— 插件开发者可以仅往文章页面插入 HTML 片段而不影响其他页面如首页和归档。\n- 插件开发者请参考 Hexo 的 [Injector API 文档] 了解具体使用方法。\n\n## 其他新特性\n\n除上述三个重磅功能外，Hexo 还新增了其他功能，如：\n\n- 标签插件 API 新增 `unregister` 方法\n- `tagcloud` 辅助函数新增支持自定义 class 属性和 level\n- `feed_tag` 辅助函数增加对 hexo-generator-feed 插件的兼容\n- `youtube` 标签插件新增对 YouTube 播放列表的支持，以及可选使用 `www.youtube-nocookie.com` 域名\n- `post_link` 标签插件在找不到对应文章时将会显示警告信息\n- `post_permalink` 配置项新增支持 :second 属性\n- 当文章的标签插件出现渲染错误时，报错信息将会显示出错文件的路径\n\n# 修复的 Bug\n\n- 修复了 数个相邻的标签插件 无法渲染的 Bug\n- 修复了 文章中的代码块由于包含大括号（`{` 和 `}`）导致的渲染失败\n- 修复了 包含 Source Map 的 Hexo 插件无法加载的 Bug\n- 修复了 code 标签插件无法解析 `wrap` 选项的问题\n- 当 `post_asset_folder` 功能启用时，`hexo new` 命令将不再生成错误的 `index` 目录\n\n# 性能改进\n\n一如既往，Hexo 5.0.0 也带来了一系列性能改进，以提升 Hexo 的渲染性能。\n\n- 改进了标签插件的渲染性能\n- 优化了 `meta[generator]` 标签注入的逻辑\n- 优化为外部链接添加 `rel=noopenner` 和 `target=\"_blank\"` 功能的性能\n- 确保 `after_render:html` Filter 在每个页面只执行一次\n- 优化了 Filter API 的执行速度\n- 延迟加载代码高亮，减少 Hexo 启动用时\n- 当执行 `hexo clean` 时不再加载无关的插件\n\n# 从 Hexo 4.x 升级到 Hexo 5.x\n\nHexo 5.0.0 引入了少数不向后兼容的功能，因此当你升级到 Hexo 5.0.0 时，需要遵循以下步骤进行迁移：\n\n## 升级 Node.js\n\nHexo 5.0.0 不再支持 Node.js 8 及更低版本。为了使用 Hexo 5.0.0，请确保 Node.js 版本不低于 10.13.0。\n\n## 文章 Front-Matter 不再支持 keywords 字段\n\n过去这一字段被主要用于 `open_graph` 辅助函数。升级到 Hexo 5.0.0 后你无需去除现有文章的 Front-Matter 中的 `keywords` 字段，但这一字段将不会再起任何作用。\n\n## 文章 Front-Matter 中 permalink 字段的行为\n\nHexo 5.0.0 修改了在文章的 Front Matter 中指定 `permalink` 字段的行为，与独立页面的 `permalink` 的行为一致。\n\n## 全局变量中不再包含 Lodash\n\nHexo 5.0.0 去除了全局变量中的 Lodash，因此主题无法继续在模板中使用 Lodash。主题开发者应该遵循 [You-Dont-Need-Lodash-Underscore](https://github.com/you-dont-need/You-Dont-Need-Lodash-Underscore) 进行迁移。\n\n## 用 updated_option 配置代替 use_date_for_updated\n\nHexo 4.0.0 提供的 `use_date_for_updated` 配置项现已被 `updated_option` 替代。\n\n`use_date_for_updated: true` 现在等价于 `updated_option: 'date'`。\n`use_date_for_updated: false` 现在等价于 `updated_option: 'mtime'`。\n","categories":["转载"]},{"title":"JUnit 5 教程","url":"/articles/cherry/junit-5-info/","content":"\nJUnit 5 作为新一代的 Java 单元测试框架，提供很多改进。例如对比 [JUnit4](https://junit.org/junit4/) 与 [JUnit5](https://junit.org/junit5/) 的官网，JUnit5 的设计更加简约与时尚，至少不会抗拒阅读的程度了（像破烂一样的网站，看了整个人都难受，不影响效率？不存在的）\n\n![](https://jiangtj-lab.github.io/pic-repo/img-apricot/20200116113048.png)\n\n而且，除此外，他的文档使用了 Asciidoc， 相对于markdown复杂，主要是它还支持具有包含另一个文件内容，这对于写API文档来说挺重要的，有兴趣可以了解下~\n\nOkay， 结束吐槽，让我来看看 JUnit5 到底带来了哪些变化吧\n\n<!-- more -->\n\n# JUnit 5 是什么？\n\n与以往的版本不同，JUnit5 由三个模块模版组成  JUnit Platform + JUnit Jupiter + JUnit Vintage\n\n- JUnit Platform：运行测试框架的基础服务，定义了一套API，任何实现这套API的测试引擎，都能运行在这之上\n- JUnit Jupiter：一系列用于编写JUnit5测试或者扩展的组合，同时他的子项目提供了JUnit5测试引擎\n- JUnit Vintage：提供 JUnit3 和 JUnit4 的测试引擎\n\n# 三分钟教程\n\n## 环境搭建\n\n1. 创建你的项目（建议Spring Boot），简单的勾选几个依赖\n![](https://jiangtj-lab.github.io/pic-repo/img-apricot/20200116131303.png)\n\n2. 添加 JUnit5 的依赖（spring boot 2.2 中已默认是Junit5，不需要额外加，详见[WIKI](https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.2-Release-Notes#junit-5)），\n```xml\n    <dependency>\n      <groupId>org.junit.jupiter</groupId>\n      <artifactId>junit-jupiter</artifactId>\n      <version>${latest-version}</version>\n      <scope>test</scope>\n    </dependency>\n```\n`org.junit.jupiter:junit-jupiter`已包含了 JUnit Platform，不需要额外声明依赖，一个就够了\n![](https://jiangtj-lab.github.io/pic-repo/img-apricot/20200116133004.png)\n\n## 第一个测试用例\n\n1. 创建一个待测试的工具类\n```java\npublic class TimeUtils {\n    public static String hello(Instant now) {\n        return \"现在时间是：\" + now.toString();\n    }\n}\n```\n\n2. 创建测试用例\n```java\nclass TimeUtilsTest {\n    @Test\n    void hello() {\n        Instant now = Instant.now();\n        String expect = \"现在时间是：\" + now.toString();\n        assertEquals(expect, TimeUtils.hello(now));\n    }\n}\n```\n\n3. 运行测试用例，如果你使用idea，那么直接点旁边的运行按钮，或者使用其它编辑器的功能测试，当然，你还可以选择通过命令行，下载[junit-platform-console-standalone](https://repo1.maven.org/maven2/org/junit/platform/junit-platform-console-standalone/)，并运行它(不懂)，另一种是`mvn test`运行测试\n\n# 更多食用方案\n\n## 别名\n\n测试的Class可以通过添加@DisplayName()，添加别名\n\n```java\n@DisplayName(\"时间工具类测试\")\nclass TimeUtilsTest {}\n```\n\n也可以使用@DisplayNameGeneration()，进行更多的配置\n\n```java\n@DisplayNameGeneration(TimeUtils2Test.ReplaceUnderscores.class)\nclass TimeUtils2Test {\n    @Test\n    void hello() {\n        Instant now = Instant.now();\n        String expect = \"现在时间是：\" + now.toString();\n        assertEquals(expect, TimeUtils.hello(now));\n    }\n    static class ReplaceUnderscores extends DisplayNameGenerator.ReplaceUnderscores {\n        @Override\n        public String generateDisplayNameForClass(Class<?> testClass) {\n            return \"哈哈哈\";\n        }\n    }\n}\n```\n\n## 断言、假设\n\n测试中核心之一，用于判断是否执行成功，在JUnit5中增加了些对lambdas的支持，例如：\n\n```java\n    @Test\n    void asserts() {\n        assertEquals(1,2, () -> \"1要是1\");\n    }\n```\n\n另外，还增加了假设\n\n```java\n    @Test\n    void assume() {\n        assumingThat(\"DEV\".equals(System.getenv(\"ENV\")),\n                () -> {\n                    // 如果不为true这里将不执行\n                    assertEquals(1, 1);\n                });\n\n        assumeTrue(\"DEV\".equals(System.getenv(\"ENV\")),\n                () -> \"Aborting test: not on developer workstation\");\n        // 如果不为true这里将不执行\n    }\n```\n\n## 禁用\n\n添加@Disabled()可以禁用测试，这个意义在于某一测试用例遇到问题，临时不执行，等待问题修复后再次使用的\n\n```java\n@Disabled(\"Disabled 因为重复\")\nclass TimeUtilsCopyTest {}\n```\n\n## 测试执行条件\n\n通过添加 @EnabledOnOs 或者 @DisabledOnOs 来决定在某一操作系统上执行.\n\n```java\n    @Test\n    @EnabledOnOs(MAC)\n    void testOnMac() {\n        log.info(\"exec on mac\");\n    }\n    @Test\n    @EnabledOnOs({ WINDOWS, LINUX })\n    void testOnOs() {\n        log.info(\"exec on windows or linux\");\n    }\n```\n\n@EnabledOnJre 和 @DisabledOnJre 可以对java环境判断\n\n```java\n    @Test\n    @EnabledOnJre(JRE.JAVA_8)\n    void testOnJava8() {\n        log.info(\"exec on java 8\");\n    }\n```\n\n@EnabledIfSystemProperty/@DisabledIfSystemProperty 与  @EnabledIfEnvironmentVariable/@DisabledIfEnvironmentVariable 分别判断系统和环境变量，他们的匹配项支持正则表达式\n\n```java\n@Test\n@DisabledIfEnvironmentVariable(named = \"ENV\", matches = \".*development.*\")\nvoid notOnDeveloperWorkstation() {\n    // ...\n}\n```\n\n## 标签/分组\n\nJUnit5 中支持通过 @Tag() 对测试用例进行分组，例如\n\n```java\n    @Tag(\"conditional\")\n    @Test\n    @EnabledOnOs(MAC)\n    void testOnMac() {\n        log.info(\"exec on mac\");\n    }\n    @Tag(\"conditional\")\n    @Test\n    @EnabledOnJre(JRE.JAVA_8)\n    void testOnJava8() {\n        log.info(\"exec on java 8\");\n    }\n```\n\n@Tag() 有以下这些语法规则\n- 不能为null或者空字符串\n- 不能有空格\n- 不能包含ISO控制符\n- 不能包含保留字符(`,`,`(`,`)`,`&`,`|`,`!`)\n\n## 顺序\n\n添加@TestMethodOrder(MethodOrderer.OrderAnnotation.class)与@Order()，定义测试用例的执行顺序\n\n```java\n@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\npublic class OrderedTest {\n    @Test\n    @Order(2)\n    void emptyValues() {\n        // perform assertions against empty values\n    }\n    @Test\n    @Order(1)\n    void nullValues() {\n        // perform assertions against null values\n    }\n    @Test\n    @Order(3)\n    void validValues() {\n        // perform assertions against valid values\n    }\n}\n```\n\n## 生命周期\n\nJUnit5 提供了4个生命周期注解 @BeforeAll @AfterAll @BeforeEach @AfterEach\n\n- @BeforeAll：在所有的 @Test @RepeatedTest @ParameterizedTest @TestFactory 之前执行\n- @BeforeEach：在每个测试用例前执行\n- @AfterAll @AfterEach：与before类似，在测试用例之后执行\n\n例如：\n\n```java\n@Slf4j\n@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n@TestInstance(TestInstance.Lifecycle.PER_CLASS)\npublic class LifecycleTest {\n    int num = 0;\n    @BeforeAll\n    static void initAll() {\n        log.error(\"initAll\");\n    }\n    @BeforeEach\n    void init() {\n        log.error(\"init\");\n    }\n    @Test\n    @Order(1)\n    void doTest1() {\n        log.error(\"num is \" + num);\n        num = 1;\n        log.error(\"doTest1\");\n    }\n    @Test\n    @Order(2)\n    void doTest2() {\n        log.error(\"num is \" + num);\n        num = 2;\n        log.error(\"doTest1\");\n    }\n}\n```\n\n除此外，还有@TestInstance()配置，见上面的例子，这个存在两个模式\n\n- PER_METHOD：每个测试用例执行前，都会创建一个实例（默认，与junit4一致）\n- PER_CLASS：每个类的测试用例执行前，创建统一的实例\n\n上面的例子中，得到的log为：\n\n```log\n13:58:03.477 [main] ERROR com.jiangtj.example.junit5.LifecycleTest - initAll\n13:58:03.485 [main] ERROR com.jiangtj.example.junit5.LifecycleTest - init\n13:58:03.487 [main] ERROR com.jiangtj.example.junit5.LifecycleTest - num is 0\n13:58:03.487 [main] ERROR com.jiangtj.example.junit5.LifecycleTest - doTest1\n13:58:03.494 [main] ERROR com.jiangtj.example.junit5.LifecycleTest - init\n13:58:03.495 [main] ERROR com.jiangtj.example.junit5.LifecycleTest - num is 1\n13:58:03.495 [main] ERROR com.jiangtj.example.junit5.LifecycleTest - doTest1\n```\n\n`doTest1()` 的执行，影响到num属性的值，而默认模式下则不会\n\n## 嵌套\n\n@Nested() 可以更好的表达测试用例间的关系，例如官方的例子\n\n```java\n@DisplayName(\"A stack\")\nclass TestingAStackDemo {\n\n    Stack<Object> stack;\n\n    @Test\n    @DisplayName(\"is instantiated with new Stack()\")\n    void isInstantiatedWithNew() {\n        new Stack<>();\n    }\n\n    @Nested\n    @DisplayName(\"when new\")\n    class WhenNew {\n\n        @BeforeEach\n        void createNewStack() {\n            stack = new Stack<>();\n        }\n\n        @Test\n        @DisplayName(\"is empty\")\n        void isEmpty() {\n            assertTrue(stack.isEmpty());\n        }\n\n        @Test\n        @DisplayName(\"throws EmptyStackException when popped\")\n        void throwsExceptionWhenPopped() {\n            assertThrows(EmptyStackException.class, stack::pop);\n        }\n\n        @Test\n        @DisplayName(\"throws EmptyStackException when peeked\")\n        void throwsExceptionWhenPeeked() {\n            assertThrows(EmptyStackException.class, stack::peek);\n        }\n\n        @Nested\n        @DisplayName(\"after pushing an element\")\n        class AfterPushing {\n\n            String anElement = \"an element\";\n\n            @BeforeEach\n            void pushAnElement() {\n                stack.push(anElement);\n            }\n\n            @Test\n            @DisplayName(\"it is no longer empty\")\n            void isNotEmpty() {\n                assertFalse(stack.isEmpty());\n            }\n\n            @Test\n            @DisplayName(\"returns the element when popped and is empty\")\n            void returnElementWhenPopped() {\n                assertEquals(anElement, stack.pop());\n                assertTrue(stack.isEmpty());\n            }\n\n            @Test\n            @DisplayName(\"returns the element when peeked but remains not empty\")\n            void returnElementWhenPeeked() {\n                assertEquals(anElement, stack.peek());\n                assertFalse(stack.isEmpty());\n            }\n        }\n    }\n}\n```\n\n我们可以清晰的看到他们之间的关系\n\n![](https://jiangtj-lab.github.io/pic-repo/img-apricot/20200117141500.png)\n\n## 重复测试\n\n@RepeatedTest() 执行多次测试，支持name修改名称（具体见官网，觉得没多大意义），另外可以在方法中获取repetitionInfo参数，用于判断当前的执行情况（JUnit5支持注入参数，后续详说）\n\n```java\n@Slf4j\nclass RepeatedTestsDemo {\n    @RepeatedTest(2)\n    void repeatedTest() {\n        log.info(\"done!\");\n    }\n    @RepeatedTest(2)\n    void repeatedTest2(RepetitionInfo repetitionInfo) {\n        int currentRepetition = repetitionInfo.getCurrentRepetition();\n        int totalRepetitions = repetitionInfo.getTotalRepetitions();\n        log.info(String.format(\"About to execute repetition %d of %d\", //\n                currentRepetition, totalRepetitions));\n    }\n}\n```\n\n## 参数测试\n\n@ParameterizedTest 很实用的注解，需要`junit-jupiter-params`依赖（我们已经添加了）\n\n它主要是配置@xxxSource，注入参数，以完成测试，参数的注入方式有多种\n\n### 数据源\n\n@ValueSource 注入String内容，这是最常用的\n\n```java\n    @ParameterizedTest\n    @ValueSource(strings = { \"racecar\", \"radar\", \"able was I ere I saw elba\" })\n    void palindromes(String candidate) {\n        log.error(candidate);\n    }\n```\n\n@EnumSource 注入枚举类\n\n```java\n    @ParameterizedTest\n    @EnumSource(TimeUnit.class)\n    void testWithEnumSource(TimeUnit timeUnit) {\n        log.error(timeUnit.toString());\n    }\n    @ParameterizedTest\n    @EnumSource(value = TimeUnit.class, names = { \"DAYS\", \"HOURS\" })\n    void testWithEnumSourceInclude(TimeUnit timeUnit) {\n        // 选择部分\n        log.error(timeUnit.toString());\n    }\n```\n\n@MethodSource 通过方法名注入（我更倾向于使用下面的@ArgumentsSource）\n\n```java\n    @ParameterizedTest\n    @MethodSource(\"stringProvider\")\n    void testWithExplicitLocalMethodSource(String argument) {\n        log.error(argument);\n    }\n    static Stream<String> stringProvider() {\n        return Stream.of(\"apple\", \"banana\");\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"stringIntAndListProvider\")\n    void testWithMultiArgMethodSource(String str, int num, List<String> list) {\n        // 多参支持\n        log.error(String.format(\"Content: %s is %d, %s\", str, num, String.join(\",\", list)));\n    }\n    static Stream<Arguments> stringIntAndListProvider() {\n        return Stream.of(\n                arguments(\"apple\", 1, Arrays.asList(\"a\", \"b\")),\n                arguments(\"lemon\", 2, Arrays.asList(\"x\", \"y\"))\n        );\n    }\n```\n\n@CsvSource csv源支持\n\n```java\n    @ParameterizedTest\n    @CsvSource({\n            \"apple,         1\",\n            \"banana,        2\",\n            \"'lemon, lime', 0xF1\"\n    })\n    void testWithCsvSource(String fruit, int rank) {\n        log.error(fruit + rank);\n    }\n```\n\n它也支持从文件导入，例如`@CsvFileSource(resources = \"/two-column.csv\", numLinesToSkip = 1)`\n\n@ArgumentsSource 通过自定义的参数提供器导入\n\n```java\n    @ParameterizedTest\n    @ArgumentsSource(MyArgumentsProvider.class)\n    void testWithArgumentsSource(String argument) {\n        log.error(argument);\n    }\n    static class MyArgumentsProvider implements ArgumentsProvider {\n        @Override\n        public Stream<? extends Arguments> provideArguments(ExtensionContext context) {\n            return Stream.of(\"apple\", \"banana\").map(Arguments::of);\n        }\n    }\n```\n\n### 参数转换\n\n为了支持csv，JUnit支持了些内建的转换，详细见文档[writing-tests-parameterized-tests-argument-conversion](https://junit.org/junit5/docs/current/user-guide/#writing-tests-parameterized-tests-argument-conversion)，如果转换失败，会寻找构造器或者静态构造方法（非私有）中，单String的方法，来转换对应的对象\n\n> 内建的转换有必要，但后一种，我宁愿得到报错，而不是转换，隐形的转换往往会导致莫名的问题出现\n\n所以推荐通过@ConvertWith实现参数类型间的转换\n\n```java\n    @ParameterizedTest\n    @ValueSource(strings = { \"Wow,12\", \"radar,50\"})\n    void toBook(@ConvertWith(ToBookConverter.class) Book book) {\n        log.error(book.toString());\n    }\n    static class ToBookConverter extends SimpleArgumentConverter {\n        @Override\n        protected Object convert(Object source, Class<?> targetType) {\n            String value = String.valueOf(source);\n            String[] split = value.split(\",\");\n            return Book.of(split[0], Integer.parseInt(split[1]));\n        }\n    }\n```\n\nJUnit中也内置了些转换，如@JavaTimeConversionPattern等\n\n除外，还可以通过@AggregateWith转换或者接收ArgumentsAccessor对象\n\n## Dynamic测试\n\n除了常规的@Test,我们还可以通过@TestFactory来构建整个测试树\n\n```java\nclass DynamicTestsDemo {\n\n    private final Calculator calculator = new Calculator();\n\n    // This will result in a JUnitException!\n    @TestFactory\n    List<String> dynamicTestsWithInvalidReturnType() {\n        return Arrays.asList(\"Hello\");\n    }\n\n    @TestFactory\n    Collection<DynamicTest> dynamicTestsFromCollection() {\n        return Arrays.asList(\n            dynamicTest(\"1st dynamic test\", () -> assertTrue(isPalindrome(\"madam\"))),\n            dynamicTest(\"2nd dynamic test\", () -> assertEquals(4, calculator.multiply(2, 2)))\n        );\n    }\n\n    @TestFactory\n    Iterable<DynamicTest> dynamicTestsFromIterable() {\n        return Arrays.asList(\n            dynamicTest(\"3rd dynamic test\", () -> assertTrue(isPalindrome(\"madam\"))),\n            dynamicTest(\"4th dynamic test\", () -> assertEquals(4, calculator.multiply(2, 2)))\n        );\n    }\n\n    @TestFactory\n    Iterator<DynamicTest> dynamicTestsFromIterator() {\n        return Arrays.asList(\n            dynamicTest(\"5th dynamic test\", () -> assertTrue(isPalindrome(\"madam\"))),\n            dynamicTest(\"6th dynamic test\", () -> assertEquals(4, calculator.multiply(2, 2)))\n        ).iterator();\n    }\n\n    @TestFactory\n    DynamicTest[] dynamicTestsFromArray() {\n        return new DynamicTest[] {\n            dynamicTest(\"7th dynamic test\", () -> assertTrue(isPalindrome(\"madam\"))),\n            dynamicTest(\"8th dynamic test\", () -> assertEquals(4, calculator.multiply(2, 2)))\n        };\n    }\n\n    @TestFactory\n    Stream<DynamicTest> dynamicTestsFromStream() {\n        return Stream.of(\"racecar\", \"radar\", \"mom\", \"dad\")\n            .map(text -> dynamicTest(text, () -> assertTrue(isPalindrome(text))));\n    }\n\n    @TestFactory\n    Stream<DynamicTest> dynamicTestsFromIntStream() {\n        // Generates tests for the first 10 even integers.\n        return IntStream.iterate(0, n -> n + 2).limit(10)\n            .mapToObj(n -> dynamicTest(\"test\" + n, () -> assertTrue(n % 2 == 0)));\n    }\n\n    @TestFactory\n    Stream<DynamicTest> generateRandomNumberOfTests() {\n\n        // Generates random positive integers between 0 and 100 until\n        // a number evenly divisible by 7 is encountered.\n        Iterator<Integer> inputGenerator = new Iterator<Integer>() {\n\n            Random random = new Random();\n            int current;\n\n            @Override\n            public boolean hasNext() {\n                current = random.nextInt(100);\n                return current % 7 != 0;\n            }\n\n            @Override\n            public Integer next() {\n                return current;\n            }\n        };\n\n        // Generates display names like: input:5, input:37, input:85, etc.\n        Function<Integer, String> displayNameGenerator = (input) -> \"input:\" + input;\n\n        // Executes tests based on the current input value.\n        ThrowingConsumer<Integer> testExecutor = (input) -> assertTrue(input % 7 != 0);\n\n        // Returns a stream of dynamic tests.\n        return DynamicTest.stream(inputGenerator, displayNameGenerator, testExecutor);\n    }\n\n    @TestFactory\n    Stream<DynamicNode> dynamicTestsWithContainers() {\n        return Stream.of(\"A\", \"B\", \"C\")\n            .map(input -> dynamicContainer(\"Container \" + input, Stream.of(\n                dynamicTest(\"not null\", () -> assertNotNull(input)),\n                dynamicContainer(\"properties\", Stream.of(\n                    dynamicTest(\"length > 0\", () -> assertTrue(input.length() > 0)),\n                    dynamicTest(\"not empty\", () -> assertFalse(input.isEmpty()))\n                ))\n            )));\n    }\n\n    @TestFactory\n    DynamicNode dynamicNodeSingleTest() {\n        return dynamicTest(\"'pop' is a palindrome\", () -> assertTrue(isPalindrome(\"pop\")));\n    }\n\n    @TestFactory\n    DynamicNode dynamicNodeSingleContainer() {\n        return dynamicContainer(\"palindromes\",\n            Stream.of(\"racecar\", \"radar\", \"mom\", \"dad\")\n                .map(text -> dynamicTest(text, () -> assertTrue(isPalindrome(text)))\n        ));\n    }\n\n}\n```\n\n还未看过源码，但目测@Test是由内建的转换器，转换成DynamicNode，然后再执行。使用@TestFactory，tree型的代码也是种选择，再维护上，不差于@Test的常规方案\n\n# 扩展\n\n与 Junit4 不同，Junit5 提供了一个统一的一个扩展API。不过在之前，先看下另一个 Junit5 的重要特性--组合注解\n\n## 组合注解\n\n在官方文档中，这部分与注解部分一同讲的，但我将它移到此处，因为绝大多数情况下，他都是与扩展API一同使用。\n\n组合注解，顾名思义，当一个注解上存在其他的Junit注解时，同时也继承这些注解的语义\n\n例如：组合Tag与Test注解\n\n```java\n@Target({ ElementType.TYPE, ElementType.METHOD })\n@Retention(RetentionPolicy.RUNTIME)\n@Tag(\"fast\")\n@Test\npublic @interface Fast {\n}\n```\n\n```java\n@Fast\nvoid asserts() {\n    assertTrue(true);\n}\n```\n\n## Extend API\n\n在 Junit5 中通过 `@ExtendWith` 注解实现添加扩展。\n\n```java\n@ExtendWith(DatabaseExtension.class)\npublic class SimpleTest {\n  // code\n}\n```\n\n```java\n@Slf4j\npublic class DatabaseExtension implements BeforeAllCallback, AfterAllCallback {\n    @Override\n    public void beforeAll(ExtensionContext extensionContext) throws Exception {\n        log.info(\"连接数据库\");\n    }\n    @Override\n    public void afterAll(ExtensionContext extensionContext) throws Exception {\n        log.info(\"关闭数据库\");\n    }\n}\n```\n\n`@ExtendWith` 提供了扩展的入口，具体的实现通过实现对应的接口，例如上面的 `DatabaseExtension` 实现 `BeforeAllCallback`，`AfterAllCallback`\n\n在Junit中，存在许多扩展接口\n\n### ExecutionCondition\n\n定义执行条件，满足条件时才能执行，下面是一个例子\n\n```java\n@Target({ ElementType.TYPE, ElementType.METHOD })\n@Retention(RetentionPolicy.RUNTIME)\n@ExtendWith(PassConditionalExtension.class)\n@Test\npublic @interface Pass {\n    String value();\n}\n```\n\n```java\npublic class PassConditionalExtension implements ExecutionCondition {\n    @Override\n    public ConditionEvaluationResult evaluateExecutionCondition(ExtensionContext context) {\n        return AnnotationUtils.findAnnotation(context.getElement(), Pass.class)\n                .map(Pass::value)\n                .filter(\"我很帅\"::equals)\n                .map(item -> ConditionEvaluationResult.enabled(\"pass\"))\n                .orElse(ConditionEvaluationResult.disabled(\"pass is not okay!\"));\n    }\n}\n```\n\n```java\npublic class ConditionalTest {\n    @Pass(\"密码不对不执行\")\n    void notExec() {\n        // code...\n    }\n    @Pass(\"我很帅\")\n    void exec() {\n        // code...\n    }\n}\n```\n\n### TestInstanceFactory\n\n定义测试实例，只能用于class上，暂时想不到例子，跳过~~\n\n### TestInstancePostProcessor\n\n对测试实例处理，通常用于注入依赖，暂时想不到例子，跳过~~\n\n### TestInstancePreDestroyCallback\n\n当测试实例销毁前调用，暂时想不到例子，跳过~~\n\n### ParameterResolver\n\n处理参数，见下面例子\n\n```java\n@Target(ElementType.PARAMETER)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface BookInject {\n    String title();\n    int price() default 0;\n}\n```\n\n```java\npublic class BookParameterResolver implements ParameterResolver {\n    @Override\n    public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) throws ParameterResolutionException {\n        return parameterContext.isAnnotated(BookInject.class);\n    }\n    @Override\n    public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext) throws ParameterResolutionException {\n        return parameterContext.findAnnotation(BookInject.class)\n                .map(book -> Book.of(book.title(), book.price()))\n                .orElse(null);\n    }\n}\n```\n\n```java\n@Slf4j\npublic class BookParameterTest {\n    @Test\n    @ExtendWith(BookParameterResolver.class)\n    void exec(@BookInject(title = \"删库\") Book book) {\n        log.info(book.toString());\n    }\n}\n```\n\n### TestWatcher\n\n监听测试用例的执行结果\n\n```java\n@Slf4j\npublic class LogTestWatcher implements TestWatcher {\n    @Override\n    public void testSuccessful(ExtensionContext context) {\n        log.info(\"wow, 成功了！\");\n    }\n    @Override\n    public void testAborted(ExtensionContext context, Throwable cause) {\n        // 终止\n    }\n    @Override\n    public void testDisabled(ExtensionContext context, Optional<String> reason) {\n        // 取消（跳过）\n    }\n    @Override\n    public void testFailed(ExtensionContext context, Throwable cause) {\n        // 失败\n    }\n}\n```\n\n### 生命周期回调\n\n在一开始的例子中就是生命周期的回调，这里不写例子拉，他们执行的先后顺序如下\n\n- BeforeAllCallback\n  - BeforeEachCallback\n    - BeforeTestExecutionCallback\n    - AfterTestExecutionCallback\n  - AfterEachCallback\n- AfterAllCallback\n\n### TestExecutionExceptionHandler\n\n处理异常，如果存在一些自定义的运行时异常，这是很有用的，可以做些处理\n\n```java\npublic class IgnoreExceptionExtension implements TestExecutionExceptionHandler {\n    @Override\n    public void handleTestExecutionException(ExtensionContext context, Throwable throwable) throws Throwable {\n        if (throwable instanceof Exception) {\n            return;\n        }\n        throw throwable;\n    }\n}\n```\n\n```java\npublic class SimpleTest {\n    @Test\n    @ExtendWith(IgnoreExceptionExtension.class)\n    void exec2() throws Exception {\n        throw new Exception(\"被忽略\");\n    }\n    @Test\n    @ExtendWith(IgnoreExceptionExtension.class)\n    void exec3() throws Throwable {\n        throw new Throwable(\"不被忽略\");\n    }\n}\n```\n\n### Intercepting Invocations\n\n拦截测试方法，类似于 Spring 中的 AOP\n\n```java\n@Slf4j\n@ExtendWith(MyInvocationInterceptorTest.LogInvocationInterceptor.class)\npublic class MyInvocationInterceptorTest {\n\n    @ParameterizedTest\n    @ValueSource(strings = { \"racecar\", \"radar\", \"able was I ere I saw elba\" })\n    void showParameterized(String candidate) {\n        log.error(candidate);\n    }\n\n\n    static class LogInvocationInterceptor implements InvocationInterceptor {\n        @Override\n        public void interceptTestTemplateMethod(Invocation<Void> invocation,\n                                                ReflectiveInvocationContext<Method> invocationContext,\n                                                ExtensionContext extensionContext) throws Throwable {\n            Method executable = invocationContext.getExecutable();\n            List<Object> arguments = invocationContext.getArguments();\n            Class<?> targetClass = invocationContext.getTargetClass();\n            log.info(\"executable method: \" + executable.getName());\n            log.info(\"arguments: \" + arguments.stream().map(String::valueOf).collect(Collectors.joining()));\n            log.info(\"targetClass: \" + targetClass.getName());\n            log.info(\"invocation.proceed() start\");\n            invocation.proceed();\n            log.info(\"invocation.proceed() end\");\n        }\n    }\n}\n```\n\nInvocationInterceptor 中有多个方法 `interceptBeforeAllMethod` `interceptTestMethod` `interceptTestTemplateMethod` 等，分别在不同的时候拦截，里中 `@ParameterizedTest` 继承 `@TestTemplate` 所以使用 `interceptTestTemplateMethod`\n\n拦截器中一般会传入这几个变量：\n- invocation: 测试请求，只有`proceed()`代表执行\n- invocationContext: 测试请求的上下文\n- extensionContext: 扩展的上下文\n\n### 为 Test Templates 提供上下文\n\n上面提到了 `@ParameterizedTest` 是由 `@TestTemplate`， 而 `@TestTemplate` 至少需要一个 `TestTemplateInvocationContextProvider` 提供时执行，在 `@ParameterizedTest` 中我们可以看到，`@ParameterizedTest` 由 `ParameterizedTestExtension.class` 提供测试的参数\n\n```java\n@TestTemplate\n@ExtendWith(ParameterizedTestExtension.class)\npublic @interface ParameterizedTest {\n  // ...\n}\n```\n\n所以，相对于我写例子，直接学习它的源码可能更好，这是真实的案例，下面是 `ParameterizedTestExtension.class` 部分内容\n\n```java\nclass ParameterizedTestExtension implements TestTemplateInvocationContextProvider {\n\n  private static final String METHOD_CONTEXT_KEY = \"context\";\n\n  // 在 TestTemplateInvocationContextProvider 提供两个方法，这是其中一个\n  // 用于判断是否支持该扩展，例如下面两判断分别是不存在测试方法与不存在注解@ParameterizedTest时不执行（按道理不能能出现的情况。。。）\n  @Override\n  public boolean supportsTestTemplate(ExtensionContext context) {\n    if (!context.getTestMethod().isPresent()) {\n      return false;\n    }\n    Method testMethod = context.getTestMethod().get();\n    if (!isAnnotated(testMethod, ParameterizedTest.class)) {\n      return false;\n    }\n\n    ParameterizedTestMethodContext methodContext = new ParameterizedTestMethodContext(testMethod);\n    Preconditions.condition(methodContext.hasPotentiallyValidSignature(),\n      () -> String.format(\n        \"@ParameterizedTest method [%s] declares formal parameters in an invalid order: \"\n            + \"argument aggregators must be declared after any indexed arguments \"\n            + \"and before any arguments resolved by another ParameterResolver.\",\n        testMethod.toGenericString()));\n    getStore(context).put(METHOD_CONTEXT_KEY, methodContext);\n    return true;\n  }\n\n\n  // 这是另一个方法\n  // 提供测试的参数\n  // 返回一个Stream，简单的样式是 Stream.of(invocationContext(\"apple\"), invocationContext(\"banana\"));\n  // ParameterizedTestExtension中比较复杂，大概是 获取提供值(获取参数提供器 -> 消费注解) -> 获取并消费参数 -> 构建InvocationContext\n  @Override\n  public Stream<TestTemplateInvocationContext> provideTestTemplateInvocationContexts(ExtensionContext extensionContext) {\n\n    Method templateMethod = extensionContext.getRequiredTestMethod();\n    String displayName = extensionContext.getDisplayName();\n    ParameterizedTestMethodContext methodContext = getStore(extensionContext)//\n        .get(METHOD_CONTEXT_KEY, ParameterizedTestMethodContext.class);\n    ParameterizedTestNameFormatter formatter = createNameFormatter(templateMethod, displayName);\n    AtomicLong invocationCount = new AtomicLong(0);\n\n    // @formatter:off\n    return findRepeatableAnnotations(templateMethod, ArgumentsSource.class)\n        .stream()\n        .map(ArgumentsSource::value)\n        .map(this::instantiateArgumentsProvider)\n        .map(provider -> AnnotationConsumerInitializer.initialize(templateMethod, provider))\n        .flatMap(provider -> arguments(provider, extensionContext))\n        .map(Arguments::get)\n        .map(arguments -> consumedArguments(arguments, methodContext))\n        .map(arguments -> createInvocationContext(formatter, methodContext, arguments))\n        .peek(invocationContext -> invocationCount.incrementAndGet())\n        .onClose(() ->\n            Preconditions.condition(invocationCount.get() > 0,\n                \"Configuration error: You must configure at least one set of arguments for this @ParameterizedTest\"));\n    // @formatter:on\n  }\n\n  // ...\n\n}\n\n```\n\n### 在扩展中保持状态\n\n熟悉前端的知道在 vue 或者 react 中都会涉及到状态 state 的保持，在junit 5 中也提供了类似的API `Store` （连名字都差不多。。。），大致上你可以理解为Map这类的东西，在 `ParameterizedTestExtension` 中也使用它存储了 `METHOD_CONTEXT_KEY`\n\n# 在 Spring 中的使用\n\n> 未完待续\n\n# 最后\n\n一个疑问，JUnit5 的注解风格和 Spring 为何如此接近。。。\n\n- 例子源码：https://github.com/jiangtj-lab/junit5-demo\n","categories":["后端"],"tags":["Test","Unit Test","JUnit"]},{"title":"linux 代理","url":"/articles/cherry/linux-proxy/","content":"\n# env\n\n```bash\nexport http_proxy=http://192.168.1.20:7890\nexport https_proxy=http://192.168.1.20:7890\n```\n\n# profile\n\n在 `~/.profile` 持久化当前用户的代理，全局在 `/etc/profile`\n\n```bash\nexport http_proxy=http://192.168.1.20:7890\nexport https_proxy=http://192.168.1.20:7890\n```\n\n# wget\n\n修改 `~/.wgetrc` 创建 `wget` 代理\n```bash\n#You can set the default proxies for Wget to use for http, https, and ftp.\n# They will override the value in the environment.\nhttps_proxy = http://192.168.1.20:7890\nhttp_proxy = http://192.168.1.20:7890\nftp_proxy = http://192.168.1.20:7890\n\n# If you do not want to use proxy at all, set this to off.\nuse_proxy = on\n```\n","categories":["运维"]},{"title":"造了套自己的 Promise","url":"/articles/cherry/mine-promise/","content":"\nPromise 很火，没看源码，仅参考平时的使用，造了一个小轮子（有时间再去看源码把）\n\n```js\nclass PromiseT {\n  constructor() {\n    this.status = 'running';\n    this.val = null;\n    this.pendingList = [];\n  }\n  then(...list) {\n    this.pendingList.push(...list);\n    return this.run();\n  }\n  resolve(val) {\n    this.status = 'running';\n    if (val !== undefined) {\n      this.val = val;\n    }\n    return this.run();\n  }\n  pending() {\n    this.status = 'pending';\n  }\n  run() {\n    if (this.status === 'pending') {\n      return this;\n    }\n    const cal = this.pendingList.shift();\n    if (cal === undefined) {\n      return this;\n    }\n    const result = cal(this.val, this);\n    if (result === undefined) {\n      return this.run();\n    }\n    if (result.constructor === PromiseT) {\n      return result.then(...this.pendingList);\n    }\n    this.val = result;\n    return this.run();\n  }\n}\n```\n\n测试：\n\n```js\nnew PromiseT()\n  .resolve(5)\n  .then(x => x + 1)\n  .then(x => new PromiseT().resolve(2).then(a => x / a))\n  .then(x => console.log(x))\n  .then((x, p) => {\n    p.pending();\n    setTimeout(() => {\n      p.resolve(x - 3);\n    }, 2000);\n  })\n  .then(x => console.log(x));\n\n// 输出 3\n// 等待 2s\n// 输出 0\n```\n\n毕竟是小轮子，`catch()` `finally()` 这些没写。。。\n","categories":["前端"]},{"title":"新网址！","url":"/articles/cherry/new-deploy/","content":"\nnetlify免费版的网络真的太差了（跟1年多前刚使用的时候比，差太多），所以原本打算迁移到github pages\n\n看对比，github pages整体比netlify稳定的多，但github不支持重定向。而腾讯云的解析服务，重定向需要备案，所以dnocm只好保持不动，选择新增了一个部署\n\n同时也尝试了coding，但在国外的ping不理想，所以干脆一次性部署了多个\n\n- <https://dnocm.com>(<https://www.dnocm.com>) 由netlify提供服务\n- https://jiangtj.com 由github pages提供服务\n- https://jiangtj.gitlab.io 由gitlab pages提供服务\n- <https://zh.jiangtj.com>(<https://www.jiangtj.com>) 由coding提供服务，中国访问较快\n\n假如，你在访问当前地址时，感觉卡，可以试试前往我的其他域名下\n\n![](https://jiangtj-lab.github.io/pic-repo/img-apricot/20200519112323.png)\n\n![](https://jiangtj-lab.github.io/pic-repo/img-apricot/20200519170805.png)\n"},{"title":"NPM 包代理","url":"/articles/cherry/npm-pack-proxy/","content":"\n在国外，最简单的是安装，在国内，最难得就是安装，太难了\n\n下面是一份我正在用的`.yarnrc`的配置\n\n```\ndisable-self-update-check true\nregistry \"https://registry.npm.taobao.org\"\nphantomjs_cdnurl \"https://npm.taobao.org/dist/phantomjs/\"\nelectron_mirror \"https://npm.taobao.org/mirrors/electron/\"\nelectron_builder_binaries_mirror \"https://npm.taobao.org/mirrors/electron-builder-binaries/\"\nsass_binary_site \"https://npm.taobao.org/mirrors/node-sass/\"\nprofiler_binary_host_mirror \"https://npm.taobao.org/mirrors/node-inspector/\"\nchromedriver_cdnurl \"https://cdn.npm.taobao.org/dist/chromedriver\"\noperadriver_cdnurl \"http://npm.taobao.org/mirrors/operadriver\"\nnode_sqlite3_binary_host_mirror \"http://npm.taobao.org/mirrors\"\npython_mirror \"http://npm.taobao.org/mirrors/python\"\n```\n"},{"title":"R2DBC-传统数据库也能响应式编程","url":"/articles/cherry/r2dbc/","content":"\nR2DBC 是 Reactive Relational Database Connectivity （关系型数据库的响应式连接） 的缩写，最近在项目中尝试 Webflux，被迫，使用 R2DBC 进行数据库操作（我还是更喜欢关系型数据库而不是文档型）。当然在实际使用后，发现这个框架虽然有些不足，但这才是我喜欢的DB框架\n\n这里零散的记录下我遇到的一些问题，或者钟爱的一些特性，或者自己写的小工具\n\n<!-- more -->\n\n# Repositories 未完整支持\n\n我是从Spring Data JPA迁移过来的，第一件是，就是看它的Repositories该如何去定义，怎么获取数据库中的内容。\n\n## 领域模型描述方式少\n\n首先，R2DBC未引入`javax.persistence`，所以需要使用 Spring Data 中定义的注解，Spring Data 中的注解很少，这意味着，这个框架目前它比 JPA 能做的事情少很多，比如自动生成表（我相信在实际项目中很少这么做吧）\n\n```java\n@Data\n@Table\npublic class AdminUser {\n    @Id\n    private Long id;\n    private String username;\n    @JsonProperty(access = JsonProperty.Access.WRITE_ONLY)\n    private String password;\n    private Integer isDeleted;\n}\n```\n\n但同样的，最简单的模型的代码简洁太多了，它就是一个普通的Java对象加个`@Id`注解（`@Table`可以不添加的，无影响，但是官方文档建议加上，`@Data` 是Lombok注解），目前 R2DBC 只支持以下注解\n\n- @Id: 定义那个是主键.\n- @Table: 可以用来指定表名.\n- @Transient: 不需要映射的字段，与JPA中一样.\n- @PersistenceConstructor: 如果有多个构造方法，可以用它指定某个用于读取数据后的转换.\n- @Value: 提供使用SpEL语法，获取数据的方式.\n- @Column: 定义列名.\n- @Version: 用于乐观锁的（暂时未尝试）.\n\nJPA 中的关系映射，如 `@ManyToOne` `@OneToMany`等也不支持的，所以遇到有关联的时候，需要我们自己处理\n\n## 不支持 Page<T> 与 Specifications\n\n在 JPA 中，我使用 Specifications 来查询分页内容，例如\n\n```java\npublic interface CustomerRepository extends JpaRepository<Customer, Long>, JpaSpecificationExecutor<Customer> {\n …\n}\n\nPage<Customer> page = CustomerRepository.findAll(spec, pageable);\n```\n\n实现分页很容易，虽然 Specification 写起来也有点烦\n\n`ExampleMatcher` 需要候选版的Spring Boot，最近的 R2DBC 已经支持了 `ExampleMatcher`，但 Spring Boot 中还未升级，它需要 `Spring Boot 2.5+` 但目前还只是 `Spring Boot 2.4.5`\n\n# Fluent API\n\nR2DBC 的 Repositories 支持的确太差，甚至，我都差点放弃，但 R2DBC 还支持另一种查询方式，也就是 Fluent API，先看一个例子\n\n```java\nMono<Person> first = template.select(Person.class)  \n  .from(\"other_person\")\n  .matching(query(where(\"firstname\").is(\"John\")     \n    .and(\"lastname\").in(\"Doe\", \"White\"))\n    .sort(by(desc(\"id\"))))                          \n  .one(); \n```\n\n不需要做任何说明，我相信你们都能理解这行代码的意思\n\n```sql\nselect * \n  from other_person\n  where firstname = John\n    and lastname in (\"Doe\", \"White\")\n    order by id desc\n```\n\n`one()` 不是 `limit 1`，只是表示断言获取到的数据是一条。。。\n\nFluent API 其实相当于 JAP 中 Specifications，也就是 Hibernate 中的 Criteria，目的是为了提供类型安全的查询，但是相对于 Hibernate 来说简单太多了\n\n```java\n// Hibernate\nCriteriaBuilder builder = entityManager.getCriteriaBuilder();\nCriteriaQuery<Person> criteria = builder.createQuery( Person.class );\nRoot<Person> root = criteria.from( Person.class );\ncriteria.select( root );\ncriteria.where( builder.equal( root.get( Person_.name ), \"John Doe\" ) );\nList<Person> persons = entityManager.createQuery( criteria ).getResultList();\n```\n\nFluent API 拥有接近原生SQL的写法表现，同时还能保证类型安全，未来，它必定比Mybatis还要更加优秀（未来的原因是目前无法完整支持sql语法，比如join），我使用 R2DBC 的项目已经全部使用 Fluent API 进行数据库操作而不是半残的 Repositories\n\n# 分页支持\n\n官方不支持Page<T>，原因在于生成Page<T>需要提前消费Flux<T>的数据，这是不推荐的，我们可以分成两个接口，一个用于获取数据，一个用于获取总数。但是在某些场景下，比如后台，对于性能要求不是很高，而且现有的框架已经对Page数据格式支持了，那么我们自然希望仍旧返回Page。\n\n我创建一个`PageQueryBuilder`，生成Page\n\n```java\nimport static org.springframework.data.relational.core.query.Query.query;\n\npublic class PageQueryBuilder<T> {\n\n    private final R2dbcEntityTemplate template;\n    private final Class<T> clz;\n    private Criteria criteria;\n    private Pageable pageable;\n\n    public PageQueryBuilder(R2dbcEntityTemplate template, Class<T> clz) {\n        this.template = template;\n        this.clz = clz;\n    }\n\n    public PageQueryBuilder<T> where(Criteria criteria) {\n        this.criteria = criteria;\n        return this;\n    }\n\n    public PageQueryBuilder<T> pageable(Pageable pageable) {\n        this.pageable = pageable;\n        return this;\n    }\n\n    public Mono<Page<T>> apply() {\n        return Mono.zip(selectList(), selectCount())\n            .map(tuple -> new PageImpl<>(tuple.getT1(), pageable, tuple.getT2()));\n    }\n\n    public <R> Mono<Page<R>> apply(Function<List<T>, Mono<List<R>>> fn) {\n        return Mono.zip(selectList().flatMap(fn), selectCount())\n            .map(tuple -> new PageImpl<>(tuple.getT1(), pageable, tuple.getT2()));\n    }\n\n    public <R> Mono<Page<R>> flatTuple(Function<Tuple2<List<T>, Long>, Mono<Tuple2<List<R>, Long>>> fn) {\n        return Mono.zip(selectList(), selectCount())\n            .flatMap(fn)\n            .map(tuple -> new PageImpl<>(tuple.getT1(), pageable, tuple.getT2()));\n    }\n\n    private Mono<List<T>> selectList() {\n        return template.select(clz)\n            .matching(query(criteria).with(pageable))\n            .all()\n            .collectList();\n    }\n\n    private Mono<Long> selectCount() {\n        return template.select(clz)\n            .matching(query(criteria))\n            .count();\n    }\n}\n```\n\n这样我们可以轻松的实现获取page\n\n```java\nPage<Persion> page = new PageQueryBuilder<>(template, Persion.class)\n  .where(where(\"name\").is(\"John\"))\n  .pageable(pageable)\n  .apply();\n```\n\n# 非Null字段更新\n\nR2DBC 添加是对于所以非null的字段生成sql添加，但是，更新是所有非@Id字段更新，但是我们经常会对于非null的数据更新，忽略null字段，所以我又写了个工具。。。\n\n```java\npublic interface DbUtils {\n  \n    List<String> ignoreDescriptors = Arrays.asList(\"class\");\n\n    static <T> Mono<Integer> update(R2dbcEntityTemplate template, T entity) {\n        PropertyDescriptor[] descriptors = BeanUtils.getPropertyDescriptors(entity.getClass());\n        Update update = null;\n        Query query = null;\n        for (PropertyDescriptor descriptor: descriptors) {\n            try {\n                String name = descriptor.getName();\n\n                if (ignoreDescriptors.contains(name)) {\n                    continue;\n                }\n\n                Object invoke = descriptor.getReadMethod().invoke(entity);\n                if (invoke == null) {\n                    continue;\n                }\n                if (\"id\".equals(name)) {\n                    query = query(Criteria.where(name).is(invoke));\n                } else {\n                    update = update == null? Update.update(name, invoke):\n                        update.set(name, invoke);\n                }\n            } catch (IllegalAccessException | InvocationTargetException e) {\n                e.printStackTrace();\n            }\n        }\n\n        if (query == null || update == null) {\n            return Mono.error(new BadRequestException(\"无法生成有效的Sql语句！\"));\n        }\n\n        return template.update(entity.getClass())\n            .matching(query)\n            .apply(update);\n    }\n}\n```\n\n下面是使用例子\n\n```java\nDbUtils.update(template, persion)\n```\n\n# 总结\n\n我甚至希望 Spring 能放弃对 Repositories 的支持，专心完善它的 Fluent API，可惜我在官方仓库中看到的基本都是提 Repositories 的需求，其实我也一样，一般情况 JPA 转过去的，都是先看有什么一样的API，方便入手，可是实际体验，还是Fluent API更加香啊\n","categories":["后端"],"tags":["Webflux","R2DBC"]},{"title":"Spring Boot 2.4 新的配置文件处理方式","url":"/articles/cherry/spring-boot-2-4-config/","content":"\n配置文件是 Spring Boot 的一个核心特性，自正式版发布以来，几乎未改动过，而在2.4中，Spring 官方调整了配置文件的处理逻辑\n\n- 外部配置文件优先于内部 Profile 配置\n- 重命名 `spring.profiles` 为 `spring.config.activate.on-profile`\n- 新增 Profile 组\n\n<!-- more -->\n\n# 配置文件优先级\n\n在 2.4 中，最主要的修改是调整了配置文件优先级\n\n之前，加载顺序为\n\n1. ...(其他)\n2. Jar 包外部的 Profile-specific 配置文件 (application-{profile}.properties)\n3. Jar 包内部的 Profile-specific 配置文件 (application-{profile}.properties)\n4. **Jar 包外部的主配置文件 (application.properties)**\n5. Jar 包内部的主配置文件 (application.properties)\n6. ...(其他)\n\n在这个版本中\n\n1. ...(其他)\n2. Jar 包外部的 Profile-specific 配置文件 (application-{profile}.properties)\n3. **Jar 包外部的主配置文件 (application.properties)**\n4. Jar 包内部的 Profile-specific 配置文件 (application-{profile}.properties)\n5. Jar 包内部的主配置文件 (application.properties)\n6. ...(其他)\n\n举个例子，假如有以下三个配置文件\n\nJar 包内部的 application.properties\n```\nsecret=default-password\n```\n\nJar 包内部的 application-dev.properties\n```\nsecret=dev-password\n```\n\nJar 包外部的 application.properties\n```\nsecret=prod-password\n```\n\n之前版本 `secret` 为 `dev-password`，而在新版本中 `secret` 为 `prod-password`\n\n同时用于顺序的调整，对 Profile-specific 配置文件做了一定的限制，禁止其使用 `spring.profiles.active` 和 `spring.profiles.include`，官方说的原因是，对于 `spring.config.activate.on-profile` 的判断只进行一次，所以不能嵌套使用，在实际使用中，避免这样的嵌套，可以更简洁明了\n\n另外，如果你还是希望使用以前的处理逻辑，可以添加`spring.config.use-legacy-processing=true`\n\n```yml\nspring.config.use-legacy-processing=true\n\n# any other properties\n```\n\n# 属性名调整\n\n`spring.profiles` 修改为 `spring.config.activate.on-profile`，后者更加贴近用意，这个属性只在多文档的yaml文件中用到（用`---`分成多个配置）\n\n例如在2.3或者更早，我们会进行以下配置\n\n```yml\nsecret: \"default-password\"\n---\nspring:\n  profiles: \"dev\"\nsecret: \"dev-password\"\n---\nspring:\n  profiles: \"prod\"\nsecret: \"production-password\"\n```\n\n那么当我们升级到2.4，我们需要修改成以下样子\n\n```yml\nsecret: \"default-password\"\n---\nspring:\n  config:\n    activate:\n      on-profile: \"dev\"\nsecret: \"dev-password\"\n---\nspring:\n  config:\n    activate:\n      on-profile: \"prod\"\nsecret: \"production-password\"\n```\n\n# Profile 组\n\n前面我们已经提到，由于载入顺序的变化，Spring 增加了 Profile 不能使用 `spring.profiles.active` 和 `spring.profiles.include` 的限制，但有个常用的场景，就是可能需要同时使用两个 Profile 配置， 比如线上配置了 mysql 以及 rabbitmq\n\n```yml\nspring:\n  config:\n    activate:\n      on-profile: \"mysql\"\n  datasource:\n    url: \"jdbc:mysql://localhost/test\"\n    username: \"dbuser\"\n    password: \"dbpass\"\n---\nspring:\n  config:\n    activate:\n      on-profile: \"rabbitmq\"\n  rabbitmq:\n    host: \"localhost\"\n    port: 5672\n    username: \"admin\"\n    password: \"secret\"\n```\n\n在之前，我们可以创建一个 prod 的 Profile 配置，去包含上面两个，方便启用\n\n```yml\nspring:\n  config:\n    activate:\n      on-profile: \"prod\"\n  profiles:\n    include: \"mysql,rabbitmq\"\n```\n\n但新版中已经禁止了这样的写法，所以引入了“组”的概念，方便创建相应的便捷操作\n\n```yml\nspring:\n  profiles:\n    group:\n      \"prod\": \"mysql,rabbitmq\"\n```\n\n*`spring.profiles.group` 同样不能用于 Profile 文件*\n\n# 总结\n\n尝试对自己的项目升了级，发现没有任何影响，在我的项目中，线上的配置文件习惯添加`spring.profiles.active=online`，用于阻止加载内部的 Profile 配置（现在也没创建 online 的 Profile 配置，就真只是为了阻止），这次的改动，大大点赞\n"},{"title":"为 Spring WebFlux 提供 'ApplicationEventPublisher'","url":"/articles/cherry/webflux-event/","content":"\n在 Spring 中提供了 ApplicationEventPublisher，用于发布事件，这在一些场景下十分有用，比如，当我创建一个货物，而另一个服务监听货物的创建并为其创建库存。所以在Spring MVC中很实用，我也常常用它来解耦，但是当我切换为 WebFlux 时，就尴尬了。因为 ApplicationEventPublisher 是同步操作，它并不支持响应式，即流操作。\n\n所以，我在 WebFlux 中实现一个类似的发布订阅模式，以替代 ApplicationEventPublisher\n\n<!-- more -->\n\n# 实现 Event 服务\n\n我们的事件服务分为3个部分\n\n- 对发布对象的封装\n- 设计通用的监听接口\n- 提供类似 ApplicationEventPublisher 的对象，发布事件\n\n## ObjectEventNotifier\n\n首先先对发布的对象进行封装，这步就算是 ApplicationEventPublisher，也是无法避免的，不然，你监听到一个对象，但不知道这对象是创建还是删除，这又该做什么处理呢。\n\n```java\npublic class ObjectEventNotifier<T> implements ResolvableTypeProvider {\n\n    private final T object;\n    private final Type type;\n\n    private ObjectEventNotifier(T object, Type type) {\n        this.object = object;\n        this.type = type;\n    }\n\n    public static <T> ObjectEventNotifier<T> from(T object, Type type) {\n        return new ObjectEventNotifier<>(object, type);\n    }\n\n    @Override\n    public ResolvableType getResolvableType() {\n        return ResolvableType.forClassWithGenerics(getClass(), ResolvableType.forInstance(object));\n    }\n\n    public T getObject() {\n        return this.object;\n    }\n\n    public Type getType() {\n        return this.type;\n    }\n\n    public enum Type {\n        Create, Update, Delete\n    }\n}\n```\n\n上面的类，依据枚举 Type，对对象进行分类，以便在不同情况下，做不同处理\n\n## EventListener\n\n接下来设计监听接口，一般而言，我们依据类的类型，选择不同的消费者，所以，简单的监听接口如下\n\n```java\npublic interface EventListener<T> {\n\n    Class<T> target();\n\n    Publisher<Void> consume(ObjectEventNotifier<T> consumer);\n\n}\n```\n\n但是这样，存在一个问题，当我们创建监听服务时，就会像下面那样\n\n```java\n@Bean\npublic EventListener<Goods> listener() {\n    return new EventListener<>() {\n        @Override\n        public Class<Goods> target() {\n            return Goods.class;\n        }\n        @Override\n        public Publisher<Void> consume(ObjectEventNotifier<Goods> consumer) {\n            // ...\n        }\n    };\n}\n```\n\n这代码真的是一言难尽，所以，对于监听接口必须提供一个简化版的创建方式\n\n```java\npublic interface EventListener<T> {\n    //...\n    static <T> EventListener<T> register(Class<T> target, Function<ObjectEventNotifier<T>, Publisher<Void>> fn) {\n        return new EventListener<>() {\n            @Override\n            public Class<T> target() {\n                return target;\n            }\n            @Override\n            public Publisher<Void> consume(ObjectEventNotifier<T> consumer) {\n                return fn.apply(consumer);\n            }\n        };\n    }\n}\n\n@Bean\npublic EventListener<Goods> listener() {\n    return EventListener.register(Goods.class, notifier -> ...);\n}\n```\n\n这样就好多了\n\n## EventService\n\n最后，实现我们最重要的事件服务，它分为两个部分\n\n- 接受监听服务，并基于类的类型进行分类\n- 接受发布对象，封装并依据类型，选择对应的监听服务消费\n\n第一部分，由于我们使用Spring boot，所以，我们可以让spring给我们要的已经创好的监听服务，我们只需要将 EventListener 根据类型不同，放在不同的Map里存储\n\n```java\n@Service\npublic class EventService {\n\n    public Map<String, List<Object>> store = new ConcurrentHashMap<>();\n\n    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n    public EventService(List<EventListener> listeners) {\n        listeners.forEach(listener -> {\n            this.register(listener.target(), listener::consume);\n        });\n    }\n\n    public <T> void register(Class<T> target, Function<ObjectEventNotifier<T>, Publisher<Void>> consumer) {\n        String name = target.getName();\n        List<Object> consumers = store.getOrDefault(name, null);\n        if (consumers == null) {\n            consumers = new ArrayList<>();\n            store.put(name, consumers);\n        }\n        consumers.add(consumer);\n    }\n}\n```\n\n第二部分，这是响应式中的难点，响应式是非阻塞的，所以消费者也需要返回一个非阻塞的结果，之前的接口返回是 `Publisher<Void>`，就是因为这是个未处理完的结果\n\n```java\n@Service\npublic class EventService {\n\n    public Map<String, List<Object>> store = new ConcurrentHashMap<>();\n\n    @SuppressWarnings({\"unchecked\"})\n    public <T> Flux<Void> publish(ObjectEventNotifier.Type type, T target) {\n        String name = target.getClass().getName();\n        List<Object> consumers = store.getOrDefault(name, null);\n        if (consumers == null) {\n            return Flux.empty();\n        }\n        return Flux\n            .fromIterable(consumers)\n            .flatMap(obj -> {\n                Function<ObjectEventNotifier<T>, Publisher<Void>> consumer = (Function<ObjectEventNotifier<T>, Publisher<Void>>) obj;\n                Publisher<Void> apply = consumer.apply(ObjectEventNotifier.from(target, type));\n                return apply == null ? Mono.empty() : apply;\n            });\n    }\n\n    public <T> Mono<T> publishCreate(T target) {\n        return this.publish(ObjectEventNotifier.Type.Create, target)\n            .then(Mono.just(target));\n    }\n\n    public <T> Mono<T> publishUpdate(T target) {\n        return this.publish(ObjectEventNotifier.Type.Update, target)\n            .then(Mono.just(target));\n    }\n\n    public <T> Mono<T> publishDelete(T target) {\n        return this.publish(ObjectEventNotifier.Type.Delete, target)\n            .then(Mono.just(target));\n    }\n\n}\n```\n\n主要是publish部分的代码，下面的publishCreate等，是为了快捷操作\n\n# 试试写好的 Event 服务\n\n创建一个货物服务\n\n```java\npublic class GoodsService {\n\n    @Resource\n    private EventService eventService;\n\n    public Mono<Goods> createGoods() {\n        Goods apple = Goods.of(1, \"苹果\");\n        return Mono.just(apple)\n            .flatMap(eventService::publishCreate);\n    }\n\n}\n```\n\n为 Goods 创建监听服务（创了两个，毕竟这种监听一般都是一对多的嘛）\n\n```java\n@Configuration\npublic class ServerConfiguration {\n\n    @Bean\n    public GoodsService goodsService() {\n        return new GoodsService();\n    }\n\n    @Bean\n    public StockService stockService() {\n        return new StockService();\n    }\n\n    @Bean\n    public EventListener<Goods> listener1(StockService stockService) {\n        return EventListener.register(Goods.class, stockService::initStockWithGoods1);\n    }\n\n    @Bean\n    public EventListener<Goods> listener2(StockService stockService) {\n        return EventListener.register(Goods.class, stockService::initStockWithGoods2);\n    }\n\n}\n\n@Slf4j\npublic class StockService {\n\n    public Publisher<Void> initStockWithGoods1(ObjectEventNotifier<Goods> notifier) {\n        ObjectEventNotifier.Type type = notifier.getType();\n        if (type == ObjectEventNotifier.Type.Create) {\n            log.error(\"Create stock for: \" + notifier.getObject().getName());\n            return Mono.just(Stock.of(1, 0)).then();\n        }\n        return Mono.empty();\n    }\n\n    public Publisher<Void> initStockWithGoods2(ObjectEventNotifier<Goods> notifier) {\n        log.error(\"Another listener for Goods: \" + notifier.getObject().getName());\n        return Mono.empty();\n    }\n\n}\n```\n\n创建一个测试用例，调用创建苹果\n\n```java\n@SpringBootTest\nclass GoodsServiceTest {\n\n    @Resource\n    GoodsService goodsService;\n\n    @Test\n    void createGoods() {\n        goodsService.createGoods()\n            .as(StepVerifier::create)\n            .expectNextCount(1)\n            .verifyComplete();\n    }\n}\n```\n\n运行，我们可以看到以下结果，说明在创建苹果的时候，调用了库存中的两个方法\n\n```\nCreate stock for: 苹果\nAnother listener for Goods: 苹果\n```\n\n# 源码在这里\n\n> 源码： https://github.com/jiangtj-lab/ex-flux-event\n\n> Spring 对 ApplicationEventPublisher 支持响应式技术栈的进展可以看这个Issue： https://github.com/spring-projects/spring-framework/issues/21025\n","categories":["后端"],"tags":["WebFlux","Event"]},{"title":"WinGet Windows官方的包管理工具","url":"/articles/cherry/winget/","content":"\nWinGet 是官方推出的包管理工具，它目前支持以下命令\n\n```cmd\nwinget  install   安装给定的程序包\nwinget  show      显示有关程序包的信息\nwinget  source    管理程序包的来源\nwinget  search    查找并显示程序包的基本信息\nwinget  hash      哈希安装程序的帮助程序\nwinget  validate  验证清单文件\nwinget  settings  打开设置\nwinget  features  显示实验性功能的状态\nwinget  export    导出已安装程序包的列表\nwinget  import    安装文件中的所有程序包\n```\n\n大部分命令都是很常见的，相对于Linux来说，WinGet的安装方式是下载exe mis等文件，直接运行安装，在体验上有些怪怪的。而且，从我个人使用来看，目前 WinGet 最适合的场景就是重装完系统，快速安装软件\n\n<!-- more -->\n\n这需要用到的 export 与 import 命令\n\n```cmd\nwinget export -o install.json\n```\n\n运行以上命令，将系统中支持包安装的软件生成json列表\n\n然后运行，重装完成后运行 `winget import install.json` 快速安装软件，有些不支持的软件做好记录，手动安装。这也同样适用于在不同电脑上安装熟悉的工作或娱乐环境。\n\n比如，我的列表如下\n\n{% include_code lang:json install.json %}\n\n任何地方，我要快速安装环境都只需要下下来这个json，import下就可以了，是不是很方便，那还不赶紧也弄一份自己的软件列表\n","categories":["工具"]},{"title":"Spring Cloud 平台搭建(序)：聊一聊与做些准备","url":"/articles/durian/cloud-0/","content":"\n# 开场白\n\n学技术的我相信绝大部分都是理科生，和一样，写博客会很为难，不知道怎么开场，但救星来了，那就是ChatGPT，当然，我这里不是（需要填手机号，然后提示不提供服务，哎），是new bing生成的，让我们欣赏下AI吧\n\n你好，欢迎来到我的博客。今天我想和大家聊一聊spring cloud，这是一个基于spring boot的微服务框架，它提供了一系列的组件和工具，让我们可以快速地开发和部署分布式系统。\n\n什么是微服务呢？简单地说，就是把一个大型的单体应用拆分成多个小的、独立的、可复用的服务，每个服务负责一个特定的功能或业务领域，它们之间通过轻量级的通信协议进行交互。这样做有什么好处呢？主要有以下几点：\n\n- 可扩展性：当某个服务需要扩容或缩容时，我们只需要对该服务进行操作，而不影响其他服务。\n- 灵活性：当某个服务需要更新或替换时，我们只需要对该服务进行操作，而不影响其他服务。\n- 容错性：当某个服务出现故障时，我们可以快速地恢复或切换到备用方案，而不影响其他服务。\n- 解耦性：每个服务都有自己的数据存储和业务逻辑，它们之间通过定义好的接口进行交互，这样可以降低耦合度和依赖性。\n\n当然，微服务也有一些挑战和问题，比如：\n\n<!-- more -->\n\n- 服务治理：如何管理众多的微服务？如何保证它们之间的协调和一致性？如何监控和追踪它们的状态和性能？\n- 服务发现：如何让微服务之间找到彼此？如何处理动态变化的网络地址和端口？\n- 服务配置：如何统一管理微服务的配置信息？如何实现配置信息的动态更新和刷新？\n- 服务熔断：如何防止某个故障的微服务导致整个系统崩溃？如何实现故障隔离和降级策略？\n- 服务网关：如何为外部客户端提供统一的访问入口？如何实现负载均衡、路由转发、认证授权、限流熔断等功能？\n\n这就是spring cloud要解决的问题。spring cloud是一个生态系统，它包含了多个子项目，每个子项目都针对上述问题提供了一个解决方案。例如：\n\n- Eureka：一个基于RESTful风格的注册中心，提供了微服务之间的发现与注册功能。\n- Config：一个集中式配置管理工具，提供了从外部源（比如Git）获取配置信息并推送给各个微服务的功能。\n- Hystrix：一个断路器模式实现工具，提供了故障检测、熔断保护、降级处理等功能。\n- Zuul：一个基于过滤器模式实现的网关工具，提供了路由转发、认证授权、限流熔断等功能。\n- Ribbon：一个客户端负载均衡工具，在调用其他微服 务时自动选择最优节点。\n- Feign: 一个声明式RESTful客户端工具，在调用其他微服 务时自动封装请求参数并解析响应结果。\n\n除此之外还有很多其他子项目，在这里就不一一介绍了。如果你想深入学习spring cloud，请参考官方文档\n\n# 准备做什么\n\n挺震撼的，现在的AI生成介绍类内容已经不比人类差了。上面那段话除了有点过时之外，并没有什么问题，而且我准备写的内容也不是一个个集成spring cloud组件的例子，所以过时的内容影响不大，也懒得改了\n\n关于spring cloud平台搭建，主要考虑的是简单易用，能开箱即用，所以在组件的选择上会选用特定的组件来集成。如果你想全面地了解spring cloud，也许其他教程会更合适。当然，如果只是想了解基本概念，我推荐你看《微服务设计》这本书。\n\n废话不多说了，让我们开始准备搭建整个平台吧。在学习之前，让我们先创建一个根项目\n\n# 创建 parent 项目\n\n首先创建一个parent项目，你可以用maven的命令行也可以用ide创建，但是最简单的是直接拷贝一个`pom.xml`文件，因为这是个管理依赖版本的父工程，不需要其他的文件，如果用ide创建可能还要删除一些文件\n\n修改`pom.xml`为以下内容\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>com.jtj.cloud</groupId>\n    <artifactId>parent</artifactId>\n    <packaging>pom</packaging>\n    <version>1.0.0</version>\n\n    <parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>3.0.4</version>\n        <relativePath/> <!-- lookup parent from repository -->\n    </parent>\n\n    <properties>\n        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n        <java.version>17</java.version>\n        <spring-cloud.version>2022.0.1</spring-cloud.version>\n        <spring-cloud-alibaba.version>2022.0.0.0-RC1</spring-cloud-alibaba.version>\n        <spring-boot-admin.version>3.0.1</spring-boot-admin.version>\n        <jjwt.version>0.11.5</jjwt.version>\n        <!-- <maven.test.skip>true</maven.test.skip> -->\n    </properties>\n\n    <modules>\n    </modules>\n\n    <dependencyManagement>\n        <dependencies>\n            <dependency>\n                <groupId>io.jsonwebtoken</groupId>\n                <artifactId>jjwt-api</artifactId>\n                <version>${jjwt.version}</version>\n            </dependency>\n            <dependency>\n                <groupId>io.jsonwebtoken</groupId>\n                <artifactId>jjwt-impl</artifactId>\n                <version>${jjwt.version}</version>\n            </dependency>\n            <dependency>\n                <groupId>io.jsonwebtoken</groupId>\n                <artifactId>jjwt-jackson</artifactId>\n                <version>${jjwt.version}</version>\n            </dependency>\n            <dependency>\n                <groupId>org.springframework.cloud</groupId>\n                <artifactId>spring-cloud-dependencies</artifactId>\n                <version>${spring-cloud.version}</version>\n                <type>pom</type>\n                <scope>import</scope>\n            </dependency>\n            <dependency>\n                <groupId>de.codecentric</groupId>\n                <artifactId>spring-boot-admin-dependencies</artifactId>\n                <version>${spring-boot-admin.version}</version>\n                <type>pom</type>\n                <scope>import</scope>\n            </dependency>\n            <dependency>\n                <groupId>com.alibaba.cloud</groupId>\n                <artifactId>spring-cloud-alibaba-dependencies</artifactId>\n                <version>${spring-cloud-alibaba.version}</version>\n                <type>pom</type>\n                <scope>import</scope>\n            </dependency>\n        </dependencies>\n    </dependencyManagement>\n</project>\n```\n\n按照规范，我的包名应该为`com.jiangtj`，毕竟jiangtj.com这个域名才是我的，这项目是在一个很早前的项目上改的懒得改路径\n\n# 基础业务模块\n\n除了父项目，我们还需要添加两个子模块，`base-reactive` `base-servlet`，他们分别是spring 5开始的两个web类型，好用的平台自然是要都兼容的（主要我喜欢`base-reactive`，但它还是不怎么完善）\n\n如果idea，直接选择创建模块在选择spring initializr，再选择相应的web依赖就好\n\n然后修改pom文件的父依赖\n\n```xml\n    <parent>\n        <groupId>com.jtj.cloud</groupId>\n        <artifactId>parent</artifactId>\n        <version>1.0.0</version>\n    </parent>\n```\n\n在parent的pom中也添加这两模块\n\n```xml\n\n    <modules>\n        <!-- template -->\n        <module>base-reactive</module>\n        <module>base-servlet</module>\n    </modules>\n```\n\n最终的项目结构是这样的，一个管理依赖版本的父项目，和两个模块，哦对了，把`.mvn` `mvnw` `mvnw.cmd`复制到外边，这东西怎么说的，如果你自动化部署会用到，调用能自动下载maven\n\n![](https://raw.githubusercontent.com/jiangtj/picgo-repo/master/img-a20230321175410.png)\n\n# 尾\n\n事实上，在写这篇文章的时候，我已经写了一部分了，原本我并没有写博客的打算，项目也是给我自己用的，用于快速搭建一个可用的平台，但突然想到了AI，所以后面文章的风格也会这样，由AI辅助，它会帮我写概念相关的东西，而我更关注实际项目，项目已经开源在GitHub上了，https://github.com/jiangtj/spring-cloud-examples，期待你们的星星\n\n\n","categories":["后端"],"tags":["Spring Cloud 平台搭建"]},{"title":"Spring Cloud 平台搭建(一)：服务注册与配置中心Nacos","url":"/articles/durian/cloud-1/","content":"\n# Nacos 是什么？\n\nNacos 是一个易用的动态服务发现、配置和服务管理平台，可以帮助你在云原生时代，轻松构建、交付、管理自己的微服务平台，快速复用和组合业务服务，快速交付商业创新的价值。\n\nNacos 是阿里巴巴开源的一个项目，它的名字来源于Na ming and Co nfiguration S ervice。nacos提供了以下几个核心功能：\n\nNacos 提供了以下主要功能：\n\n- **动态服务发现**：Nacos 可以让你注册和发现各种类型的微服务，包括 HTTP、RPC 和 WebSocket 等，并提供负载均衡、流量控制和故障转移等能力。\n- **动态配置管理**：Nacos 可以让你集中管理应用的配置信息，并支持配置变更推送、版本控制和灰度发布等功能。\n- **动态 DNS 服务**：Nacos 可以让你基于权重路由请求到不同的后端集群，并支持域名解析、健康检查和故障隔离等功能。\n- **服务及其元数据管理**：Nacos 可以让你存储和查询微服务及其元数据信息，并支持元数据驱动的开发模式。\n\n# 为什么要使用 Nacos？\n\n在微服务架构中，我们需要解决以下几个问题：\n\n- 如何发现和调用其他微服务？\n- 如何管理微服务之间的依赖关系？\n- 如何动态调整微服务的配置？\n- 如何保证微服务之间的高可用性和弹性？\n- 如何实现微服务之间的分布式事务？\n\n这些问题都需要一个强大而灵活的中间件来支撑。而 Nacos 正是这样一个中间件，它可以为我们提供一站式的解决方案。\n\n# 快速上手吧\n\nNacos 官方提供了许多的部署方式，他们在 `nacos-group` 组织里，比如 `nacos-docker` 提供在 docker 运行 Nacos，提供了很多个 docker compose 编排脚本，还有 `nacos-k8s` 提供了些 k8s 下的脚本\n\n不过，开发环境下，我们只要能快速运行起来就好，运行以下命令\n\n```shell\ndocker run --name nacos-quick -e MODE=standalone -p 8848:8848 -p 9848:9848 -d nacos/nacos-server:v2.2.0\n```\n\n修改版本号到最新版本，这样服务就运行在了`8848`端口上(`9848`是节点间通讯的端口，用于集群)，打开 localhost:8848/nacos，输入默认的用户名密码nacos，就可以看到管理界面了\n\n![](https://raw.githubusercontent.com/jiangtj/picgo-repo/master/img-a20230322093428.png)\n\n接下来，在[两个基础业务模块](https://jiangtj.com/articles/durian/cloud-0/#%E5%9F%BA%E7%A1%80%E4%B8%9A%E5%8A%A1%E6%A8%A1%E5%9D%97)中添加服务注册需要的依赖\n\n```xml\n        <dependency>\n            <groupId>com.alibaba.cloud</groupId>\n            <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>com.alibaba.cloud</groupId>\n            <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>\n        </dependency>\n```\n\n在Applications中添加注解启用\n\n```java\n@SpringBootApplication\n@EnableDiscoveryClient\npublic class BaseServletApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(BaseServletApplication.class, args);\n    }\n}\n```\n\n除此之外，你还需要更改配置文件，配置 Nacos 配置中心地址以及以 Nacos 协议导入配置\n\n```properties\nspring.cloud.nacos.config.server-addr=127.0.0.1:8848\nspring.config.import=nacos:auth.properties\n# 如果你希望支持动态刷新的话，添加?refresh=true\n# spring.config.import=nacos:auth.properties?refresh=true\n```\n\n在 Nacos 管理平台上添加 `auth.properties` 这是后面鉴权时会用到的（`secret` 填长一点），这里暂时只是介绍怎么用 Nacos 配置中心\n\n![](https://raw.githubusercontent.com/jiangtj/picgo-repo/master/img-a20230322093727.png)\n\n如果你需要引入多个配置文件，只需要填写多个import，用逗号隔开即可\n\n```properties\nspring.cloud.nacos.config.server-addr=127.0.0.1:8848\nspring.config.import=nacos:auth.properties,nacos:base-servlet.properties\n```\n\n运行两个服务后（修改为不同端口，我是17000与17001），我们可以观察到，他们在服务注册中心注册了\n\n![](https://raw.githubusercontent.com/jiangtj/picgo-repo/master/img-a20230322093606.png)\n\n# 线上怎么部署？\n\n线上部署与开发其实差不多，不过多指定一个数据库即可，下面是官方的mysql8单机的例子，已经很完善了，不需要修改，数据库挂载卷也都是配好的。另外 Nacos 是支持环境变量配置的，如果你是外部数据库，可以配置 `MYSQL_SERVICE_HOST` 等变量就好了\n\n```yml\nversion: \"3.8\"\nservices:\n  nacos:\n    image: nacos/nacos-server:${NACOS_VERSION}\n    container_name: nacos-standalone-mysql\n    env_file:\n      - ../env/nacos-standlone-mysql.env\n    volumes:\n      - ./standalone-logs/:/home/nacos/logs\n    ports:\n      - \"8848:8848\"\n      - \"9848:9848\"\n    depends_on:\n      mysql:\n        condition: service_healthy\n    restart: always\n  mysql:\n    container_name: mysql\n    build:\n      context: .\n      dockerfile: ./image/mysql/8/Dockerfile\n    image: example/mysql:8.0.30\n    env_file:\n      - ../env/mysql.env\n    volumes:\n      - ./mysql:/var/lib/mysql\n    ports:\n      - \"3306:3306\"\n    healthcheck:\n      test: [ \"CMD\", \"mysqladmin\" ,\"ping\", \"-h\", \"localhost\" ]\n      interval: 5s\n      timeout: 10s\n      retries: 10\n```\n\n我这边推荐的是单例部署，毕竟这只是服务注册与配置中心，没有太多的并发请求，如果单例无法满足，那么你们的体量应当上 k8s，而 spring cloud 也有针对 k8s 的依赖，可以使用 k8s 的服务注册发现与配置功能。k8s可能是更好的选择，但我不使用的原因是，对于开发人员来说 nacos 更熟悉与易上手，而能看到这篇教程的人，我相信你也在思考如何搭建微服务平台，那么在你面前有两条路，要么一步到位 k8s，要就是逐步完善，因为在早期，nacos 就已经足够了，而即便到了后期，也只需替换部分依赖与修改部分公用组件而已\n","categories":["后端"],"tags":["Spring Cloud 平台搭建"]},{"title":"Spring Cloud 平台搭建(二)：统一异常处理 RFC 7807","url":"/articles/durian/cloud-2/","content":"\n兄弟们，上强度啦，你们觉得微服务搭建过程什么最重要？说实话，我也不清楚，但是我知道，规范一定是最重要的那部分之一\n\n# RFC 7807 定义\n\n微服务规范最重要的就是服务间的调用，目前来说绝大多数都是restful接口，请求成功直接会返回业务数据，失败的话，一般都是抛出运行时异常，并统一捕获转化为对应的http状态码以及描述错误Json内容，这部分一般都是自定义的，但最近我看到了Spring最新官方文档其中Error Responses部分\n\n![](https://raw.githubusercontent.com/jiangtj/picgo-repo/master/img-a20230323142900.png)\n\n是的，错误部分也有了一个规范，它包含五个部分\n\n- type: 问题描述文档地址，如果不存在，则\"about:blank\"\n- title: 简短的描述问题\n- status: http 状态码，比如400、401、500等\n- detail: 详细说明发生问题的原因\n- instance: 问题发生的URL地址\n\n这个和我原本自定义的错误内容差不多，所以，在这次搭建过程中，就使用了规范的定义，接下来就介绍我的开源项目[Spring Cloud Examples](https://github.com/jiangtj/spring-cloud-examples)中`micro-common`模块\n\n# 创建 micro-common 模块\n\n像之前基础业务模块一样，创建一个`micro-common`模块，然后，修改`pom.xml`文件\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n    <!-- 修改父模块 -->\n    <parent>\n        <groupId>com.jtj.cloud</groupId>\n        <artifactId>parent</artifactId>\n        <version>1.0.0</version>\n    </parent>\n    <artifactId>micro-common</artifactId>\n    <version>1.0.0</version>\n    <name>micro-common</name>\n    <description>micro-common</description>\n\n    <dependencies>\n        <!-- spring-boot-starter 是spring boot 的基本依赖 -->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter</artifactId>\n        </dependency>\n        <!-- 添加web依赖，接下来的配置都是与web相关的 -->\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-web</artifactId>\n        </dependency>\n        <!-- servlet应用需要的，有些依赖是servlet容器的，所以也需要添加，是optional -->\n        <dependency>\n            <groupId>org.apache.tomcat.embed</groupId>\n            <artifactId>tomcat-embed-core</artifactId>\n            <optional>true</optional>\n        </dependency>\n        <!-- servlet应用需要的，是optional -->\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-webmvc</artifactId>\n            <optional>true</optional>\n        </dependency>\n        <!-- reactive应用需要的，是optional -->\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-webflux</artifactId>\n            <optional>true</optional>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-configuration-processor</artifactId>\n            <optional>true</optional>\n        </dependency>\n        <dependency>\n            <groupId>org.projectlombok</groupId>\n            <artifactId>lombok</artifactId>\n            <optional>true</optional>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n    </dependencies>\n</project>\n```\n\n创建一个`BaseException`继承`ErrorResponseException`,不用原本的`ErrorResponseException`是因为难用，明明`ProblemDetail`已经包含`HttpStatusCode`，但在创建`ErrorResponseException`的时候，都得传(反正自定义一个不会错的)\n\n```java\npublic class BaseException extends ErrorResponseException {\n\n    public BaseException(HttpStatusCode status) {\n        super(status);\n    }\n\n    public BaseException(ProblemDetail body) {\n        this(body, null);\n    }\n\n    public BaseException(ProblemDetail body, @Nullable Throwable cause) {\n        super(HttpStatusCode.valueOf(body.getStatus()), body, cause);\n    }\n\n}\n```\n\n创建一个`BaseExceptionUtils`工具类，用于更方便的创建异常\n\n```java\npublic class BaseExceptionUtils {\n\n    /**\n     * 400\n     */\n    public static BaseException badRequest(String msg) {\n        return from(HttpStatus.BAD_REQUEST, msg, null);\n    }\n\n    /**\n     * 401\n     */\n    public static BaseException unauthorized(String msg) {\n        return from(HttpStatus.UNAUTHORIZED, msg, null);\n    }\n\n    /**\n     * 403\n     */\n    public static BaseException forbidden(String msg) {\n        return from(HttpStatus.FORBIDDEN, msg, null);\n    }\n\n    /**\n     * 404\n     */\n    public static BaseException notFound(String msg) {\n        return from(HttpStatus.NOT_FOUND, msg, null);\n    }\n\n    /**\n     * 500\n     */\n    public static BaseException internalServerError(String msg) {\n        return from(HttpStatus.INTERNAL_SERVER_ERROR, msg, null);\n    }\n    public static BaseException internalServerError(String msg, @Nullable Throwable cause) {\n        return from(HttpStatus.INTERNAL_SERVER_ERROR, msg, cause);\n    }\n\n    public static BaseException from(HttpStatus status, String msg, @Nullable Throwable cause) {\n        ProblemDetail problem = ProblemDetail.forStatus(status);\n        problem.setTitle(status.getReasonPhrase());\n        problem.setDetail(msg);\n        return new BaseException(problem, cause);\n    }\n\n}\n```\n\n# Reactive 应用自动配置\n\n接下来为Web应用配置统一的处理异常，先配置Reactive应用\n\n创建一个`BaseExceptionHandler`继承`WebExceptionHandler`，Reactive应用的异常会在`WebExceptionHandler`依次处理，默认的`WebExceptionHandler`是0，所以需要修改位更小的数字，使它在默认前拦截异常，我们只拦截`RuntimeException`的异常，是因为其他异常如果发现应该在业务代码中拦截修复\n\n```java\n@Slf4j\n@Order(ORDER)\npublic class BaseExceptionHandler implements WebExceptionHandler {\n\n    public final static int ORDER = -100;\n\n    @Resource\n    private NoViewResponseContext context;\n\n    @Override\n    public Mono<Void> handle(ServerWebExchange exchange, Throwable throwable) {\n        if (throwable instanceof BaseException bex) {\n            URIUtils.update(bex, exchange);\n            return ServerResponse.from(bex)\n                .flatMap(serverResponse -> serverResponse.writeTo(exchange, context));\n        }\n        if (throwable instanceof RuntimeException ex) {\n            BaseException wrapper = BaseExceptionUtils.internalServerError(ex.getMessage(), ex);\n            URIUtils.update(wrapper, exchange);\n            return ServerResponse.from(wrapper)\n                .flatMap(serverResponse -> serverResponse.writeTo(exchange, context));\n        }\n        return Mono.error(throwable);\n    }\n}\n```\n\n`ServerResponse`可以直接由`BaseException`创建，但它将输入写入`ServerWebExchange`需要一个Context，级一些编译解密器\n\n```java\npublic class NoViewResponseContext implements ServerResponse.Context {\n\n    @Resource\n    ServerCodecConfigurer serverCodecConfigurer;\n\n    @Override\n    public List<HttpMessageWriter<?>> messageWriters() {\n        return serverCodecConfigurer.getWriters();\n    }\n\n    @Override\n    public List<ViewResolver> viewResolvers() {\n        return Collections.emptyList();\n    }\n}\n```\n\n`BaseExceptionHandler`还有个`URIUtils`，用于添加instance\n\n```java\npublic class URIUtils {\n\n    public static void update(BaseException ex, ServerWebExchange exchange) {\n        URI uri = ex.getBody().getInstance();\n        if (uri == null) {\n            String path = exchange.getRequest().getPath().value();;\n            ex.setInstance(URI.create(path));\n        }\n    }\n\n}\n```\n\n最后，将我们的这些Bean注入到Spring中去\n\n```java\n@AutoConfiguration\n@ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.REACTIVE)\npublic class ReactiveExceptionAutoConfiguration {\n\n    @Bean\n    public BaseExceptionHandler baseExceptionHandler() {\n        return new BaseExceptionHandler();\n    }\n\n    @Bean\n    public NoViewResponseContext noViewResponseContext() {\n        return new NoViewResponseContext();\n    }\n\n}\n```\n\n`@AutoConfiguration`其实与`@Configuration`功能是一样的，一般用于有条件加载的情况下，例如上面，`@ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.REACTIVE)` 表示在 REACTIVE 的 web 应用环境下加载\n\n其实如果你去看了眼Spring官网文档的话，你会看到还可以用`ResponseEntityExceptionHandler`进行配置，但是，它只能转换注解的模式也就是`@RequestMapping`下，笑死，我要统一异常处理，那么必然是要连函数式模式也支持的\n\n最后，在`META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports`中添加自动配置类`ReactiveExceptionAutoConfiguration`\n\n# Servlet 应用自动配置\n\nReactive 好了之后创建 Servlet 的配置，你或许会觉得他们应该差不多吧。刚开始我也是这么想的。但是servlet有三个地方处理异常`HandlerExceptionResolver` `Filter` `ResponseEntityExceptionHandler`，他们每个有自己的作用范围\n\n- `ResponseEntityExceptionHandler`: 只处理注解模式下的异常\n- `Filter`: 处理注解模式下的异常和Filter中的异常\n- `HandlerExceptionResolver`: 处理函数式模式下的异常\n\n我当时调试的时候，真的想@#&%x~\n\n![](https://raw.githubusercontent.com/jiangtj/picgo-repo/master/img-a20230323162855.png)\n其他方便差不多到我的[开源项目](https://github.com/jiangtj/spring-cloud-examples)上看吧，不想贴源码了\n\n# 如何使用\n\n父模块中添加\n\n```xml\n    <dependencyManagement>\n        <dependencies>\n            <dependency>\n                <groupId>com.jtj.cloud</groupId>\n                <artifactId>micro-common</artifactId>\n                <version>1.0.0</version>\n            </dependency>\n        </dependencies>\n    </dependencyManagement>\n```\n\n在业务模块中添加依赖就好了\n\n```xml\n        <dependency>\n            <groupId>com.jtj.cloud</groupId>\n            <artifactId>micro-common</artifactId>\n        </dependency>\n```\n","categories":["后端"],"tags":["Spring Cloud 平台搭建"]},{"title":"Hexo Theme Cake","url":"/cake/index.html","content":"\n# 一些事\n\n![image](https://user-images.githubusercontent.com/15902347/81540257-f48c2900-93a3-11ea-8f7a-8f17636344ff.png)\n\nHexo Theme Cake是个lovely主题，基于7.1.0版本的NexT。就像蛋糕Cake，非常非常好吃，而且做起来也简单。\n\nCake取消了大量NexT上已有的功能，其中大部分能以插件形式，快速集成到该主题。如果你发现NexT有，而Cake没有的，你可以在[GitHub](https://github.com/JiangTJ/hexo-theme-cake)上提交issue，我会尽快支持这些功能。\n\n# 缘由\n\n为什么要单独独立出一个主题？这主要包含以下几点原因\n1. 实践一些新特性，大部分我都会添加至NexT中，但由于NexT的用户量，需要考虑兼容性，支持会慢些\n2. 更大的控制权，我可以做任何事，重构/去除一些有异议的功能，比如下面的例子\n  - Exturl ~~加密对于前端来说没有意义，所以会去除~~ 据说对SEO有效，但我仍然去掉了\n  - Note Tag 重构，调整其header的方式，去除了样式配置（保留一种好看的，原因是可以通过stylus自定义）\n\n> 所以如果你喜欢我的样式，可以尝试使用，如果更喜欢更多内置功能，[NexT](https://github.com/next-theme/hexo-theme-next)可能更适合你\n\n# 快速开始\n\n```bash\nyarn add hexo-theme-cake\n```\n\n修改 `theme` 为 `cake`, 如果你是一个 linux 用户, 可以执行下面的命令行. 其他用户需要手动修改.\n\n```bash\nsed -ri 's/^theme:.*/theme: cake/g' _config.yml && hexo check\n```\n\n**如果你第一次使用cake主题, 你可以执行 `hexo check` 来检测你的环境是否完整.**\n\n`hexo s`运行，你就能本地预览啦\n"},{"title":"分类","url":"/categories/index.html","content":""},{"title":"这是什么","url":"/more/index.html","content":"\n# Hi!\n距离上一次更新关于界面正好一年的时间\n这一年来，断断续续写了好几篇文章\n但更多的觉得在原地踏步\n所以之后的日子不想再这么颓废下去\n所以新的标题，新的域名，一切都重新开始\n这或许是我最好的选择吧\n但无论如何感谢您的到来\nBest Wishes In 2018.12.18\n\n# PY？\n{% shields mine %}\n\n# 大概就这些？\n- 语言: Java, JavaScript, Dart\n- 系统: Ubuntu 16, Windows 10\n- 工具: IntelliJ, VS Code, Git, Jenkins, Gitlab-CI\n- 架构: Spring Cloud, Docker\n\n# 简历\n<p>\n  <a href=\"https://pan.wps.cn/l/s8ikcg4\">\n\t  <i class=\"fa fa-heart\" aria-hidden=\"true\" style='color:black'></i> 我的简历档案，求内推呀！\n  </a>\n</p>\n\n*新域名(dnocm.com)上线了ヽ(ﾟ∀ﾟ)ﾉ━━━ｩ♪(这个域名仅仅因为够短，写起来好看，没意义哈...)*\n"},{"title":"标签","url":"/tags/index.html","content":""},{"title":"配置","url":"/cake/options/index.html","content":"\n# 修改主题配置\n\n虽然主题通过npm管理，但仍可以很方便的修改配置，hexo支持通过`theme_config`配置来覆盖主题中的配置\n\n例如，添加网站icon：\n\n```yml\ntheme_config:\n  favicons:\n    - rel: icon\n      type: image/png\n      sizes: 64x64\n      href: /images/favicon/xin-64.png\n```\n\n如果你的hexo版本大于5.0，你还以在`_config.<theme>.yml`中配置，这等效于`theme_config`\n\n完整的配置，[前往主题仓库查看](https://github.com/jiangtj/hexo-theme-cake/blob/master/_config.yml)\n\n# 注入布局\n\n[hexo-extend-injector2](https://github.com/jiangtj/hexo-extend-injector2)插件的功能，Cake主题提供这些注入点（headBegin,headEnd(head),bodyBegin,bodyEnd,header,footer,postBodyEnd,menu,postMeta,sidebar,variable,style）,如何使用见插件仓库\n\n# 替换布局文件\n\n这部分是hexo的功能，在大部分主题中都支持\n\n```js\nconst fs = require('fs');\nhexo.extend.filter.register('before_generate', function (data) {\n  hexo.theme.setView('需要替换的文件路径（相对于主题路径）', fs.readFileSync('你的自定义文件').toString());\n});\n```\n\n你也可以使用[hexo-theme-plus](https://github.com/JiangTJ/hexo-theme-plus)简化这部分工作\n"},{"title":"插件","url":"/cake/plugins/index.html","content":"\nCake通过插件集成附加的功能，而本身不包含附加功能的任何文件。所以轻量且强大。除此之外，你还可以前往[Awesome NexT](https://github.com/theme-next/awesome-next)，使用NexT主题中的插件\n\n# List\n\n下面是我所编写的插件，其中大部分是NexT原本集成的功能，被我独立出去的（＃￣～￣＃）\n\n- [hexo-cake-moon-menu](https://github.com/jiangtj-lab/hexo-cake-moon-menu): 新的右下角按钮(阅读进度与返回顶部按钮)\n- [hexo-cake-local-search](https://github.com/jiangtj-lab/hexo-cake-local-search): 本地搜索功能\n\n另外的一些插件，可能对你使用hexo有帮助\n- [hexo-netlify-cms](https://github.com/jiangtj/hexo-netlify-cms)：简化Netlify CMS（一个在线的内容编辑器）的使用\n- [hexo-extend-theme](https://github.com/jiangtj/hexo-extend-theme)：旨在外部替换主题内部的布局文件\n\n还有些例子，如果你希望自己编写插件，可以参考\n- [hexo-cake-google-analytics](https://github.com/jiangtj-lab/hexo-cake-google-analytics): Google 分析\n- [hexo-cake-math](https://github.com/jiangtj-lab/hexo-cake-math): Math支持\n- [hexo-cake-canvas-ribbon](https://github.com/jiangtj-lab/hexo-cake-canvas-ribbon): Ribbon背景\n- [hexo-cake-live2d](https://github.com/jiangtj-lab/hexo-cake-live2d): Live2d支持(与上游区别：仅Cake生成的Html文件非全部)，如果上游没问题的话请使用上游的插件，我修改的原因是，它会在`hexo-netlify-cms`生成的文件内添加js，导致其页面显示异常\n- [hexo-next-article-anchor](https://github.com/jiangtj-lab/hexo-next-article-anchor): 页面标题锚点\n- [hexo-next-wapper-tag-cloud](https://github.com/jiangtj-lab/hexo-next-wapper-tag-cloud)：封装hexo-tag-cloud插件\n\n# Use\n\n```bash\n# use npm\nnpm i <plugin-name>\n# or use yarn\nyarn add <plugin-name>\n```\n\nCake插件非常容易安装，就像普通的hexo的插件一样，唯一的区别在于在NexT或者Cake主题（[或者其它集成injector2的主题](https://github.com/jiangtj/hexo-extend-injector2)）下有效\n\n如果其它的主题的用户希望使用，请查看[hexo-extend-injector2](https://github.com/jiangtj/hexo-extend-injector2)\n"},{"url":"/downloads/code/hexo-newd.js","content":"/* eslint-disable no-undef */\n/* eslint-disable no-console */\n'use strict';\n\nfunction createNewPost(args) {\n  console.log(args);\n  // 需要将date改为正确的日期\n  args.slug = 'date-' + (args.slug || args._[0]);\n  hexo.call('new', args);\n}\n\nhexo.extend.console.register('newd', '为文件添加日期', {\n  arguments: [\n    { name: 'title', desc: '标题名' }\n  ]\n}, createNewPost);\n"},{"url":"/downloads/code/install.json","content":"{\n\t\"$schema\" : \"https://aka.ms/winget-packages.schema.2.0.json\",\n\t\"CreationDate\" : \"2021-12-02T11:49:20.258-00:00\",\n\t\"Sources\" : \n\t[\n\t\t{\n\t\t\t\"Packages\" : \n\t\t\t[\n\t\t\t\t{\n\t\t\t\t\t\"PackageIdentifier\" : \"Alibaba.aDrive\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"PackageIdentifier\" : \"360.360zip\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"PackageIdentifier\" : \"Jigsaw.OutlineManager\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"PackageIdentifier\" : \"MarkText.MarkText\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"PackageIdentifier\" : \"Canonical.Ubuntu\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"PackageIdentifier\" : \"Docker.DockerDesktop\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"PackageIdentifier\" : \"Tencent.Foxmail\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"PackageIdentifier\" : \"GitHub.GitHubDesktop\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"PackageIdentifier\" : \"Git.Git\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"PackageIdentifier\" : \"Kingsoft.WPSOffice-CN\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"PackageIdentifier\" : \"Microsoft.Edge\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"PackageIdentifier\" : \"Microsoft.WindowsTerminal\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"PackageIdentifier\" : \"Microsoft.OneDrive\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"PackageIdentifier\" : \"Postman.Postman\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"PackageIdentifier\" : \"Tencent.QQBrowser\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"PackageIdentifier\" : \"Tencent.QQMusic\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"PackageIdentifier\" : \"Sogou.QQPinyin\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"PackageIdentifier\" : \"JetBrains.Toolbox\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"PackageIdentifier\" : \"Tencent.WeChat\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"PackageIdentifier\" : \"beekeeper-studio.beekeeper-studio\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"PackageIdentifier\" : \"Tencent.QQ\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"PackageIdentifier\" : \"EpicGames.EpicGamesLauncher\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"PackageIdentifier\" : \"Microsoft.VC++2012Redist-x86\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"PackageIdentifier\" : \"OpenJS.NodeJS.LTS\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"PackageIdentifier\" : \"Yarn.Yarn\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"PackageIdentifier\" : \"Logitech.GHUB\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"PackageIdentifier\" : \"Telegram.TelegramDesktop\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"PackageIdentifier\" : \"Microsoft.dotnetRuntime.5-x64\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"PackageIdentifier\" : \"Microsoft.VisualStudioCode\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"PackageIdentifier\" : \"Oracle.JDK.17\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"PackageIdentifier\" : \"GitHub.cli\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"PackageIdentifier\" : \"Microsoft.VC++2015-2019Redist-x86\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"PackageIdentifier\" : \"Microsoft.VC++2015-2019Redist-x64\"\n\t\t\t\t}\n\t\t\t],\n\t\t\t\"SourceDetails\" : \n\t\t\t{\n\t\t\t\t\"Argument\" : \"https://winget.azureedge.net/cache\",\n\t\t\t\t\"Identifier\" : \"Microsoft.Winget.Source_8wekyb3d8bbwe\",\n\t\t\t\t\"Name\" : \"winget\",\n\t\t\t\t\"Type\" : \"Microsoft.PreIndexed.Package\"\n\t\t\t}\n\t\t}\n\t],\n\t\"WinGetVersion\" : \"1.2.3131-preview\"\n}"},{"title":"Hexo Theme Cake","url":"/en/cake/index.html","content":"\n# About\n\n![image](https://user-images.githubusercontent.com/15902347/81540257-f48c2900-93a3-11ea-8f7a-8f17636344ff.png)\n\nHexo Theme Cake is a lovely theme based on the 7.1.0 version of NexT. Just like Cake, it's very delicious, and it's easy to do.\n\nCake has eliminated a lot of features already on NexT, most of which can be quickly integrated into the theme as plugins. If you find that NexT has it and Cake doesn't, you can submit the issue on [GitHub](https://github.com/JiangTJ/hexo-theme-cake) and I will support these features as soon as possible.\n\n# Why\n\nWhy do I want to separate a topic separately? This mainly includes the following reasons\n1. Practice some new features, most of which I will add to NexT, but due to the number of NexT users, need to consider compatibility, support will be slower\n2. With greater control, I can do anything to refactor/remove some dissident features, such as the following example\n  - Exturl ~~encryption is meaningless for the front end, so it will be removed~~ , it's said to be effective for SEO, but I still removed it.\n  - Note Tag refactoring, adjusting its headers, removing style configuration (retaining a nice style, due to stylus customization)\n\n> So if you like my style, try it out. If you prefer more built-in features, [NexT](https://github.com/next-theme/hexo-theme-next) might be better for you.\n\n# Quick Start\n\n```bash\nyarn add hexo-theme-cake\n```\n\nModify `theme` to `cake`, if you are am linux user, can exec this cmd. Others modify it manually.\n\n```bash\nsed -ri 's/^theme:.*/theme: cake/g' _config.yml && hexo check\n```\n\n**If you use cake theme for the first time, you can exec `hexo check` to check whether the environment is complete.**\n\n`hexo s` runs, you can preview it locally\n"},{"title":"公告","url":"/more/bullhorn/index.html","content":"\n# 2019-03-11\n1. 使用新的图片加载方式（默认模糊图片，懒加载清晰图片），但由于宽度改为了100%，可能导致部分文章不美观。\n\n# 2018-12-19\n1. 注册了新的域名（dnocm.com），迁移站点的地址到这上\n2. 使用Netlify静态托管\n\n# 2018-11-12\n1. 重命名了文章目录 `:year/:month/:day/:title/` -> `articles/:title/` 避免日期的更改导致链接失效\n2. 文章以A-Z英文前缀的能吃的名开头\n  - almond 杏仁果 2017-2018\n  - beechnut 山毛榉坚果 2019-future\n"},{"title":"友情链接","url":"/more/friends/index.html","content":"\n\n# 永远Forever\n{% shields friends %}\n\n# 说Say\nEmmm... 这里有些还在更新，有些已经停好了好久，我尽力按最新文章的日期排序，期待你们再次更新自己的博客！\n"},{"title":"规划","url":"/more/schedule/index.html","content":"\n# 文档规范\n- almond 杏仁果 2017-2018\n- beechnut 山毛榉坚果 2019-future\n\n# 学习中\n- Spring Cloud 微服务解决方案\n- Kubernetes 基于容器技术的分布式架构\n\n# 计划\n- Sharding-Sphere 分布式数据库中间件\n- Vertx java框架\n\n<!-- more -->\n\n# 使用\n- Vue&Angular WEB MVVM框架\n- Docker 容器技术\n- JMeter 压力测试工具\n\n# 备选\n- Mycat 数据库分库分表中间件\n- Guava Google的java工具类\n- Dart 类js语言（沉迷于其它，暂无时间）\n\n# 娱乐排行\n- [TIOBE](https://www.tiobe.com/tiobe-index/)\n- [TechEmpower Benchmarks](https://www.techempower.com/benchmarks/)\n- [DB-Engines Ranking](https://db-engines.com/en/ranking)\n\n"},{"title":"工具集","url":"/more/tools/index.html","content":"\n# Tools\n- 编辑器\n  - Typora markdown编辑器\n  - VS Code 文本编辑器\n  - OneNote 笔记本\n  - IntelliJ IDEA Java开发工具\n- Git 客户端\n  - GitHub Desktop\n  - GUI\n- Fiddler 抓包工具\n- Postman 接口调试\n- Navicat 数据库客户端\n\n#  产品\n- Axure 原型模型设计\n- 亿图 流程图软件\n- Visio 流程图软件\n- MindMaster 脑图\n- Sway 微软出的故事线应用\n- Zeplin\n\n# 运维\n- CI/CD 持续集成工具\n  - GitLab-CI\n  - Jenkins\n- 数据分析\n  - TICK技术栈 数据采集、存储、分析、监控方案\n  - Grafana 多数据源数据分析\n  - Google 分析\n\n\n# 团队\n- 静态文档生成方案\n  - Docsify\n  - VuePress\n  - Hexo+NexT\n- 协作文档\n  - 石墨文档\n  - 腾讯文档\n  - WPS云文档\n- 内部沟通\n  - Slack\n  - Mattermost\n  - WeChat&QQ\n  - Telegram\n\n# 排行\n- [TIOBE](https://www.tiobe.com/tiobe-index/)\n- [TechEmpower Benchmarks](https://www.techempower.com/benchmarks/)\n- [DB-Engines Ranking](https://db-engines.com/en/ranking)\n- [Wappalyzer Technologies](https://www.wappalyzer.com/technologies)\n\n# 其他\n- 客服支持\n  - Chatra\n  - Tidio\n  - small.chat\n  - Intercom\n- 小工具\n  - Snipaste 截图工具\n  - Sticky Notes 便签\n"},{"title":"VPN教程","url":"/more/vpn/index.html","content":"\n# 提示！\n\n警惕外网的资讯，“真相”，“自由”，“民主”。\n\n教程分为两部分，一个是服务器搭建，一个是客户端\n\n# 服务端\n\n下载 [Outline Manage](https://github.com/Jigsaw-Code/outline-server/) 依据上面的内容进行配置即可完成\n\nOutline 的技术相当不错，服务端使用了docker，有能力可以了解下它所启动的两服务，尤其是另一个保持docker应用最新的服务，以后在你工作中也有可能会用到哦\n\n(如果你无法下载到 Outline Manage，可以发送email给我哦)\n\n# 客户端\n\nOutline Manage 本身就能链接到你的服务器，然后去下载一些其他客户端（Outline Manage 作为客户端实在不好用），shadowsocks或者clash，都是能用的\n\n我使用的clash，GitHub有ss转clash配置的工具，你也可以自己编写，clash的好处是，不同端有一样的规则。macos与Android支持不错，win有点差。在win电脑上，我是docker运行clash服务，并手动设置系统代理，你可以和我一样配置\n"},{"title":"Options","url":"/en/cake/options/index.html","content":"\n# Modify theme configuration\n\nAlthough themes are managed by NPM, they can be easily configured, and hexo supports overridden configurations in themes through the key `theme_config`\n\nFor example, to add a website icon:\n\n```yml\ntheme_config:\n  favicons:\n    - rel: icon\n      type: image/png\n      sizes: 64x64\n      href: /images/favicon/xin-64.png\n```\n\nIf your hexo version is greater than 5.0, you can also configure it in `config.<theme>.yml`, which is equivalent to `theme_config`\n\nFor the complete configuration, [go to the theme repository to view it](https://github.com/jiangtj/hexo-theme-cake/blob/master/_config.yml)\n\n# Inject content\n\nThis is the function of [hexo-extend-injector2](https://github.com/jiangtj/hexo-extend-injector2) plugin. Cake theme provides these injection points (headBegin, headEnd (head), bodyBegin, bodyEnd, header, footer, postBodyEnd, menu, postMeta, sidebar, variable, style), how to use see plugin warehouse\n\n# Replace layout\n\nThis part is the function of hexo, which is supported in most themes (you need to replace include with partial, and Cake can be replaced except for the root of layout).\n\n```js\nConst fs = require('fs');\nHexo.extend.filter.register('before_generate', function (data) {\n  hexo.theme.setView('File path to be replaced', fs.readFileSync('your custom file').toString());\n});\n```\n\nYou can also simplify this part of the work with [hexo-theme-plus](https://github.com/JiangTJ/hexo-theme-plus)\n"},{"title":"Plugins","url":"/en/cake/plugins/index.html","content":"\nCake integrates additional features through plugins, and does not itself contain any files with additional features. So lightweight and powerful. And you can also use NexT's plugin, go to [Awesome NexT](https://github.com/theme-next/awesome-next) to see more plugins\n\n# List\n\nThe following are the plugins I have written, most of which are the original integrated functions of NexT, which I went out independently （＃￣～￣＃）\n\n- [hexo-cake-moon-menu](https://github.com/jiangtj-lab/hexo-cake-moon-menu): New lower right button (read progress and return to top button)\n- [hexo-cake-local-search](https://github.com/jiangtj-lab/hexo-cake-local-search): Local search function\n\nSome other plugins may be helpful for you to use hexo\n- [hexo-netlify-cms](https://github.com/jiangtj/hexo-netlify-cms): Simplify the use of Netlify CMS (an online content editor)\n- [hexo-extend-theme](https://github.com/jiangtj/hexo-extend-theme): Designed to externally replace the layout files inside the theme\n\nSome examples, if you want to write your own plugin, you can refer to\n- [hexo-cake-google-analytics](https://github.com/jiangtj-lab/hexo-cake-google-analytics): Google Analytics for cake theme\n- [hexo-cake-canvas-ribbon](https://github.com/jiangtj-lab/hexo-cake-canvas-ribbon): Ribbon background\n- [hexo-cake-math](https://github.com/jiangtj-lab/hexo-cake-math): Math Support\n- [hexo-cake-live2d](https://github.com/jiangtj-lab/hexo-cake-live2d): Live2d support (different from upstream: only the Html files generated by Cake are not all)\n- [hexo-next-article-anchor](https://github.com/jiangtj-lab/hexo-next-article-anchor): Page title anchor\n- [hexo-next-wapper-tag-cloud](https://github.com/jiangtj-lab/hexo-next-wapper-tag-cloud): Encapsulate the hexo-tag-cloud plugin\n\n# Use\n\n```bash\n# use npm\nnpm i <plugin-name>\n# or use yarn\nyarn add <plugin-name>\n```\n\nThe Cake plugin is very easy to install, just like the normal hexo plugin, the only difference is that it works on NexT or Cake themes ([or other use injector2 plugin](https://github.com/jiangtj/hexo-extend-injector2)).\n\nOther themes, if the user wants to use, please goto [hexo-extend-injector2](https://github.com/jiangtj/hexo-extend-injector2).\n"},{"title":"文章","url":"/more/bullhorn/articles/index.html","content":"\n# 文章目录\n`articles/:a-z/:title/` 避免日期的更改导致链接失效\n# :a-z\n:a-z表示文章以A-Z英文前缀的能吃的名开头\n- almond 杏仁果 2017-2018\n- beechnut 山毛榉坚果 2019\n- cherry 樱桃 2020-future\n"},{"title":"技术","url":"/more/bullhorn/tech/index.html","content":"\n# 技术栈\n- 部署：Netlify\n- 存储仓库：GitHub\n- 生成工具：Hexo\n- 主题：NexT\n\n# 主题\n主题官网：<https://theme-next.org/>\n\n有幸加入theme-next组织，如果您也使用该主题，您可以通过右下角的Chatra或者邮件、Gitter、Telegram与我交流任何相关问题。\n\n同样您也可以在[GitHub](https://github.com/theme-next/hexo-theme-next)上提交你的issue，有空的话我也会关注相关issue。\n"},{"title":"QRCode","url":"/more/tools/qrcode/index.html","content":"\n请输入值：\n<textarea id='input-value' rows='5' style='width:100%'></textarea>\n\n<input type='button' onclick='generate()' value='生成' />\n\n二维码：\n<canvas id=\"canvas\"></canvas>\n\n<script src=\"https://cdn.jsdelivr.net/npm/qrcode@1.3.3/build/qrcode.min.js\" integrity=\"sha256-u+Rro3XIli4fMcm5/CrEJQ6TTaJtvdzskIim2GV6q38=\" crossorigin=\"anonymous\"></script>\n<script>\nfunction generate() {\n  QRCode.toCanvas(document.getElementById('canvas'), document.getElementById('input-value').value, function (error) {\n    if (error) console.error(error)\n    console.log('success!');\n  })\n}\n</script>\n"},{"title":"正则","url":"/more/tools/regex/index.html","content":"\n请输入匹配值：\n<textarea id='input-value' rows='5' style='width:100%'></textarea>\n\n正则表达式：<input id='regex' type='text' style='width:70%' />\n\n<input type='button' onclick='doRegex()' value='匹配' />\n\n匹配值：\n<div id='output-value'></div>\n\n<script type=\"text/javascript\">\nfunction doRegex() {\n  var patt = eval(document.getElementById('regex').value);\n  var inputValue = document.getElementById('input-value').value;\n  debugger;\n  var outputTxt = patt.exec(inputValue);\n  document.getElementById('output-value').innerHTML=outputTxt;\n}\n</script>\n\n"},{"title":"Use git submodule manage hexo theme","url":"/en/articles/beechnut/hexo-git-submodule/index.html","content":"\nNeed to reserve knowledge in advance, if you do not understand please go to Google\n- Basic Git operation (Git Init/Add/Commit/Pust/Fetch/Pull)\n- Basic Node/NPM operation (npm install) or Yarn (similar to NPM)\n- Basic Hexo command (hexo init/cl/s/g)\n\n# Initialization project\n\nFirst we create a new hexo project, the command line runs the following command\n```bash\n# Create a new hexo project\nhexo init <dir>\nCd <dir>\n```\n\nUse the Git management for this project\n```bash\nGit init\n# do something by yourself, if you want to push it to GitHub.\n```\n\nAdd the Cake theme as the Git submodule for the project\n```bash\ngit submodule add https://github.com/JiangTJ/hexo-theme-cake themes/cake\n```\n\nModify the configuration file in Hexo `theme` to `cake`\n\nA basic project can be created through the above steps. If you have already had your own blog project before this article, locate the unfinished steps and follow the instructions.\n\n# Update theme version\n\nIf the theme you are using is still being maintained, then you can get updates from remote. This operation is very simple, like this:\n```bash\ngit submodule update --remote\n```\n\nIt will pull the code from the latest master to your submodule from the remote.\n\n> If you want to modify the pull branch by `git config -f .gitmodules submodule.themes/cake.branch stable`, in general, the master branch is good enough, no need to modify\n\n# Replace with npm script\n\nThe git submodule command is not easy to remember, another way is to use the npm script to replace. Edit the `package.json` file and add the following:\n```json\n{\n  \"name\": \"mrtt-hexo-blog\",\n  \"version\": \"1.0.0\",\n  \"private\": true,\n  \"scripts\": {\n    \"update-theme\": \"git submodule update --remote\"\n  },\n  \"hexo\": {\n    \"version\": \"3.9.0\"\n  },\n  \"dependencies\": {\n    //...\n  }\n}\n```\n\nFor each update, you only need to run `npm run update-theme`\n\n# Custom Theme\n\nThis problem is often mentioned, I want to get updates from the official remote repository, but I want to be able to modify the file of the theme, add my own code, how to deal with it?\n\nOne way is to fork, and then use the theme of your fork as a submodule, but each update needs to synchronize the official update to the theme of your fork (somewhat troublesome)\n\nThe other one is introduced here: replacement. I don't make changes to the theme file, but I can create a file outside. The idea is to replace the file in the same way as the file path of the theme.\n\n## Replacement\n\nFirst, install a hexo plugin [hexo-theme-plus](https://github.com/jiangtj/hexo-theme-plus)\n```bash\nnpm i --save @jiangtj/hexo-theme-plus\n```\n\nBy default, the replacement path is already configured. If you need to modify it, modify the following configuration in hexo.\n```yml\ntheme_plus:\n  custom_path: custom/theme # disabled: set 'false'\n```\n\nCreate a corresponding theme file in `custom/theme`, such as `${theme_dir}/layout/_partials/footer.swig`, copy it to `${hexo_dir}/custom/theme/_partials/footer.swig`, then Make some changes, for example, I added a Ծ‸ Ծ to the author information.\n```html\n  <span class=\"author\" itemprop=\"copyrightHolder\">{{ theme.footer.copyright || author }} Ծ‸ Ծ</span>\n```\n\n`hexo s` run preview, we can see the bottom, the author has added Ծ‸ Ծ\n\n> Replace has a bit of defects. First, it only supports files under `layout`. Secondly, it needs theme support (using partial, you can't use the specific syntax of the template, such as include). Cake except for the `layout` root directory, all support replacement. But NexT requires you to replace the syntax of `include` `macro` etc.\n\n## Injection\n\nAnother way, you can also inject any code you want at the injection point. See my previous article [Hexo NexT Advanced Tutorial Injects](/articles/beechnut/hexo-next-injects/)\n\n# Editing on another computer\n\nIn the case of Git repository synchronization, if you need to work on another computer, the only thing you need to do is add `--recursive` to the `git clone` command.\n\n```bash\ngit clone --recursive https://github.com/your-name/your-blog\n```\n\nIf it's a GUI tool, then nothing needs to be changed. They default to adding `--recursive`\n\nIf you forget to add `--recursive`, you can execute the following command. Of course, you can also add it to your npm scripts, so you can remember it.\n\n```bash\ngit submodule init\ngit submodule update\n```\n\n# Summary\n\n1. Don't modify any theme files. I believe that replacing and injecting, you can modify any theme code, which ensures that your theme repository can be set directly to the official repository, and the update has no conflicts.\n2. There are very few commands to remember, just two `git submodule update --remote` and `git clone --recursive repo`\n"},{"title":"Hexo NexT Advanced Tutorial For Injects","url":"/en/articles/beechnut/hexo-next-injects/index.html","content":"\n> My English is not very good, so if there is a typo, please remind me, thank you very much.\n\n# Why\n\nThis goes back to March, Mimi's [PR: Adding Submodule](https://github.com/theme-next/hexo-theme-next/pull/663), and we discussed how to manage third-party dependencies. LEAFERx proposed that using NPM management would be better, he practice PR:Extract leancloud-counter to plugins [#677](https://github.com/theme-next/hexo-theme-next/pull/677) [ #707](https://github.com/theme-next/hexo-theme-next/pull/707). In my opinion, LEAFERx's solution is not good because of the complexity. So to be plugin, there are two requirements that must be met:\n\n1. Flexibility/Extensibility, in the plugin, we have to be able to modify most of the content.\n2. Simplicity, we can integrate the functions with very little code.\n\nIn addition, ivan-nginx is also concerned about documentation issues, but if it is completely independent, it is not a problem. In the meantime, I also tried [PR:Refactoring comments](https://github.com/theme-next/hexo-theme-next/pull/711). After all, the comment system is really \"bad\". A bunch of `if else`. This refactoring is a good attempt, but I can't easily get together because the impact is big (almost everyone), and then I found another solution, a plugin for Hexo [hexo-inject](https://Github.com/hexojs/hexo-inject), by customizing the content by injecting code, since hexo itself is separated from the theme, it can only provide 4 injection points, and the scalability is far from enough. But if it can be implemented in NexT, it is completely different, so I mentioned [PR: Add new filter type theme_inject](https://github.com/theme-next/hexo-theme-next/pull/868)\n\n<!-- more -->\n\n# How to use\n\nOkay, let's talk about this, let's experience how to use `theme_inject`. Of course, if you are a beginner, you can use the `custom_file_path` in the configuration file to add custom content. If you want to modify more content, then follow me step by step. The docs of Injects can be found in [NexT Document](https://theme-next.org/docs/advanced-settings#Injects). Here is an example, step by step integration [gitter](https://sidecar.gitter.im/).\n\n## Injection layout\n\nFirst, we create a js file (any name) in the hexo or theme `scripts`, add the following content. As long as it is a script inside, the hexo runtime will execute it.\n\n```js\nhexo.extend.filter.register('theme_inject', function(injects) {\n  // Name path etc. can be modified at will, in order to facilitate the following are based on the definition here\n  injects.head.file('gitter', 'views/gitter.swig', {}, {cache: true});\n});\n```\n\nIn the second step, we create a `views/gitter.swig` file and add the following.\n```html\n<script>\n  ((window.gitter = {}).chat = {}).options = {\n    Room: 'your-room-name'\n  }});\n</script>\n<script src=\"https://sidecar.gitter.im/dist/sidecar.v1.js\" async defer></script>\n```\n\n`hexo s` runs, you can see that the gitter has been integrated in the lower right corner.\n\n## Injection style\n\nNext step, we adjust the style. In the script, add more styles of injection.\n\n```js\nhexo.extend.filter.register('theme_inject', function(injects) {\n  injects.head.file('gitter', 'views/gitter.swig', {}, {cache: true});\n  injects.style.push('views/gitter.styl');\n});\n```\n\nCreate a `views/gitter.styl` file\n\n```css\n.gitter-open-chat-button {\n  background-color: slateblue;\n  margin-bottom: .8rem;\n  margin-right: 1rem;\n  padding: .4rem .8rem;\n  border-radius: .6rem;\n  box-shadow: 0 0 .4rem #111;\n  opacity: .9;\n}\n\n.gitter-open-chat-button:focus,.gitter-open-chat-button:hover {\n  background-color: slateblue;\n  box-shadow: 0px 0px 0.8rem #111;\n}\n\n.gitter-open-chat-button.is-collapsed {\n  transform: translateY(150%);\n}\n\n.sidebar-toggle {\n  margin-bottom: 18px;\n}\n```\n\nRun it again, the style of the button changes, do you think it is better than the original or...?\n\n# Make a npm plugin\n\nThe spirit of open source lies in sharing. When you customize your theme, you may write an article \"How to implement XXXX in NexT\". Then, after Visitor saw it, and followed you. Although there is no problem. But after all, \"lazy\" is the intent. If we can put it all into an NPM plugin, then they only need `yarn add xxxx` when they use it. How convenient it will be! ! !\n\nThe next step is to implement a plug-in that slides to the bottom/head and read progress. The final effect is seen in [hexo-cake-moon-menu](https://github.com/jiangtj-lab/hexo-cake-moon-menu)\n\nIn order to be uploaded to the NPM repository, you first need to create an account on it: <https://www.npmjs.com/>, and for convenience, I use yarn as a command line tool.\n\n## Initializing an NPM package\n\nCreate a new folder and run `yarn init` in it, you will be asked a series of questions (such as the following), after initialization will initialize a package.json\n\n```cmd\nPS C:\\Users\\MrTT\\Desktop\\hexo-moon-menu> yarn init\nYarn init v1.16.0\nQuestion name (hexo-moon-menu): @jiangtj/hexo-moon-menu\nQuestion version (1.0.0):\nQuestion description: Hallo\nQuestion entry point (index.js):\nQuestion repository url: https://github.com/jiangtj/hexo-theme-cake.git\nQuestion author: Mr.J\nQuestion license (MIT): LGPL-3.0\nQuestion private: false\nSuccess Saved package.json\nDone in 99.85s.\n```\n\n- name suggests adding `@scope` which is `@yourname`, after all, the same name package can't upload\n- name must start with `hexo-` or `@scope/hexo-`\n\n## Create an example project for preview\n\nYou need to upload your plugin (this step is the last step, but due to hexo will detect package.json to execute the plugin, you must have the plugin first), run `yarn publish --access public` in the current project.\n\nAdd a `.gitignore`, npm will also ignore unnecessary files based on it\n```\nnode_modules/\n*.log\nexample/\n```\n\nRun the following command to create an example project\n```bash\n# Create a hexo project\nhexo init example\n# Enter the example directory\ncd example\n# Add next theme\ngit clone https://github.com/theme-next/hexo-theme-next themes/next\n# Switch theme configuration\nhexo config theme next\n# Switch scheme to Gemini, this plugin is not supported by Muse because of conflict with the sidebar. If you are interested, you can implement it in Muse.\nhexo config theme_config.scheme Gemini\n# Run preview\nhexo s\n```\n\nLink plugin\n```bash\n# Add dependencies\nyarn add \"@jiangtj/hexo-moon-menu\"\n# Create a reference to the plugin for debug\ncd ..\nyarn link\ncd example\nyarn link \"@jiangtj/hexo-moon-menu\"\n#Run preview, because nothing has been done, so nothing changes.\nhexo s\n```\n\n## Layout and style\n\nNext copy the following part of [hexo-cake-moon-menu](https://github.com/jiangtj-lab/hexo-cake-moon-menu) in my project to your plugin project.\n- default.yaml default configuration\n- moon-menu.swig layout of the menu\n- moon-menu.styl style of the menu\n\nIn the above use of Injects, you can understand that the focus is on js scripts. Styles layout etc are organized through it, so I ignore the style, if you want to study you can view those.\n\n## Script\n\nThe main in package.json defines the script's entry file. The default is `index.js`, so we create it and add the following\n\n```js\n// Need to load dependencies\nconst yaml = require('js-yaml');\nconst fs = require('fs');\nconst path = require('path');\n\nhexo.extend.filter.register('theme_inject', function(injects) {\n\n  // need to disable the original button\n  hexo.theme.config.back2top.enable = false;\n\n  // Read the default configuration file\n  // __dirname to the absolute directory of the file, you need to pay attention to the location here. If you do not use path to get the absolute path, the file readout will be abnormal (recommended, try npm pit)\n  let defaultConfig = yaml.load(fs.readFileSync(path.join(__dirname, 'default.yaml')));\n  // Merge default configuration with moon_menu configuration in hexo\n  let moonMenu = Object.assign(defaultConfig, hexo.config.moon_menu);\n\n  // Reorganize menus, sort, etc.\n  let moonMenuArr = Object.keys(moonMenu)\n    .map(key => moonMenu[key])\n    .map(item => {\n      Item.order = item.order || 0;\n      If (item.enable === undefined) {\n        Item.enable = true;\n      }\n      Return item;\n    })\n    .filter(item => item.enable)\n    .sort((a, b) => a.order - b.order);\n\n  // Add layout\n  injects.bodyEnd.file('moon-menu', path.join(__dirname, 'moon-menu.swig'), {menus: moonMenuArr}, {cache: true, only: true});\n  // Add style\n  injects.style.push(path.join(__dirname, 'moon-menu.styl'));\n\n});\n```\n\nAnd you need to add `js-yaml` dependency for parsing yaml\n```bash\ncd ..\nyarn add js-yaml\ncd example\nhexo s\n```\n\nRun the preview again and you can see the button added to your example project.\n\n## Uploading and sharing\n\nRemember to upload `yarn publish --access public` after you finish, and then try to add `yarn add @jiangtj/hexo-moon-menu` in your blog.\n\nIf you would like to more user use your plugin, please submit a PR to [Awesome-NexT](https://github.com/theme-next/awesome-next)\n\n## Others\n\nWe can also load other hexo plugins in the plugin, after adding the hexo plugin (`yarn add plugin-name`). Load the script with the following code.\n\n```js\nconst tagcloud = hexo.resolvePlugin('plugin-name')\nhexo.loadPlugin(tagcloud).then(() => {\n  hexo.log.debug('Plugin loaded: plugin-name');\n}).catch(err => {\n  hexo.log.error({err}, 'Plugin load failed: plugin-name');\n});\nhexo.extend.filter.register('theme_inject', injects => {\n  //...\n});\n```\n\n> Note: `hexo.loadPlugin` needs to be placed outside the filter, to ensure that it is executed at the first time. The above code comes from an example: [hexo-next-wapper-tag-cloud](https://github. Com/jiangtj-lab/hexo-next-wapper-tag-cloud)\n\n# Summary\n\nAlthough this theme_inject has been merged, there are still many improvements that need to be made.\n- It is necessary to make NexT more structured to provide more injection points.\n- The refactoring PR of the comment system is closed, for various reasons, I plan to re-refactor it based on theme_inject (Done).\n"}]